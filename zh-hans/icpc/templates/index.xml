<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>代码模板 on codgician</title>
    <link>https://codgician.me/zh-hans/icpc/templates/</link>
    <description>Recent content in 代码模板 on codgician</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Thu, 12 Dec 2019 20:29:35 +0800</lastBuildDate>
    
	<atom:link href="https://codgician.me/zh-hans/icpc/templates/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Math</title>
      <link>https://codgician.me/zh-hans/icpc/templates/math/</link>
      <pubDate>Thu, 12 Dec 2019 20:29:35 +0800</pubDate>
      
      <guid>https://codgician.me/zh-hans/icpc/templates/math/</guid>
      <description>pre code.sourceCode { white-space: pre; position: relative; } pre code.sourceCode span { display: inline-block; line-height: 1.25; } pre code.sourceCode span:empty { height: 1.2em; } code.sourceCode span { color: inherit; text-decoration: inherit; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { pre code.sourceCode { white-space: pre-wrap; } pre code.sourceCode span { text-indent: -5em; padding-left: 5em; }</description>
    </item>
    
    <item>
      <title>Offline Algorithms</title>
      <link>https://codgician.me/zh-hans/icpc/templates/offline-algorithms/</link>
      <pubDate>Mon, 18 Nov 2019 09:10:17 +0800</pubDate>
      
      <guid>https://codgician.me/zh-hans/icpc/templates/offline-algorithms/</guid>
      <description>莫队算法 普通莫队 typedef struct _Query { int id, qLeftPt, qRightPt; } Query; Query qArr[SIZE]; int arr[SIZE], ans[SIZE], len, qNum, pos[SIZE]; int main() { /* Some code here... */ // Partition int blockSize = sqrt(len); for (int i = 0; i &amp;lt; len; i++) pos[i] = i / blockSize; // Sort sort(qArr + 0, qArr + qNum, [](const Query &amp;amp; fst, const Query &amp;amp; snd)</description>
    </item>
    
    <item>
      <title>Data Structure</title>
      <link>https://codgician.me/zh-hans/icpc/templates/data-structure/</link>
      <pubDate>Mon, 18 Nov 2019 09:07:21 +0800</pubDate>
      
      <guid>https://codgician.me/zh-hans/icpc/templates/data-structure/</guid>
      <description>pre code.sourceCode { white-space: pre; position: relative; } pre code.sourceCode span { display: inline-block; line-height: 1.25; } pre code.sourceCode span:empty { height: 1.2em; } code.sourceCode span { color: inherit; text-decoration: inherit; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { pre code.sourceCode { white-space: pre-wrap; } pre code.sourceCode span { text-indent: -5em; padding-left: 5em; }</description>
    </item>
    
    <item>
      <title>Graph Theory</title>
      <link>https://codgician.me/zh-hans/icpc/templates/graph-theory/</link>
      <pubDate>Mon, 18 Nov 2019 09:02:35 +0800</pubDate>
      
      <guid>https://codgician.me/zh-hans/icpc/templates/graph-theory/</guid>
      <description>最短路 Dijkstra long long int dist[VERTEX_SIZE]; bool vis[VERTEX_SIZE]; void dijkstra(int startPt) { for (int i = 0; i &amp;lt; vertexNum; i++) vis[i] = false, dist[i] = LLONG_MAX; priority_queue&amp;lt;pair&amp;lt;long long int, int&amp;gt; &amp;gt; pq; pq.push(make_pair(0, startPt)); dist[startPt] = 0; while (!pq.empty()) { int cntPt = pq.top().second; pq.pop(); if (vis[cntPt]) continue; vis[cntPt] = true; for (int i = head[cntPt]; i != -1; i = edges[i].next) { int nextPt = edges[i].to;</description>
    </item>
    
  </channel>
</rss>