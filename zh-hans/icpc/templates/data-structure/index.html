<!DOCTYPE html>
<html lang="zh-hans">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#292a2d">
	<meta name="msapplication-TileColor" content="#292a2d">
<meta itemprop="name" content="Data Structure">
<meta itemprop="description" content="pre code.sourceCode { white-space: pre; position: relative; } pre code.sourceCode span { display: inline-block; line-height: 1.25; } pre code.sourceCode span:empty { height: 1.2em; } code.sourceCode span { color: inherit; text-decoration: inherit; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { pre code.sourceCode { white-space: pre-wrap; } pre code.sourceCode span { text-indent: -5em; padding-left: 5em; }">
<meta itemprop="datePublished" content="2019-11-18T09:07:21&#43;08:00" />
<meta itemprop="dateModified" content="2019-11-18T09:07:21&#43;08:00" />
<meta itemprop="wordCount" content="4146">
<meta itemprop="image" content="https://codgician.me/"/>



<meta itemprop="keywords" content="" /><meta property="og:title" content="Data Structure" />
<meta property="og:description" content="pre code.sourceCode { white-space: pre; position: relative; } pre code.sourceCode span { display: inline-block; line-height: 1.25; } pre code.sourceCode span:empty { height: 1.2em; } code.sourceCode span { color: inherit; text-decoration: inherit; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { pre code.sourceCode { white-space: pre-wrap; } pre code.sourceCode span { text-indent: -5em; padding-left: 5em; }" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://codgician.me/zh-hans/icpc/templates/data-structure/" />
<meta property="og:image" content="https://codgician.me/"/>
<meta property="article:published_time" content="2019-11-18T09:07:21+08:00" />
<meta property="article:modified_time" content="2019-11-18T09:07:21+08:00" /><meta property="og:site_name" content="codgician" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://codgician.me/"/>

<meta name="twitter:title" content="Data Structure"/>
<meta name="twitter:description" content="pre code.sourceCode { white-space: pre; position: relative; } pre code.sourceCode span { display: inline-block; line-height: 1.25; } pre code.sourceCode span:empty { height: 1.2em; } code.sourceCode span { color: inherit; text-decoration: inherit; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { pre code.sourceCode { white-space: pre-wrap; } pre code.sourceCode span { text-indent: -5em; padding-left: 5em; }"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Data Structure</title>
	<link rel="stylesheet" href="https://codgician.me/css/style.min.b30187625a7d423c3fce439bfc630ffb0606aaa670b860811f7cbea5cdd3a2ec.css" integrity="sha256-swGHYlp9Qjw/zkOb/GMP+wYGqqZwuGCBH3y+pc3Touw=" crossorigin="anonymous">
	
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha256-V8SV2MO1FUb63Bwht5Wx9x6PVHNa02gv8BgH/uH3ung=" crossorigin="anonymous">

</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="/zh-hans">codgician</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://codgician.me/zh-hans/posts/">博客</a>
				<a href="https://codgician.me/zh-hans/icpc/">竞赛</a>
				<a href="https://codgician.me/zh-hans/more/">更多</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title="目录"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://www.github.com/codgician/" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://twitter.com/codgician/" target="_blank" rel="noopener me" title="Twitter"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="https://t.me/codgician/" target="_blank" rel="noopener me" title="Telegram"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.198 2.433a2.242 2.242 0 0 0-1.022.215l-8.609 3.33c-2.068.8-4.133 1.598-5.724 2.21a405.15 405.15 0 0 1-2.849 1.09c-.42.147-.99.332-1.473.901-.728.968.193 1.798.919 2.286 1.61.516 3.275 1.009 4.654 1.472.509 1.793.997 3.592 1.48 5.388.16.36.506.494.864.498l-.002.018s.281.028.555-.038a2.1 2.1 0 0 0 .933-.517c.345-.324 1.28-1.244 1.811-1.764l3.999 2.952.032.018s.442.311 1.09.355c.324.022.75-.04 1.116-.308.37-.27.613-.702.728-1.196.342-1.492 2.61-12.285 2.997-14.072l-.01.042c.27-1.006.17-1.928-.455-2.474a1.654 1.654 0 0 0-1.034-.407z"/></svg></a><a href="mailto:gutomata@outlook.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a></span><button id="menu-btn" class="hdr-btn" title="菜单"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://codgician.me/zh-hans/posts/">博客</a></li>
			<li><a href="https://codgician.me/zh-hans/icpc/">竞赛</a></li>
			<li><a href="https://codgician.me/zh-hans/more/">更多</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Nov 18, 2019</span></div>
				<h1>Data Structure</h1>
			</header>
			<div class="content">
				
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  { color: #cccccc; background-color: #303030; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ffcfaf; } /* Alert */
code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #dca3a3; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #f0dfaf; } /* ControlFlow */
code span.ch { color: #dca3a3; } /* Char */
code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code span.co { color: #7f9f7f; } /* Comment */
code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code span.do { color: #7f9f7f; } /* Documentation */
code span.dt { color: #dfdfbf; } /* DataType */
code span.dv { color: #dcdccc; } /* DecVal */
code span.er { color: #c3bf9f; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #c0bed1; } /* Float */
code span.fu { color: #efef8f; } /* Function */
code span.im { } /* Import */
code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
code span.kw { color: #f0dfaf; } /* Keyword */
code span.op { color: #f0efd0; } /* Operator */
code span.ot { color: #efef8f; } /* Other */
code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code span.sc { color: #dca3a3; } /* SpecialChar */
code span.ss { color: #cc9393; } /* SpecialString */
code span.st { color: #cc9393; } /* String */
code span.va { } /* Variable */
code span.vs { color: #cc9393; } /* VerbatimString */
code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
</style>

<div id="TOC">
<ul>
<li><a href="#st-表">ST 表</a>
<ul>
<li><a href="#朴素-rmq">朴素 RMQ</a></li>
<li><a href="#约束-rmq">约束 RMQ</a></li>
<li><a href="#随机数据时的优化">随机数据时的优化</a></li>
</ul></li>
<li><a href="#树状数组">树状数组</a>
<ul>
<li><a href="#一维前缀和最大值">一维前缀和/最大值</a></li>
<li><a href="#一维区间最大值">一维区间最大值</a></li>
<li><a href="#二维前缀和">二维前缀和</a></li>
</ul></li>
<li><a href="#线段树">线段树</a>
<ul>
<li><a href="#普通线段树">普通线段树</a></li>
<li><a href="#带-lazy-标记的线段树">带 lazy 标记的线段树</a></li>
</ul></li>
<li><a href="#可持久化线段树">可持久化线段树</a>
<ul>
<li><a href="#普通可持久化线段树">普通可持久化线段树</a></li>
<li><a href="#带-lazy-标记的可持久化线段树">带 lazy 标记的可持久化线段树</a></li>
<li><a href="#区间第-k-大">区间第 k 大</a></li>
</ul></li>
<li><a href="#平衡树">平衡树</a>
<ul>
<li><a href="#无旋转-treap">无旋转 treap</a></li>
<li><a href="#文艺平衡树">文艺平衡树</a></li>
</ul></li>
<li><a href="#字典树">字典树</a></li>
<li><a href="#policy_based_data_structures">policy_based_data_structures</a>
<ul>
<li><a href="#heap">Heap</a></li>
<li><a href="#set">Set</a></li>
</ul></li>
</ul>
</div>

<div id="st-表" class="section level2">
<h2>ST 表</h2>
<div id="朴素-rmq" class="section level3">
<h3>朴素 RMQ</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a>pair&lt;<span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>, <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>&gt; stArr[SIZE][<span class="dv">20</span>]; <span class="co">// Min, Max</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>pair&lt;<span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>, <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>&gt; minMax(<span class="at">const</span> pair&lt;<span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>, <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>&gt; &amp; fst, <span class="at">const</span> pair&lt;<span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>, <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>&gt; &amp; snd) {</span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="cf">return</span> make_pair(min(fst.first, snd.first), max(fst.second, snd.second));</span>
<span id="cb1-5"><a href="#cb1-5"></a>}</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="dt">void</span> initSt() {</span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="dt">int</span> logLim = log2(len) + <span class="dv">1</span>;</span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++)</span>
<span id="cb1-10"><a href="#cb1-10"></a>        stArr[i][<span class="dv">0</span>] = make_pair(arr[i], arr[i]);</span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= logLim; j++) {</span>
<span id="cb1-12"><a href="#cb1-12"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++) {</span>
<span id="cb1-13"><a href="#cb1-13"></a>            <span class="cf">if</span> (i + (<span class="dv">1</span> &lt;&lt; j) - <span class="dv">1</span> &gt;= len)</span>
<span id="cb1-14"><a href="#cb1-14"></a>                <span class="cf">continue</span>;</span>
<span id="cb1-15"><a href="#cb1-15"></a>            stArr[i][j] = minMax(stArr[i][j - <span class="dv">1</span>], stArr[i + (<span class="dv">1</span> &lt;&lt; (j - <span class="dv">1</span>))][j - <span class="dv">1</span>]);</span>
<span id="cb1-16"><a href="#cb1-16"></a>        }</span>
<span id="cb1-17"><a href="#cb1-17"></a>    }</span>
<span id="cb1-18"><a href="#cb1-18"></a>}</span>
<span id="cb1-19"><a href="#cb1-19"></a></span>
<span id="cb1-20"><a href="#cb1-20"></a>pair&lt;<span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>, <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>&gt; queryMinMax(<span class="dt">int</span> qLeftPt, <span class="dt">int</span> qRightPt) {</span>
<span id="cb1-21"><a href="#cb1-21"></a>    <span class="dt">int</span> lenLog = log2(qRightPt - qLeftPt + <span class="dv">1</span>);</span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="cf">return</span> minMax(stArr[qLeftPt][lenLog], stArr[qRightPt - (<span class="dv">1</span> &lt;&lt; lenLog) + <span class="dv">1</span>][lenLog]);</span>
<span id="cb1-23"><a href="#cb1-23"></a>}</span></code></pre></div>
</div>
<div id="约束-rmq" class="section level3">
<h3>约束 RMQ</h3>
<p>对于序列 <span class="math inline">\(a\)</span>，满足 <span class="math inline">\(\forall i \in [2, n], \ |a_i - a_{i - 1}| = 1\)</span>。此时预处理部分可以优化至 <span class="math inline">\(\mathcal{O}(1)\)</span>。大致思想是分块，块内分别搞一次 RMQ，块间最值再搞一次 RMQ。</p>
<p>设块大小 <span class="math inline">\(b = \frac{1}{2} \log{n}\)</span>，则块数 <span class="math inline">\(d = \lceil \frac{n}{b} \rceil\)</span>。由于相邻两个数只可能 <span class="math inline">\(\pm 1\)</span>，故块内情况只有 <span class="math inline">\(2^b = \sqrt{n}\)</span> 种不同情况。预处理时直接对所有情况进行预处理，复杂度不会超过线性。处理好后带上 offset 搞就好了。询问的时候左右不完整块内部查询，中间块外部查询。</p>
</div>
<div id="随机数据时的优化" class="section level3">
<h3>随机数据时的优化</h3>
<p>块大小为 <span class="math inline">\(b\)</span>，块内预处理前缀 <span class="math inline">\(\max\)</span> 和后缀 <span class="math inline">\(\max\)</span>，预处理的复杂度为 <span class="math inline">\(\mathcal{O}(n + \frac{n}{b} \log{\frac{n}{b}})\)</span>。若询问两端点跨不同区间则可 <span class="math inline">\(\mathcal{O}(1)\)</span> 得到（块内前后缀，块间 ST 表），而若两端跨相同区间最坏 <span class="math inline">\(\mathcal{O}(b)\)</span> 得到。考虑到询问完全随机时两端在同一区间内概率为 <span class="math inline">\(\frac{b}{n}\)</span>，则期望复杂度是 <span class="math inline">\(\mathcal{O}(\frac{b^2}{n})\)</span>。</p>
<p>总复杂度：<span class="math inline">\(\mathcal{O}(n + \frac{n}{b}\log{\frac{n}{b}} + q + q\frac{b^2}{n})\)</span></p>
<ul>
<li><span class="math inline">\(b\)</span> 至少为 <span class="math inline">\(\mathcal{O}(\log{n})\)</span> 时，预处理不超过 <span class="math inline">\(\mathcal{O}(n)\)</span>；</li>
<li><span class="math inline">\(b\)</span> 至多为 <span class="math inline">\(\mathcal{O}(\sqrt{n})\)</span> 时，询问不超过 <span class="math inline">\(\mathcal{O}(q)\)</span>；</li>
<li>如果数据不随机，大致取 <span class="math inline">\(2\sqrt{\frac{n}{q}\log{n}}\)</span> 可以让期望复杂度为 <span class="math inline">\(\mathcal{O}(n\sqrt{\log{n}})\)</span>；</li>
<li>调参即可~</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">int</span> arr[SIZE], pos[SIZE], blockSiz, blockNum, len;</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="dt">int</span> pfx[SIZE], sfx[SIZE], logs[SIZE], twoPows[<span class="dv">30</span>];</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="dt">int</span> stArr[BLK_NUM][LG_SIZE];</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">inline</span> <span class="dt">void</span> initLogs() {</span>
<span id="cb2-6"><a href="#cb2-6"></a>    logs[<span class="dv">0</span>] = -<span class="dv">1</span>;</span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; BLK_NUM; i++)</span>
<span id="cb2-8"><a href="#cb2-8"></a>        logs[i] = logs[i &gt;&gt; <span class="dv">1</span>] + <span class="dv">1</span>;</span>
<span id="cb2-9"><a href="#cb2-9"></a>    twoPows[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="dv">30</span>; i++)</span>
<span id="cb2-11"><a href="#cb2-11"></a>        twoPows[i] = twoPows[i - <span class="dv">1</span>] &lt;&lt; <span class="dv">1</span>;</span>
<span id="cb2-12"><a href="#cb2-12"></a>}</span>
<span id="cb2-13"><a href="#cb2-13"></a></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="kw">inline</span> <span class="dt">void</span> initSt() {</span>
<span id="cb2-15"><a href="#cb2-15"></a>    <span class="cf">for</span> (<span class="dt">int</span> b = <span class="dv">0</span>, l = <span class="dv">0</span>; l &lt; len; b++, l += blockSiz) {</span>
<span id="cb2-16"><a href="#cb2-16"></a>        <span class="dt">int</span> r = min(l + blockSiz, len) - <span class="dv">1</span>;</span>
<span id="cb2-17"><a href="#cb2-17"></a>        pfx[l] = arr[l]; sfx[r] = arr[r];</span>
<span id="cb2-18"><a href="#cb2-18"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = l + <span class="dv">1</span>; i &lt;= r; i++)</span>
<span id="cb2-19"><a href="#cb2-19"></a>            pfx[i] = max(pfx[i - <span class="dv">1</span>], arr[i]);</span>
<span id="cb2-20"><a href="#cb2-20"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = r - <span class="dv">1</span>; i &gt;= l; i--)</span>
<span id="cb2-21"><a href="#cb2-21"></a>            sfx[i] = max(sfx[i + <span class="dv">1</span>], arr[i]);</span>
<span id="cb2-22"><a href="#cb2-22"></a>        stArr[b][<span class="dv">0</span>] = sfx[l];</span>
<span id="cb2-23"><a href="#cb2-23"></a>    }</span>
<span id="cb2-24"><a href="#cb2-24"></a></span>
<span id="cb2-25"><a href="#cb2-25"></a>    <span class="dt">int</span> logLim = logs[blockNum];</span>
<span id="cb2-26"><a href="#cb2-26"></a>    <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= logLim; j++) {</span>
<span id="cb2-27"><a href="#cb2-27"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; blockNum; i++) {</span>
<span id="cb2-28"><a href="#cb2-28"></a>            <span class="cf">if</span> (i + twoPows[j] - <span class="dv">1</span> &gt;= blockNum)</span>
<span id="cb2-29"><a href="#cb2-29"></a>                <span class="cf">continue</span>;</span>
<span id="cb2-30"><a href="#cb2-30"></a>            stArr[i][j] = max(stArr[i][j - <span class="dv">1</span>], stArr[i + twoPows[j - <span class="dv">1</span>]][j - <span class="dv">1</span>]);</span>
<span id="cb2-31"><a href="#cb2-31"></a>        }</span>
<span id="cb2-32"><a href="#cb2-32"></a>    }</span>
<span id="cb2-33"><a href="#cb2-33"></a>}</span>
<span id="cb2-34"><a href="#cb2-34"></a></span>
<span id="cb2-35"><a href="#cb2-35"></a><span class="kw">inline</span> <span class="dt">int</span> queryMax(<span class="dt">int</span> qLeftPt, <span class="dt">int</span> qRightPt) {</span>
<span id="cb2-36"><a href="#cb2-36"></a>    <span class="cf">if</span> (pos[qLeftPt] == pos[qRightPt]) {</span>
<span id="cb2-37"><a href="#cb2-37"></a>        <span class="dt">int</span> ret = arr[qLeftPt];</span>
<span id="cb2-38"><a href="#cb2-38"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = qLeftPt + <span class="dv">1</span>; i &lt;= qRightPt; i++)</span>
<span id="cb2-39"><a href="#cb2-39"></a>            ret = max(ret, arr[i]);</span>
<span id="cb2-40"><a href="#cb2-40"></a>        <span class="cf">return</span> ret;</span>
<span id="cb2-41"><a href="#cb2-41"></a>    }</span>
<span id="cb2-42"><a href="#cb2-42"></a></span>
<span id="cb2-43"><a href="#cb2-43"></a>    <span class="dt">int</span> ret = max(sfx[qLeftPt], pfx[qRightPt]);</span>
<span id="cb2-44"><a href="#cb2-44"></a>    qLeftPt = pos[qLeftPt] + <span class="dv">1</span>, qRightPt = pos[qRightPt] - <span class="dv">1</span>;</span>
<span id="cb2-45"><a href="#cb2-45"></a>    <span class="cf">if</span> (qLeftPt &gt; qRightPt)</span>
<span id="cb2-46"><a href="#cb2-46"></a>        <span class="cf">return</span> ret; </span>
<span id="cb2-47"><a href="#cb2-47"></a>    <span class="dt">int</span> lenLog = logs[qRightPt - qLeftPt + <span class="dv">1</span>];</span>
<span id="cb2-48"><a href="#cb2-48"></a>    <span class="cf">return</span> max({ret, stArr[qLeftPt][lenLog], stArr[qRightPt - (<span class="dv">1</span> &lt;&lt; lenLog) + <span class="dv">1</span>][lenLog]});</span>
<span id="cb2-49"><a href="#cb2-49"></a>}</span>
<span id="cb2-50"><a href="#cb2-50"></a></span>
<span id="cb2-51"><a href="#cb2-51"></a><span class="dt">int</span> main() {</span>
<span id="cb2-52"><a href="#cb2-52"></a>    <span class="co">/* Some inits... */</span></span>
<span id="cb2-53"><a href="#cb2-53"></a>    blockSiz = max(<span class="dv">1</span>, (<span class="dt">int</span>)sqrt(len)); blockNum = len / blockSiz + (len % blockSiz &gt; <span class="dv">0</span>);</span>
<span id="cb2-54"><a href="#cb2-54"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++)</span>
<span id="cb2-55"><a href="#cb2-55"></a>        cin &gt;&gt; arr[i], pos[i] = i / blockSiz;</span>
<span id="cb2-56"><a href="#cb2-56"></a>    initSt();</span>
<span id="cb2-57"><a href="#cb2-57"></a>    <span class="co">/* Some queries... */</span></span>
<span id="cb2-58"><a href="#cb2-58"></a>}</span></code></pre></div>
</div>
</div>
<div id="树状数组" class="section level2">
<h2>树状数组</h2>
<div id="一维前缀和最大值" class="section level3">
<h3>一维前缀和/最大值</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="dt">int</span> lowbit(<span class="dt">int</span> n) {</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="cf">return</span> n &amp; (-n);</span>
<span id="cb3-3"><a href="#cb3-3"></a>}</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="dt">void</span> add(<span class="dt">int</span> pos, <span class="dt">int</span> val) {</span>
<span id="cb3-6"><a href="#cb3-6"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = pos; i &lt; SIZE; i += lowbit(i)) {</span>
<span id="cb3-7"><a href="#cb3-7"></a>        bit[i] += val;</span>
<span id="cb3-8"><a href="#cb3-8"></a>        <span class="co">// bit[i] = max(bit[i], val);</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    }</span>
<span id="cb3-10"><a href="#cb3-10"></a>}</span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="dt">int</span> prefixSum(<span class="dt">int</span> pos) {</span>
<span id="cb3-13"><a href="#cb3-13"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = pos; i &gt; <span class="dv">0</span>; i -= lowbit(i)) {</span>
<span id="cb3-15"><a href="#cb3-15"></a>        ans += bit[i];</span>
<span id="cb3-16"><a href="#cb3-16"></a>        <span class="co">// ans = max(ans, bit[i]);</span></span>
<span id="cb3-17"><a href="#cb3-17"></a>    }</span>
<span id="cb3-18"><a href="#cb3-18"></a>    <span class="cf">return</span> ans;</span>
<span id="cb3-19"><a href="#cb3-19"></a>}</span></code></pre></div>
</div>
<div id="一维区间最大值" class="section level3">
<h3>一维区间最大值</h3>
<p>复杂度： <span class="math inline">\(\mathcal{O}(\log^2{n})\)</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="dt">int</span> lowbit(<span class="dt">int</span> n) {</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="cf">return</span> n &amp; -n;</span>
<span id="cb4-3"><a href="#cb4-3"></a>}</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="dt">void</span> update(<span class="dt">int</span> pos, <span class="dt">int</span> val) {</span>
<span id="cb4-6"><a href="#cb4-6"></a>    arr[pos] = val; <span class="co">// Original Array</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = pos; i &lt;= num; i += lowbit(i)) {</span>
<span id="cb4-8"><a href="#cb4-8"></a>        bit[i] = val;</span>
<span id="cb4-9"><a href="#cb4-9"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt; lowbit(i); j &lt;&lt;= <span class="dv">1</span>) {</span>
<span id="cb4-10"><a href="#cb4-10"></a>            bit[i] = max(bit[i], bit[i - j]);</span>
<span id="cb4-11"><a href="#cb4-11"></a>        }</span>
<span id="cb4-12"><a href="#cb4-12"></a>    }</span>
<span id="cb4-13"><a href="#cb4-13"></a>}</span>
<span id="cb4-14"><a href="#cb4-14"></a></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="dt">int</span> query(<span class="dt">int</span> leftPt, <span class="dt">int</span> rightPt) {</span>
<span id="cb4-16"><a href="#cb4-16"></a>    <span class="dt">int</span> ans = INT_MIN;</span>
<span id="cb4-17"><a href="#cb4-17"></a>    <span class="cf">while</span> (rightPt &gt;= leftPt) {</span>
<span id="cb4-18"><a href="#cb4-18"></a>        ans = max(ans, arr[rightPt]);</span>
<span id="cb4-19"><a href="#cb4-19"></a>        rightPt--;</span>
<span id="cb4-20"><a href="#cb4-20"></a>        <span class="cf">while</span> (rightPt - lowbit(rightPt) &gt;= leftPt) {</span>
<span id="cb4-21"><a href="#cb4-21"></a>            ans = max(ans, bit[rightPt]);</span>
<span id="cb4-22"><a href="#cb4-22"></a>            rightPt -= lowbit(rightPt);</span>
<span id="cb4-23"><a href="#cb4-23"></a>        }</span>
<span id="cb4-24"><a href="#cb4-24"></a>    }</span>
<span id="cb4-25"><a href="#cb4-25"></a>    <span class="cf">return</span> ans;</span>
<span id="cb4-26"><a href="#cb4-26"></a>}</span></code></pre></div>
</div>
<div id="二维前缀和" class="section level3">
<h3>二维前缀和</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="dt">int</span> lowbit(<span class="dt">int</span> n) {</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="cf">return</span> n &amp; -n;</span>
<span id="cb5-3"><a href="#cb5-3"></a>}</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="dt">void</span> add(<span class="at">const</span> pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &amp; pos, <span class="dt">int</span> val) {</span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = pos.first; i &lt; SIZE; i += lowbit(i)) {</span>
<span id="cb5-7"><a href="#cb5-7"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = pos.second; j &lt; SIZE; j += lowbit(j)) {</span>
<span id="cb5-8"><a href="#cb5-8"></a>            bit[i][j] += val;</span>
<span id="cb5-9"><a href="#cb5-9"></a>        }</span>
<span id="cb5-10"><a href="#cb5-10"></a>    }</span>
<span id="cb5-11"><a href="#cb5-11"></a>}</span>
<span id="cb5-12"><a href="#cb5-12"></a></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="dt">int</span> getSum(<span class="at">const</span> pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &amp; pos) {</span>
<span id="cb5-14"><a href="#cb5-14"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb5-15"><a href="#cb5-15"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = pos.first; i &gt; <span class="dv">0</span>; i -= lowbit(i)) {</span>
<span id="cb5-16"><a href="#cb5-16"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = pos.second; j &gt; <span class="dv">0</span>; j -= lowbit(j)) {</span>
<span id="cb5-17"><a href="#cb5-17"></a>            ans += bit[i][j];</span>
<span id="cb5-18"><a href="#cb5-18"></a>        }</span>
<span id="cb5-19"><a href="#cb5-19"></a>    }</span>
<span id="cb5-20"><a href="#cb5-20"></a>    <span class="cf">return</span> ans;</span>
<span id="cb5-21"><a href="#cb5-21"></a>}</span>
<span id="cb5-22"><a href="#cb5-22"></a></span>
<span id="cb5-23"><a href="#cb5-23"></a><span class="dt">int</span> getRangeSum(<span class="at">const</span> pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &amp; upperLeftPt, <span class="at">const</span> pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &amp; lowerRightPt) {</span>
<span id="cb5-24"><a href="#cb5-24"></a>    <span class="dt">int</span> ans = getSum(lowerRightPt);</span>
<span id="cb5-25"><a href="#cb5-25"></a>    <span class="cf">if</span> (upperLeftPt.first &gt; <span class="dv">0</span>)</span>
<span id="cb5-26"><a href="#cb5-26"></a>        ans -= getSum(make_pair(upperLeftPt.first - <span class="dv">1</span>, lowerRightPt.second));</span>
<span id="cb5-27"><a href="#cb5-27"></a>    <span class="cf">if</span> (upperLeftPt.second &gt; <span class="dv">0</span>)</span>
<span id="cb5-28"><a href="#cb5-28"></a>        ans -= getSum(make_pair(lowerRightPt.first, upperLeftPt.second - <span class="dv">1</span>));</span>
<span id="cb5-29"><a href="#cb5-29"></a>    <span class="cf">if</span> (upperLeftPt.first &gt; <span class="dv">0</span> &amp;&amp; upperLeftPt.second &gt; <span class="dv">0</span>)</span>
<span id="cb5-30"><a href="#cb5-30"></a>        ans += getSum(make_pair(upperLeftPt.first - <span class="dv">1</span>, upperLeftPt.second - <span class="dv">1</span>));</span>
<span id="cb5-31"><a href="#cb5-31"></a>    <span class="cf">return</span> ans;</span>
<span id="cb5-32"><a href="#cb5-32"></a>}</span></code></pre></div>
</div>
</div>
<div id="线段树" class="section level2">
<h2>线段树</h2>
<div id="普通线段树" class="section level3">
<h3>普通线段树</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">#define LEFT_SON </span>(segPt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="pp">#define RIGHT_SON </span>(segPt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span><span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">typedef</span> <span class="kw">struct</span> _SegNode {</span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="dt">int</span> leftPt, rightPt;</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="dt">int</span> sum;</span>
<span id="cb6-7"><a href="#cb6-7"></a>} SegNode;</span>
<span id="cb6-8"><a href="#cb6-8"></a>SegNode segTree[SIZE &lt;&lt; <span class="dv">2</span>];</span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="dt">void</span> pushUp(<span class="dt">int</span> segPt) {</span>
<span id="cb6-11"><a href="#cb6-11"></a>    segTree[segPt].sum = segTree[LEFT_SON].sum + segTree[RIGHT_SON].sum;</span>
<span id="cb6-12"><a href="#cb6-12"></a>}</span>
<span id="cb6-13"><a href="#cb6-13"></a></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="dt">void</span> build(<span class="dt">int</span> segPt, <span class="dt">int</span> leftPt, <span class="dt">int</span> rightPt) {</span>
<span id="cb6-15"><a href="#cb6-15"></a>    segTree[segPt].leftPt = leftPt;</span>
<span id="cb6-16"><a href="#cb6-16"></a>    segTree[segPt].rightPt = rightPt;</span>
<span id="cb6-17"><a href="#cb6-17"></a></span>
<span id="cb6-18"><a href="#cb6-18"></a>    <span class="cf">if</span> (leftPt == rightPt) {</span>
<span id="cb6-19"><a href="#cb6-19"></a>        segTree[segPt].sum = <span class="dv">0</span>;</span>
<span id="cb6-20"><a href="#cb6-20"></a>        <span class="cf">return</span>;</span>
<span id="cb6-21"><a href="#cb6-21"></a>    }</span>
<span id="cb6-22"><a href="#cb6-22"></a></span>
<span id="cb6-23"><a href="#cb6-23"></a>    <span class="dt">int</span> midPt = (leftPt + rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb6-24"><a href="#cb6-24"></a>    build(LEFT_SON, leftPt, midPt);</span>
<span id="cb6-25"><a href="#cb6-25"></a>    build(RIGHT_SON, midPt + <span class="dv">1</span>, rightPt);</span>
<span id="cb6-26"><a href="#cb6-26"></a>    pushUp(segPt);</span>
<span id="cb6-27"><a href="#cb6-27"></a>}</span>
<span id="cb6-28"><a href="#cb6-28"></a></span>
<span id="cb6-29"><a href="#cb6-29"></a><span class="dt">void</span> update(<span class="dt">int</span> segPt, <span class="dt">int</span> cntPt, <span class="dt">int</span> val) {</span>
<span id="cb6-30"><a href="#cb6-30"></a>    <span class="cf">if</span> (segTree[segPt].leftPt == segTree[segPt].rightPt) {</span>
<span id="cb6-31"><a href="#cb6-31"></a>        segTree[segPt].sum = val;</span>
<span id="cb6-32"><a href="#cb6-32"></a>        <span class="cf">return</span>;</span>
<span id="cb6-33"><a href="#cb6-33"></a>    }</span>
<span id="cb6-34"><a href="#cb6-34"></a></span>
<span id="cb6-35"><a href="#cb6-35"></a>    <span class="dt">int</span> midPt = (segTree[segPt].leftPt + segTree[segPt].rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb6-36"><a href="#cb6-36"></a>    <span class="cf">if</span> (cntPt &lt;= midPt)</span>
<span id="cb6-37"><a href="#cb6-37"></a>        update(LEFT_SON, cntPt, val);</span>
<span id="cb6-38"><a href="#cb6-38"></a>    <span class="cf">else</span></span>
<span id="cb6-39"><a href="#cb6-39"></a>        update(RIGHT_SON, cntPt, val);</span>
<span id="cb6-40"><a href="#cb6-40"></a>    pushUp(segPt);</span>
<span id="cb6-41"><a href="#cb6-41"></a>}</span>
<span id="cb6-42"><a href="#cb6-42"></a></span>
<span id="cb6-43"><a href="#cb6-43"></a><span class="dt">int</span> querySum(<span class="dt">int</span> segPt, <span class="dt">int</span> qLeftPt, <span class="dt">int</span> qRightPt) {</span>
<span id="cb6-44"><a href="#cb6-44"></a>    <span class="cf">if</span> (segTree[segPt].leftPt &gt;= qLeftPt &amp;&amp; segTree[segPt].rightPt &lt;= qRightPt) {</span>
<span id="cb6-45"><a href="#cb6-45"></a>        <span class="cf">return</span> segTree[segPt].sum;</span>
<span id="cb6-46"><a href="#cb6-46"></a>    }</span>
<span id="cb6-47"><a href="#cb6-47"></a></span>
<span id="cb6-48"><a href="#cb6-48"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb6-49"><a href="#cb6-49"></a>    <span class="dt">int</span> midPt = (segTree[segPt].leftPt + segTree[segPt].rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb6-50"><a href="#cb6-50"></a>    <span class="cf">if</span> (qLeftPt &lt;= midPt)</span>
<span id="cb6-51"><a href="#cb6-51"></a>        ans += querySum(LEFT_SON, qLeftPt, qRightPt);</span>
<span id="cb6-52"><a href="#cb6-52"></a>    <span class="cf">if</span> (qRightPt &gt; midPt)</span>
<span id="cb6-53"><a href="#cb6-53"></a>        ans += querySum(RIGHT_SON, qLeftPt, qRightPt);</span>
<span id="cb6-54"><a href="#cb6-54"></a>    <span class="cf">return</span> ans;</span>
<span id="cb6-55"><a href="#cb6-55"></a>}</span></code></pre></div>
</div>
<div id="带-lazy-标记的线段树" class="section level3">
<h3>带 lazy 标记的线段树</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#define LEFT_SON </span>(segPt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="pp">#define RIGHT_SON </span>(segPt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span><span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="kw">typedef</span> <span class="kw">struct</span> _SegNode {</span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="dt">int</span> leftPt, rightPt;</span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="dt">int</span> sum, lazy;</span>
<span id="cb7-7"><a href="#cb7-7"></a>} SegNode;</span>
<span id="cb7-8"><a href="#cb7-8"></a>SegNode segTree[SIZE &lt;&lt; <span class="dv">2</span>];</span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="dt">void</span> pushUp(<span class="dt">int</span> segPt) {</span>
<span id="cb7-11"><a href="#cb7-11"></a>    segTree[segPt].sum = segTree[LEFT_SON].sum + segTree[RIGHT_SON].sum;</span>
<span id="cb7-12"><a href="#cb7-12"></a>}</span>
<span id="cb7-13"><a href="#cb7-13"></a></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="dt">void</span> pushDown(<span class="dt">int</span> segPt) {</span>
<span id="cb7-15"><a href="#cb7-15"></a>    <span class="cf">if</span> (segTree[segPt].lazy != <span class="dv">0</span>) {</span>
<span id="cb7-16"><a href="#cb7-16"></a>        segTree[LEFT_SON].sum += segTree[segPt].lazy * (segTree[LEFT_SON].rightPt - segTree[LEFT_SON].leftPt + <span class="dv">1</span>);</span>
<span id="cb7-17"><a href="#cb7-17"></a>        segTree[RIGHT_SON].sum += segTree[segPt].lazy * (segTree[RIGHT_SON].rightPt - segTree[RIGHT_SON].leftPt + <span class="dv">1</span>);</span>
<span id="cb7-18"><a href="#cb7-18"></a></span>
<span id="cb7-19"><a href="#cb7-19"></a>        segTree[LEFT_SON].lazy += segTree[segPt].lazy;</span>
<span id="cb7-20"><a href="#cb7-20"></a>        segTree[RIGHT_SON].lazy += segTree[segPt].lazy;</span>
<span id="cb7-21"><a href="#cb7-21"></a></span>
<span id="cb7-22"><a href="#cb7-22"></a>        segTree[segPt].lazy = <span class="dv">0</span>;</span>
<span id="cb7-23"><a href="#cb7-23"></a>    }</span>
<span id="cb7-24"><a href="#cb7-24"></a>}</span>
<span id="cb7-25"><a href="#cb7-25"></a></span>
<span id="cb7-26"><a href="#cb7-26"></a><span class="dt">void</span> build(<span class="dt">int</span> segPt, <span class="dt">int</span> leftPt, <span class="dt">int</span> rightPt) {</span>
<span id="cb7-27"><a href="#cb7-27"></a>    segTree[segPt].leftPt = leftPt;</span>
<span id="cb7-28"><a href="#cb7-28"></a>    segTree[segPt].rightPt = rightPt;</span>
<span id="cb7-29"><a href="#cb7-29"></a>    segTree[segPt].lazy = <span class="dv">0</span>;</span>
<span id="cb7-30"><a href="#cb7-30"></a>    <span class="cf">if</span> (leftPt == rightPt) {</span>
<span id="cb7-31"><a href="#cb7-31"></a>        segTree[segPt].sum = <span class="dv">0</span>;</span>
<span id="cb7-32"><a href="#cb7-32"></a>        <span class="cf">return</span>;</span>
<span id="cb7-33"><a href="#cb7-33"></a>    }</span>
<span id="cb7-34"><a href="#cb7-34"></a>    <span class="dt">int</span> midPt = (leftPt + rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb7-35"><a href="#cb7-35"></a>    build(LEFT_SON, leftPt, midPt);</span>
<span id="cb7-36"><a href="#cb7-36"></a>    build(RIGHT_SON, midPt + <span class="dv">1</span>, rightPt);</span>
<span id="cb7-37"><a href="#cb7-37"></a>    pushUp(segPt);</span>
<span id="cb7-38"><a href="#cb7-38"></a>}</span>
<span id="cb7-39"><a href="#cb7-39"></a></span>
<span id="cb7-40"><a href="#cb7-40"></a><span class="dt">void</span> addRange(<span class="dt">int</span> segPt, <span class="dt">int</span> qLeftPt, <span class="dt">int</span> qRightPt, <span class="dt">int</span> val) {</span>
<span id="cb7-41"><a href="#cb7-41"></a>    <span class="cf">if</span> (segTree[segPt].leftPt &gt;= qLeftPt &amp;&amp; segTree[segPt].rightPt &lt;= qRightPt) {</span>
<span id="cb7-42"><a href="#cb7-42"></a>        segTree[segPt].sum += val * (segTree[segPt].rightPt - segTree[segPt].leftPt + <span class="dv">1</span>);</span>
<span id="cb7-43"><a href="#cb7-43"></a>        segTree[segPt].lazy += val;</span>
<span id="cb7-44"><a href="#cb7-44"></a>        <span class="cf">return</span>;</span>
<span id="cb7-45"><a href="#cb7-45"></a>    }</span>
<span id="cb7-46"><a href="#cb7-46"></a>    pushDown(segPt);</span>
<span id="cb7-47"><a href="#cb7-47"></a>    <span class="dt">int</span> midPt = (segTree[segPt].leftPt + segTree[segPt].rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb7-48"><a href="#cb7-48"></a>    <span class="cf">if</span> (qLeftPt &lt;= midPt)</span>
<span id="cb7-49"><a href="#cb7-49"></a>        addRange(LEFT_SON, qLeftPt, qRightPt, val);</span>
<span id="cb7-50"><a href="#cb7-50"></a>    <span class="cf">if</span> (qRightPt &gt; midPt)</span>
<span id="cb7-51"><a href="#cb7-51"></a>        addRange(RIGHT_SON, qLeftPt, qRightPt, val);</span>
<span id="cb7-52"><a href="#cb7-52"></a>    pushUp(segPt);</span>
<span id="cb7-53"><a href="#cb7-53"></a>}</span>
<span id="cb7-54"><a href="#cb7-54"></a></span>
<span id="cb7-55"><a href="#cb7-55"></a><span class="dt">int</span> querySum(<span class="dt">int</span> segPt, <span class="dt">int</span> qLeftPt, <span class="dt">int</span> qRightPt) {</span>
<span id="cb7-56"><a href="#cb7-56"></a>    <span class="cf">if</span> (segTree[segPt].leftPt &gt;= qLeftPt &amp;&amp; segTree[segPt].rightPt &lt;= qRightPt) {</span>
<span id="cb7-57"><a href="#cb7-57"></a>        <span class="cf">return</span> segTree[segPt].sum;</span>
<span id="cb7-58"><a href="#cb7-58"></a>    }</span>
<span id="cb7-59"><a href="#cb7-59"></a>    pushDown(segPt);</span>
<span id="cb7-60"><a href="#cb7-60"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb7-61"><a href="#cb7-61"></a>    <span class="dt">int</span> midPt = (segTree[segPt].leftPt + segTree[segPt].rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb7-62"><a href="#cb7-62"></a>    <span class="cf">if</span> (qLeftPt &lt;= midPt)</span>
<span id="cb7-63"><a href="#cb7-63"></a>        ans += querySum(LEFT_SON, qLeftPt, qRightPt);</span>
<span id="cb7-64"><a href="#cb7-64"></a>    <span class="cf">if</span> (qRightPt &gt; midPt)</span>
<span id="cb7-65"><a href="#cb7-65"></a>        ans += querySum(RIGHT_SON, qLeftPt, qRightPt);</span>
<span id="cb7-66"><a href="#cb7-66"></a>    <span class="cf">return</span> ans;</span>
<span id="cb7-67"><a href="#cb7-67"></a>}</span></code></pre></div>
</div>
</div>
<div id="可持久化线段树" class="section level2">
<h2>可持久化线段树</h2>
<div id="普通可持久化线段树" class="section level3">
<h3>普通可持久化线段树</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="pp">#define LSON</span>(x)<span class="pp"> </span>segTree[x].leftSon</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="pp">#define RSON</span>(x)<span class="pp"> </span>segTree[x].rightSon</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">typedef</span> <span class="kw">struct</span> _SegNode {</span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="dt">int</span> sum;</span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="dt">int</span> leftSon, rightSon;</span>
<span id="cb8-7"><a href="#cb8-7"></a>} SegNode;</span>
<span id="cb8-8"><a href="#cb8-8"></a>SegNode segTree[SIZE * <span class="dv">40</span>];</span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="dt">int</span> rootArr[SIZE], cntPt;</span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="dt">void</span> pushUp(<span class="dt">int</span> segPt) {</span>
<span id="cb8-12"><a href="#cb8-12"></a>    segTree[segPt].sum = segTree[LSON(segPt)].sum + segTree[RSON(segPt)].sum;</span>
<span id="cb8-13"><a href="#cb8-13"></a>}</span>
<span id="cb8-14"><a href="#cb8-14"></a></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="dt">void</span> build(<span class="dt">int</span> &amp; segPt, <span class="dt">int</span> leftPt, <span class="dt">int</span> rightPt) {</span>
<span id="cb8-16"><a href="#cb8-16"></a>    segPt = ++cntPt;</span>
<span id="cb8-17"><a href="#cb8-17"></a>    segTree[segPt].sum = <span class="dv">0</span>;</span>
<span id="cb8-18"><a href="#cb8-18"></a>    <span class="cf">if</span> (leftPt == rightPt)</span>
<span id="cb8-19"><a href="#cb8-19"></a>        <span class="cf">return</span>;</span>
<span id="cb8-20"><a href="#cb8-20"></a></span>
<span id="cb8-21"><a href="#cb8-21"></a>    <span class="dt">int</span> midPt = (leftPt + rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb8-22"><a href="#cb8-22"></a>    build(LSON(segPt), leftPt, midPt);</span>
<span id="cb8-23"><a href="#cb8-23"></a>    build(RSON(segPt), midPt + <span class="dv">1</span>, rightPt);</span>
<span id="cb8-24"><a href="#cb8-24"></a>}</span>
<span id="cb8-25"><a href="#cb8-25"></a></span>
<span id="cb8-26"><a href="#cb8-26"></a><span class="dt">void</span> update(<span class="dt">int</span> &amp; segPt, <span class="dt">int</span> prevPt, <span class="dt">int</span> leftPt, <span class="dt">int</span> rightPt, <span class="dt">int</span> pos, <span class="dt">int</span> val) {</span>
<span id="cb8-27"><a href="#cb8-27"></a>    segPt = ++cntPt;</span>
<span id="cb8-28"><a href="#cb8-28"></a>    LSON(segPt) = LSON(prevPt);</span>
<span id="cb8-29"><a href="#cb8-29"></a>    RSON(segPt) = RSON(prevPt);</span>
<span id="cb8-30"><a href="#cb8-30"></a></span>
<span id="cb8-31"><a href="#cb8-31"></a>    <span class="cf">if</span> (leftPt == rightPt) {</span>
<span id="cb8-32"><a href="#cb8-32"></a>        segTree[segPt].minPt = val;</span>
<span id="cb8-33"><a href="#cb8-33"></a>        <span class="cf">return</span>;</span>
<span id="cb8-34"><a href="#cb8-34"></a>    }</span>
<span id="cb8-35"><a href="#cb8-35"></a></span>
<span id="cb8-36"><a href="#cb8-36"></a>    <span class="dt">int</span> midPt = (leftPt + rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb8-37"><a href="#cb8-37"></a>    <span class="cf">if</span> (pos &lt;= midPt)</span>
<span id="cb8-38"><a href="#cb8-38"></a>        update(LSON(segPt), LSON(prevPt), leftPt, midPt, pos, val);</span>
<span id="cb8-39"><a href="#cb8-39"></a>    <span class="cf">else</span></span>
<span id="cb8-40"><a href="#cb8-40"></a>        update(RSON(segPt), RSON(prevPt), midPt + <span class="dv">1</span>, rightPt, pos, val);</span>
<span id="cb8-41"><a href="#cb8-41"></a>    pushUp(segPt);</span>
<span id="cb8-42"><a href="#cb8-42"></a>}</span>
<span id="cb8-43"><a href="#cb8-43"></a></span>
<span id="cb8-44"><a href="#cb8-44"></a><span class="dt">int</span> query(<span class="dt">int</span> segPt, <span class="dt">int</span> leftPt, <span class="dt">int</span> rightPt, <span class="dt">int</span> qLeftPt, <span class="dt">int</span> qRightPt) {</span>
<span id="cb8-45"><a href="#cb8-45"></a>    <span class="cf">if</span> (qLeftPt &lt;= leftPt &amp;&amp; qRightPt &gt;= rightPt)</span>
<span id="cb8-46"><a href="#cb8-46"></a>        <span class="cf">return</span> segTree[segPt].sum;</span>
<span id="cb8-47"><a href="#cb8-47"></a></span>
<span id="cb8-48"><a href="#cb8-48"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>, midPt = (leftPt + rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb8-49"><a href="#cb8-49"></a>    <span class="cf">if</span> (qLeftPt &lt;= midPt)</span>
<span id="cb8-50"><a href="#cb8-50"></a>        ans += query(LSON(segPt), leftPt, midPt, qLeftPt, qRightPt);</span>
<span id="cb8-51"><a href="#cb8-51"></a>    <span class="cf">if</span> (qRightPt &gt; midPt)</span>
<span id="cb8-52"><a href="#cb8-52"></a>        ans += query(RSON(segPt), midPt + <span class="dv">1</span>, rightPt, qLeftPt, qRightPt);</span>
<span id="cb8-53"><a href="#cb8-53"></a>    <span class="cf">return</span> ans;</span>
<span id="cb8-54"><a href="#cb8-54"></a>}</span>
<span id="cb8-55"><a href="#cb8-55"></a></span>
<span id="cb8-56"><a href="#cb8-56"></a>cntPt = <span class="dv">0</span>;</span>
<span id="cb8-57"><a href="#cb8-57"></a>build(rootArr[<span class="dv">0</span>], <span class="dv">1</span>, len);</span></code></pre></div>
</div>
<div id="带-lazy-标记的可持久化线段树" class="section level3">
<h3>带 lazy 标记的可持久化线段树</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="pp">#define LSON</span>(x)<span class="pp"> </span>segTree[x].leftSon</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="pp">#define RSON</span>(x)<span class="pp"> </span>segTree[x].rightSon</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="kw">typedef</span> <span class="kw">struct</span> _SegNode {</span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="dt">int</span> sum, lazy;</span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="dt">int</span> leftSon, rightSon;</span>
<span id="cb9-7"><a href="#cb9-7"></a>} SegNode;</span>
<span id="cb9-8"><a href="#cb9-8"></a>SegNode segTree[SIZE * <span class="dv">40</span>];</span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="dt">int</span> rootArr[SIZE], cntPt;</span>
<span id="cb9-10"><a href="#cb9-10"></a></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="dt">void</span> pushUp(<span class="dt">int</span> segPt, <span class="dt">int</span> len) {</span>
<span id="cb9-12"><a href="#cb9-12"></a>    segTree[segPt].sum = segTree[LSON(segPt)].sum + segTree[RSON(segPt)].sum + len * segTree[segPt].lazy;</span>
<span id="cb9-13"><a href="#cb9-13"></a>}</span>
<span id="cb9-14"><a href="#cb9-14"></a></span>
<span id="cb9-15"><a href="#cb9-15"></a><span class="dt">void</span> build(<span class="dt">int</span> &amp; segPt, <span class="dt">int</span> leftPt, <span class="dt">int</span> rightPt) {</span>
<span id="cb9-16"><a href="#cb9-16"></a>    segPt = ++cntPt;</span>
<span id="cb9-17"><a href="#cb9-17"></a>    segTree[segPt].lazy = <span class="dv">0</span>;</span>
<span id="cb9-18"><a href="#cb9-18"></a>    <span class="cf">if</span> (leftPt == rightPt) {</span>
<span id="cb9-19"><a href="#cb9-19"></a>        segTree[segPt].sum = arr[leftPt];</span>
<span id="cb9-20"><a href="#cb9-20"></a>        <span class="cf">return</span>;</span>
<span id="cb9-21"><a href="#cb9-21"></a>    }</span>
<span id="cb9-22"><a href="#cb9-22"></a></span>
<span id="cb9-23"><a href="#cb9-23"></a>    <span class="dt">int</span> midPt = (leftPt + rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb9-24"><a href="#cb9-24"></a>    build(segTree[segPt].leftSon, leftPt, midPt);</span>
<span id="cb9-25"><a href="#cb9-25"></a>    build(segTree[segPt].rightSon, midPt + <span class="dv">1</span>, rightPt);</span>
<span id="cb9-26"><a href="#cb9-26"></a>    pushUp(segPt, <span class="dv">0</span>);</span>
<span id="cb9-27"><a href="#cb9-27"></a>}</span>
<span id="cb9-28"><a href="#cb9-28"></a></span>
<span id="cb9-29"><a href="#cb9-29"></a><span class="dt">void</span> rangeAdd(<span class="dt">int</span> &amp; segPt, <span class="dt">int</span> prevPt, <span class="dt">int</span> leftPt, <span class="dt">int</span> rightPt, <span class="dt">int</span> qLeftPt, <span class="dt">int</span> qRightPt, <span class="dt">int</span> val) {</span>
<span id="cb9-30"><a href="#cb9-30"></a>    segPt = ++cntPt;</span>
<span id="cb9-31"><a href="#cb9-31"></a>    segTree[segPt] = segTree[prevPt];</span>
<span id="cb9-32"><a href="#cb9-32"></a></span>
<span id="cb9-33"><a href="#cb9-33"></a>    <span class="cf">if</span> (leftPt &gt;= qLeftPt &amp;&amp; rightPt &lt;= qRightPt) {</span>
<span id="cb9-34"><a href="#cb9-34"></a>        segTree[segPt].sum += val * (rightPt - leftPt + <span class="dv">1</span>);</span>
<span id="cb9-35"><a href="#cb9-35"></a>        segTree[segPt].lazy += val;</span>
<span id="cb9-36"><a href="#cb9-36"></a>        <span class="cf">return</span>;</span>
<span id="cb9-37"><a href="#cb9-37"></a>    }</span>
<span id="cb9-38"><a href="#cb9-38"></a></span>
<span id="cb9-39"><a href="#cb9-39"></a>    <span class="dt">int</span> midPt = (leftPt + rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb9-40"><a href="#cb9-40"></a>    <span class="cf">if</span> (qLeftPt &lt;= midPt)</span>
<span id="cb9-41"><a href="#cb9-41"></a>        rangeAdd(LSON(segPt), LSON(prevPt), leftPt, midPt, qLeftPt, qRightPt, val);</span>
<span id="cb9-42"><a href="#cb9-42"></a>    <span class="cf">if</span> (qRightPt &gt; midPt)</span>
<span id="cb9-43"><a href="#cb9-43"></a>        rangeAdd(RSON(segPt), RSON(prevPt), midPt + <span class="dv">1</span>, rightPt, qLeftPt, qRightPt, val);</span>
<span id="cb9-44"><a href="#cb9-44"></a>    pushUp(segPt, rightPt - leftPt + <span class="dv">1</span>);</span>
<span id="cb9-45"><a href="#cb9-45"></a>}</span>
<span id="cb9-46"><a href="#cb9-46"></a></span>
<span id="cb9-47"><a href="#cb9-47"></a><span class="dt">int</span> querySum(<span class="dt">int</span> segPt, <span class="dt">int</span> leftPt, <span class="dt">int</span> rightPt, <span class="dt">int</span> qLeftPt, <span class="dt">int</span> qRightPt, <span class="dt">int</span> lazy = <span class="dv">0</span>) {</span>
<span id="cb9-48"><a href="#cb9-48"></a>    <span class="co">// push down when querying</span></span>
<span id="cb9-49"><a href="#cb9-49"></a>    <span class="cf">if</span> (leftPt &gt;= qLeftPt &amp;&amp; rightPt &lt;= qRightPt) {</span>
<span id="cb9-50"><a href="#cb9-50"></a>        <span class="cf">return</span> segTree[segPt].sum + lazy * (rightPt - leftPt + <span class="dv">1</span>);</span>
<span id="cb9-51"><a href="#cb9-51"></a>    }</span>
<span id="cb9-52"><a href="#cb9-52"></a></span>
<span id="cb9-53"><a href="#cb9-53"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>, midPt = (leftPt + rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb9-54"><a href="#cb9-54"></a>    <span class="cf">if</span> (qLeftPt &lt;= midPt)</span>
<span id="cb9-55"><a href="#cb9-55"></a>        ans += querySum(LSON(segPt), leftPt, midPt, qLeftPt, qRightPt, lazy + segTree[segPt].lazy);</span>
<span id="cb9-56"><a href="#cb9-56"></a>    <span class="cf">if</span> (qRightPt &gt; midPt)</span>
<span id="cb9-57"><a href="#cb9-57"></a>        ans += querySum(RSON(segPt), midPt + <span class="dv">1</span>, rightPt, qLeftPt, qRightPt, lazy + segTree[segPt].lazy);</span>
<span id="cb9-58"><a href="#cb9-58"></a>    <span class="cf">return</span> ans;</span>
<span id="cb9-59"><a href="#cb9-59"></a>}</span>
<span id="cb9-60"><a href="#cb9-60"></a></span>
<span id="cb9-61"><a href="#cb9-61"></a>cntPt = <span class="dv">0</span>;</span>
<span id="cb9-62"><a href="#cb9-62"></a>build(rootArr[<span class="dv">0</span>], <span class="dv">1</span>, len);</span></code></pre></div>
</div>
<div id="区间第-k-大" class="section level3">
<h3>区间第 k 大</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="dt">int</span> query(<span class="dt">int</span> leftPt, <span class="dt">int</span> rightPt, <span class="dt">int</span> qLeftPt, <span class="dt">int</span> qRightPt, <span class="dt">int</span> k) {</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="cf">while</span> (leftPt &lt; rightPt) {</span>
<span id="cb10-4"><a href="#cb10-4"></a>        <span class="dt">int</span> midPt = (leftPt + rightPt) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb10-5"><a href="#cb10-5"></a>        <span class="cf">if</span> (k &lt;= midPt) {</span>
<span id="cb10-6"><a href="#cb10-6"></a>            qLeftPt = segTree[qLeftPt].leftSon;</span>
<span id="cb10-7"><a href="#cb10-7"></a>            qRightPt = segTree[qRightPt].leftSon;</span>
<span id="cb10-8"><a href="#cb10-8"></a>            rightPt = midPt;</span>
<span id="cb10-9"><a href="#cb10-9"></a>        } <span class="cf">else</span> {</span>
<span id="cb10-10"><a href="#cb10-10"></a>            ans += segTree[segTree[qRightPt].leftSon].sum - segTree[segTree[qLeftPt].leftSon].sum;</span>
<span id="cb10-11"><a href="#cb10-11"></a>            qLeftPt = segTree[qLeftPt].rightSon;</span>
<span id="cb10-12"><a href="#cb10-12"></a>            qRightPt = segTree[qRightPt].rightSon;</span>
<span id="cb10-13"><a href="#cb10-13"></a>            leftPt = midPt + <span class="dv">1</span>;</span>
<span id="cb10-14"><a href="#cb10-14"></a>        }</span>
<span id="cb10-15"><a href="#cb10-15"></a>    }</span>
<span id="cb10-16"><a href="#cb10-16"></a>    <span class="cf">if</span> (k &gt;= leftPt)</span>
<span id="cb10-17"><a href="#cb10-17"></a>        ans += segTree[qRightPt].sum - segTree[qLeftPt].sum;</span>
<span id="cb10-18"><a href="#cb10-18"></a>    <span class="cf">return</span> ans;</span>
<span id="cb10-19"><a href="#cb10-19"></a>}</span>
<span id="cb10-20"><a href="#cb10-20"></a></span>
<span id="cb10-21"><a href="#cb10-21"></a><span class="co">// Discretize first</span></span>
<span id="cb10-22"><a href="#cb10-22"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= len; i++) {</span>
<span id="cb10-23"><a href="#cb10-23"></a>    <span class="dt">int</span> pos = lower_bound(dsc + <span class="dv">1</span>, dsc + dscLen + <span class="dv">1</span>, arr[i]) - dsc;</span>
<span id="cb10-24"><a href="#cb10-24"></a>    add(rootArr[i], rootArr[i - <span class="dv">1</span>], <span class="dv">1</span>, dscLen, pos, <span class="dv">1</span>);</span>
<span id="cb10-25"><a href="#cb10-25"></a>}</span>
<span id="cb10-26"><a href="#cb10-26"></a>k = upper_bound(dsc + <span class="dv">1</span>, dsc + dscLen + <span class="dv">1</span>, k) - dsc - <span class="dv">1</span>;</span>
<span id="cb10-27"><a href="#cb10-27"></a>cout &lt;&lt; query(<span class="dv">1</span>, dscLen, rootArr[qLeftPt - <span class="dv">1</span>], rootArr[qRightPt], k) &lt;&lt; endl;</span></code></pre></div>
</div>
</div>
<div id="平衡树" class="section level2">
<h2>平衡树</h2>
<div id="无旋转-treap" class="section level3">
<h3>无旋转 treap</h3>
<div id="普通平衡树" class="section level4">
<h4>普通平衡树</h4>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="pp">#define SIZE </span><span class="dv">100010</span></span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a>mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); </span>
<span id="cb11-7"><a href="#cb11-7"></a>uniform_int_distribution&lt;<span class="dt">int</span>&gt; unifInt;</span>
<span id="cb11-8"><a href="#cb11-8"></a></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="kw">class</span> Treap {</span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="kw">public</span>:</span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="dt">int</span> val, rnd, siz, son[<span class="dv">2</span>];</span>
<span id="cb11-12"><a href="#cb11-12"></a>};</span>
<span id="cb11-13"><a href="#cb11-13"></a></span>
<span id="cb11-14"><a href="#cb11-14"></a>Treap trp[SIZE]; <span class="dt">int</span> trpPt;</span>
<span id="cb11-15"><a href="#cb11-15"></a></span>
<span id="cb11-16"><a href="#cb11-16"></a><span class="at">const</span> <span class="kw">auto</span> node = [](<span class="dt">int</span> rt) -&gt; Treap &amp; { <span class="cf">return</span> trp[rt]; };</span>
<span id="cb11-17"><a href="#cb11-17"></a><span class="at">const</span> <span class="kw">auto</span> lson = [](<span class="dt">int</span> rt) -&gt; Treap &amp; { <span class="cf">return</span> trp[trp[rt].son[<span class="dv">0</span>]]; };</span>
<span id="cb11-18"><a href="#cb11-18"></a><span class="at">const</span> <span class="kw">auto</span> rson = [](<span class="dt">int</span> rt) -&gt; Treap &amp; { <span class="cf">return</span> trp[trp[rt].son[<span class="dv">1</span>]]; };</span>
<span id="cb11-19"><a href="#cb11-19"></a></span>
<span id="cb11-20"><a href="#cb11-20"></a><span class="dt">void</span> maintain(<span class="dt">int</span> rt) {</span>
<span id="cb11-21"><a href="#cb11-21"></a>    node(rt).siz = lson(rt).siz + rson(rt).siz + <span class="dv">1</span>;</span>
<span id="cb11-22"><a href="#cb11-22"></a>}</span>
<span id="cb11-23"><a href="#cb11-23"></a></span>
<span id="cb11-24"><a href="#cb11-24"></a><span class="dt">int</span> newNode(<span class="dt">int</span> val) {</span>
<span id="cb11-25"><a href="#cb11-25"></a>    <span class="dt">int</span> cntPt = trpPt++;</span>
<span id="cb11-26"><a href="#cb11-26"></a>    <span class="cf">if</span> (vec.size()) {</span>
<span id="cb11-27"><a href="#cb11-27"></a>        cntPt = vec.back();</span>
<span id="cb11-28"><a href="#cb11-28"></a>        vec.pop_back(); trpPt--;</span>
<span id="cb11-29"><a href="#cb11-29"></a>    }</span>
<span id="cb11-30"><a href="#cb11-30"></a>    trp[cntPt] = {val, unifInt(rng), <span class="dv">1</span>, {<span class="dv">0</span>, <span class="dv">0</span>}};</span>
<span id="cb11-31"><a href="#cb11-31"></a>    <span class="cf">return</span> cntPt;</span>
<span id="cb11-32"><a href="#cb11-32"></a>}</span>
<span id="cb11-33"><a href="#cb11-33"></a></span>
<span id="cb11-34"><a href="#cb11-34"></a><span class="dt">int</span> merge(<span class="dt">int</span> fstRt, <span class="dt">int</span> sndRt) {</span>
<span id="cb11-35"><a href="#cb11-35"></a>    <span class="cf">if</span> (fstRt == <span class="dv">0</span>)</span>
<span id="cb11-36"><a href="#cb11-36"></a>        <span class="cf">return</span> sndRt;</span>
<span id="cb11-37"><a href="#cb11-37"></a>    <span class="cf">if</span> (sndRt == <span class="dv">0</span>)</span>
<span id="cb11-38"><a href="#cb11-38"></a>        <span class="cf">return</span> fstRt;</span>
<span id="cb11-39"><a href="#cb11-39"></a></span>
<span id="cb11-40"><a href="#cb11-40"></a>    <span class="cf">if</span> (node(fstRt).rnd &lt; node(sndRt).rnd) {</span>
<span id="cb11-41"><a href="#cb11-41"></a>        node(fstRt).son[<span class="dv">1</span>] = merge(node(fstRt).son[<span class="dv">1</span>], sndRt);</span>
<span id="cb11-42"><a href="#cb11-42"></a>        maintain(fstRt); <span class="cf">return</span> fstRt;</span>
<span id="cb11-43"><a href="#cb11-43"></a>    } <span class="cf">else</span> {</span>
<span id="cb11-44"><a href="#cb11-44"></a>        node(sndRt).son[<span class="dv">0</span>] = merge(fstRt, node(sndRt).son[<span class="dv">0</span>]);</span>
<span id="cb11-45"><a href="#cb11-45"></a>        maintain(sndRt); <span class="cf">return</span> sndRt;</span>
<span id="cb11-46"><a href="#cb11-46"></a>    }</span>
<span id="cb11-47"><a href="#cb11-47"></a>}</span>
<span id="cb11-48"><a href="#cb11-48"></a></span>
<span id="cb11-49"><a href="#cb11-49"></a><span class="dt">void</span> split(<span class="dt">int</span> rt, <span class="dt">int</span> k, <span class="dt">int</span> &amp; fstRt, <span class="dt">int</span> &amp; sndRt) {</span>
<span id="cb11-50"><a href="#cb11-50"></a>    <span class="cf">if</span> (rt == <span class="dv">0</span>) {</span>
<span id="cb11-51"><a href="#cb11-51"></a>        fstRt = <span class="dv">0</span>; sndRt = <span class="dv">0</span>;</span>
<span id="cb11-52"><a href="#cb11-52"></a>        <span class="cf">return</span>;</span>
<span id="cb11-53"><a href="#cb11-53"></a>    }</span>
<span id="cb11-54"><a href="#cb11-54"></a></span>
<span id="cb11-55"><a href="#cb11-55"></a>    <span class="cf">if</span> (k &lt;= lson(rt).siz) {</span>
<span id="cb11-56"><a href="#cb11-56"></a>        sndRt = rt; split(node(rt).son[<span class="dv">0</span>], k, fstRt, node(rt).son[<span class="dv">0</span>]);</span>
<span id="cb11-57"><a href="#cb11-57"></a>    } <span class="cf">else</span> {</span>
<span id="cb11-58"><a href="#cb11-58"></a>        fstRt = rt; split(node(rt).son[<span class="dv">1</span>], k - lson(rt).siz - <span class="dv">1</span>, node(rt).son[<span class="dv">1</span>], sndRt);</span>
<span id="cb11-59"><a href="#cb11-59"></a>    }</span>
<span id="cb11-60"><a href="#cb11-60"></a>    maintain(rt);</span>
<span id="cb11-61"><a href="#cb11-61"></a>}</span>
<span id="cb11-62"><a href="#cb11-62"></a></span>
<span id="cb11-63"><a href="#cb11-63"></a><span class="dt">void</span> splitByVal(<span class="dt">int</span> rt, <span class="dt">int</span> val, <span class="dt">int</span> &amp; fstRt, <span class="dt">int</span> &amp; sndRt) {</span>
<span id="cb11-64"><a href="#cb11-64"></a>    <span class="cf">if</span> (rt == <span class="dv">0</span>) {</span>
<span id="cb11-65"><a href="#cb11-65"></a>        fstRt = <span class="dv">0</span>; sndRt = <span class="dv">0</span>;</span>
<span id="cb11-66"><a href="#cb11-66"></a>        <span class="cf">return</span>;</span>
<span id="cb11-67"><a href="#cb11-67"></a>    }</span>
<span id="cb11-68"><a href="#cb11-68"></a></span>
<span id="cb11-69"><a href="#cb11-69"></a>    <span class="cf">if</span> (node(rt).val &gt; val)</span>
<span id="cb11-70"><a href="#cb11-70"></a>        sndRt = rt, splitByVal(node(rt).son[<span class="dv">0</span>], val, fstRt, node(rt).son[<span class="dv">0</span>]);</span>
<span id="cb11-71"><a href="#cb11-71"></a>    <span class="cf">else</span></span>
<span id="cb11-72"><a href="#cb11-72"></a>        fstRt = rt, splitByVal(node(rt).son[<span class="dv">1</span>], val, node(rt).son[<span class="dv">1</span>], sndRt);        </span>
<span id="cb11-73"><a href="#cb11-73"></a>    maintain(rt);</span>
<span id="cb11-74"><a href="#cb11-74"></a>}</span>
<span id="cb11-75"><a href="#cb11-75"></a></span>
<span id="cb11-76"><a href="#cb11-76"></a><span class="dt">int</span> queryRank(<span class="dt">int</span> rt, <span class="dt">int</span> val) {</span>
<span id="cb11-77"><a href="#cb11-77"></a>    <span class="cf">if</span> (rt == <span class="dv">0</span>)</span>
<span id="cb11-78"><a href="#cb11-78"></a>        <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb11-79"><a href="#cb11-79"></a>    <span class="cf">if</span> (val &lt;= node(rt).val)</span>
<span id="cb11-80"><a href="#cb11-80"></a>        <span class="cf">return</span> queryRank(node(rt).son[<span class="dv">0</span>], val);</span>
<span id="cb11-81"><a href="#cb11-81"></a>    <span class="cf">return</span> queryRank(node(rt).son[<span class="dv">1</span>], val) + lson(rt).siz + <span class="dv">1</span>;</span>
<span id="cb11-82"><a href="#cb11-82"></a>}</span>
<span id="cb11-83"><a href="#cb11-83"></a></span>
<span id="cb11-84"><a href="#cb11-84"></a><span class="dt">int</span> queryByRank(<span class="dt">int</span> rt, <span class="dt">int</span> k) {</span>
<span id="cb11-85"><a href="#cb11-85"></a>    <span class="dt">int</span> fstRt = <span class="dv">0</span>, sndRt = <span class="dv">0</span>, thdRt = <span class="dv">0</span>;</span>
<span id="cb11-86"><a href="#cb11-86"></a>    split(rt, k - <span class="dv">1</span>, fstRt, sndRt);</span>
<span id="cb11-87"><a href="#cb11-87"></a>    split(sndRt, <span class="dv">1</span>, sndRt, thdRt);</span>
<span id="cb11-88"><a href="#cb11-88"></a>    <span class="dt">int</span> ret = node(sndRt).val;</span>
<span id="cb11-89"><a href="#cb11-89"></a>    rt = merge(fstRt, merge(sndRt, thdRt));</span>
<span id="cb11-90"><a href="#cb11-90"></a>    <span class="cf">return</span> ret;</span>
<span id="cb11-91"><a href="#cb11-91"></a>}</span>
<span id="cb11-92"><a href="#cb11-92"></a></span>
<span id="cb11-93"><a href="#cb11-93"></a><span class="dt">void</span> insert(<span class="dt">int</span> &amp; rt, <span class="dt">int</span> val) {</span>
<span id="cb11-94"><a href="#cb11-94"></a>    <span class="dt">int</span> k = queryRank(rt, val);</span>
<span id="cb11-95"><a href="#cb11-95"></a>    <span class="dt">int</span> fstRt = <span class="dv">0</span>, sndRt = <span class="dv">0</span>;</span>
<span id="cb11-96"><a href="#cb11-96"></a>    split(rt, k - <span class="dv">1</span>, fstRt, sndRt);</span>
<span id="cb11-97"><a href="#cb11-97"></a>    rt = merge(fstRt, merge(newNode(val), sndRt));</span>
<span id="cb11-98"><a href="#cb11-98"></a>}</span>
<span id="cb11-99"><a href="#cb11-99"></a></span>
<span id="cb11-100"><a href="#cb11-100"></a><span class="dt">void</span> remove(<span class="dt">int</span> &amp; rt, <span class="dt">int</span> val) {</span>
<span id="cb11-101"><a href="#cb11-101"></a>    <span class="dt">int</span> k = queryRank(rt, val);</span>
<span id="cb11-102"><a href="#cb11-102"></a>    <span class="dt">int</span> fstRt = <span class="dv">0</span>, sndRt = <span class="dv">0</span>, thdRt = <span class="dv">0</span>;</span>
<span id="cb11-103"><a href="#cb11-103"></a>    split(rt, k - <span class="dv">1</span>, fstRt, sndRt); </span>
<span id="cb11-104"><a href="#cb11-104"></a>    split(sndRt, <span class="dv">1</span>, sndRt, thdRt);</span>
<span id="cb11-105"><a href="#cb11-105"></a>    rt = merge(fstRt, thdRt); vec.push_back(sndRt);</span>
<span id="cb11-106"><a href="#cb11-106"></a>}</span>
<span id="cb11-107"><a href="#cb11-107"></a></span>
<span id="cb11-108"><a href="#cb11-108"></a><span class="dt">int</span> queryPrev(<span class="dt">int</span> &amp; rt, <span class="dt">int</span> val) {</span>
<span id="cb11-109"><a href="#cb11-109"></a>    <span class="dt">int</span> fstRt = <span class="dv">0</span>, sndRt = <span class="dv">0</span>;</span>
<span id="cb11-110"><a href="#cb11-110"></a>    splitByVal(rt, val - <span class="dv">1</span>, fstRt, sndRt);</span>
<span id="cb11-111"><a href="#cb11-111"></a>    <span class="dt">int</span> ret = queryByRank(fstRt, node(fstRt).siz);</span>
<span id="cb11-112"><a href="#cb11-112"></a>    rt = merge(fstRt, sndRt);</span>
<span id="cb11-113"><a href="#cb11-113"></a>    <span class="cf">return</span> ret;</span>
<span id="cb11-114"><a href="#cb11-114"></a>}</span>
<span id="cb11-115"><a href="#cb11-115"></a></span>
<span id="cb11-116"><a href="#cb11-116"></a><span class="dt">int</span> queryNext(<span class="dt">int</span> &amp; rt, <span class="dt">int</span> val) {</span>
<span id="cb11-117"><a href="#cb11-117"></a>    <span class="dt">int</span> fstRt = <span class="dv">0</span>, sndRt = <span class="dv">0</span>;</span>
<span id="cb11-118"><a href="#cb11-118"></a>    splitByVal(rt, val, fstRt, sndRt);</span>
<span id="cb11-119"><a href="#cb11-119"></a>    <span class="dt">int</span> ret = queryByRank(sndRt, <span class="dv">1</span>);</span>
<span id="cb11-120"><a href="#cb11-120"></a>    rt = merge(fstRt, sndRt);</span>
<span id="cb11-121"><a href="#cb11-121"></a>    <span class="cf">return</span> ret;</span>
<span id="cb11-122"><a href="#cb11-122"></a>}</span>
<span id="cb11-123"><a href="#cb11-123"></a></span>
<span id="cb11-124"><a href="#cb11-124"></a><span class="dt">int</span> main() {</span>
<span id="cb11-125"><a href="#cb11-125"></a>    ios::sync_with_stdio(<span class="kw">false</span>);</span>
<span id="cb11-126"><a href="#cb11-126"></a>    cin.tie(<span class="dv">0</span>); cout.tie(<span class="dv">0</span>);</span>
<span id="cb11-127"><a href="#cb11-127"></a>    vec.clear();</span>
<span id="cb11-128"><a href="#cb11-128"></a>    trpPt = <span class="dv">0</span>; trp[trpPt++] = {<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, {<span class="dv">0</span>, <span class="dv">0</span>}};</span>
<span id="cb11-129"><a href="#cb11-129"></a></span>
<span id="cb11-130"><a href="#cb11-130"></a>    <span class="dt">int</span> rt = <span class="dv">0</span>, qNum; cin &gt;&gt; qNum;</span>
<span id="cb11-131"><a href="#cb11-131"></a>    <span class="cf">while</span> (qNum--) {</span>
<span id="cb11-132"><a href="#cb11-132"></a>        <span class="dt">int</span> op, cnt; cin &gt;&gt; op &gt;&gt; cnt;</span>
<span id="cb11-133"><a href="#cb11-133"></a>        <span class="cf">if</span> (op == <span class="dv">1</span>)</span>
<span id="cb11-134"><a href="#cb11-134"></a>            insert(rt, cnt);</span>
<span id="cb11-135"><a href="#cb11-135"></a>        <span class="cf">else</span> <span class="cf">if</span> (op == <span class="dv">2</span>)</span>
<span id="cb11-136"><a href="#cb11-136"></a>            remove(rt, cnt);</span>
<span id="cb11-137"><a href="#cb11-137"></a>        <span class="cf">else</span> <span class="cf">if</span> (op == <span class="dv">3</span>)</span>
<span id="cb11-138"><a href="#cb11-138"></a>            cout &lt;&lt; queryRank(rt, cnt) &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb11-139"><a href="#cb11-139"></a>        <span class="cf">else</span> <span class="cf">if</span> (op == <span class="dv">4</span>)</span>
<span id="cb11-140"><a href="#cb11-140"></a>            cout &lt;&lt; queryByRank(rt, cnt) &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb11-141"><a href="#cb11-141"></a>        <span class="cf">else</span> <span class="cf">if</span> (op == <span class="dv">5</span>)</span>
<span id="cb11-142"><a href="#cb11-142"></a>            cout &lt;&lt; queryPrev(rt, cnt) &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb11-143"><a href="#cb11-143"></a>        <span class="cf">else</span> <span class="cf">if</span> (op == <span class="dv">6</span>)</span>
<span id="cb11-144"><a href="#cb11-144"></a>            cout &lt;&lt; queryNext(rt, cnt) &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb11-145"><a href="#cb11-145"></a>    }</span>
<span id="cb11-146"><a href="#cb11-146"></a></span>
<span id="cb11-147"><a href="#cb11-147"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-148"><a href="#cb11-148"></a>}</span></code></pre></div>
</div>
</div>
<div id="文艺平衡树" class="section level3">
<h3>文艺平衡树</h3>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb12-3"><a href="#cb12-3"></a></span>
<span id="cb12-4"><a href="#cb12-4"></a>mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); </span>
<span id="cb12-5"><a href="#cb12-5"></a>uniform_int_distribution&lt;<span class="dt">int</span>&gt; unifInt(<span class="dv">0</span>, <span class="fl">1e9</span>);</span>
<span id="cb12-6"><a href="#cb12-6"></a></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="kw">class</span> Treap {</span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="kw">public</span>:</span>
<span id="cb12-9"><a href="#cb12-9"></a>    <span class="dt">int</span> val, rnd, siz; <span class="dt">bool</span> lazy;</span>
<span id="cb12-10"><a href="#cb12-10"></a>    Treap * son[<span class="dv">2</span>];</span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a>    Treap (<span class="dt">int</span> v) : val (v) {</span>
<span id="cb12-13"><a href="#cb12-13"></a>        <span class="kw">this</span> -&gt; rnd = unifInt(rng); <span class="kw">this</span> -&gt; siz = <span class="dv">1</span>; <span class="kw">this</span> -&gt; lazy = <span class="kw">false</span>;</span>
<span id="cb12-14"><a href="#cb12-14"></a>        <span class="kw">this</span> -&gt; son[<span class="dv">0</span>] = <span class="kw">nullptr</span>; <span class="kw">this</span> -&gt; son[<span class="dv">1</span>] = <span class="kw">nullptr</span>;</span>
<span id="cb12-15"><a href="#cb12-15"></a>    }</span>
<span id="cb12-16"><a href="#cb12-16"></a></span>
<span id="cb12-17"><a href="#cb12-17"></a>    <span class="dt">void</span> maintain() {</span>
<span id="cb12-18"><a href="#cb12-18"></a>        <span class="kw">this</span> -&gt; siz = <span class="dv">1</span>;</span>
<span id="cb12-19"><a href="#cb12-19"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>; i++)</span>
<span id="cb12-20"><a href="#cb12-20"></a>            <span class="cf">if</span> (<span class="kw">this</span> -&gt; son[i] != <span class="kw">nullptr</span>)</span>
<span id="cb12-21"><a href="#cb12-21"></a>                <span class="kw">this</span> -&gt; siz += <span class="kw">this</span> -&gt; son[i] -&gt; siz;</span>
<span id="cb12-22"><a href="#cb12-22"></a>    }</span>
<span id="cb12-23"><a href="#cb12-23"></a></span>
<span id="cb12-24"><a href="#cb12-24"></a>    <span class="dt">void</span> pushDown() {</span>
<span id="cb12-25"><a href="#cb12-25"></a>        <span class="cf">if</span> (!<span class="kw">this</span> -&gt; lazy)</span>
<span id="cb12-26"><a href="#cb12-26"></a>            <span class="cf">return</span>;</span>
<span id="cb12-27"><a href="#cb12-27"></a>        swap(<span class="kw">this</span> -&gt; son[<span class="dv">0</span>], <span class="kw">this</span> -&gt; son[<span class="dv">1</span>]);</span>
<span id="cb12-28"><a href="#cb12-28"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>; i++)</span>
<span id="cb12-29"><a href="#cb12-29"></a>            <span class="cf">if</span> (<span class="kw">this</span> -&gt; son[i] != <span class="kw">nullptr</span>)</span>
<span id="cb12-30"><a href="#cb12-30"></a>                <span class="kw">this</span> -&gt; son[i] -&gt; lazy ^= <span class="dv">1</span>;</span>
<span id="cb12-31"><a href="#cb12-31"></a>        <span class="kw">this</span> -&gt; lazy = <span class="kw">false</span>; <span class="cf">return</span>;</span>
<span id="cb12-32"><a href="#cb12-32"></a>    }</span>
<span id="cb12-33"><a href="#cb12-33"></a>};</span>
<span id="cb12-34"><a href="#cb12-34"></a></span>
<span id="cb12-35"><a href="#cb12-35"></a><span class="kw">auto</span> siz = [](Treap * rt) {</span>
<span id="cb12-36"><a href="#cb12-36"></a>    <span class="cf">return</span> rt == <span class="kw">nullptr</span> ? <span class="dv">0</span> : rt -&gt; siz;</span>
<span id="cb12-37"><a href="#cb12-37"></a>};</span>
<span id="cb12-38"><a href="#cb12-38"></a></span>
<span id="cb12-39"><a href="#cb12-39"></a>Treap * merge(Treap * fstRt, Treap * sndRt) {</span>
<span id="cb12-40"><a href="#cb12-40"></a>    <span class="cf">if</span> (fstRt == <span class="kw">nullptr</span>)</span>
<span id="cb12-41"><a href="#cb12-41"></a>        <span class="cf">return</span> sndRt;</span>
<span id="cb12-42"><a href="#cb12-42"></a>    <span class="cf">if</span> (sndRt == <span class="kw">nullptr</span>)</span>
<span id="cb12-43"><a href="#cb12-43"></a>        <span class="cf">return</span> fstRt;</span>
<span id="cb12-44"><a href="#cb12-44"></a></span>
<span id="cb12-45"><a href="#cb12-45"></a>    <span class="cf">if</span> (fstRt -&gt; rnd &lt; sndRt -&gt; rnd) {</span>
<span id="cb12-46"><a href="#cb12-46"></a>        fstRt -&gt; pushDown();</span>
<span id="cb12-47"><a href="#cb12-47"></a>        fstRt -&gt; son[<span class="dv">1</span>] = merge(fstRt -&gt; son[<span class="dv">1</span>], sndRt);</span>
<span id="cb12-48"><a href="#cb12-48"></a>        fstRt -&gt; maintain(); <span class="cf">return</span> fstRt;</span>
<span id="cb12-49"><a href="#cb12-49"></a>    } <span class="cf">else</span> {</span>
<span id="cb12-50"><a href="#cb12-50"></a>        sndRt -&gt; pushDown();</span>
<span id="cb12-51"><a href="#cb12-51"></a>        sndRt -&gt; son[<span class="dv">0</span>] = merge(fstRt, sndRt -&gt; son[<span class="dv">0</span>]);</span>
<span id="cb12-52"><a href="#cb12-52"></a>        sndRt -&gt; maintain(); <span class="cf">return</span> sndRt;</span>
<span id="cb12-53"><a href="#cb12-53"></a>    }</span>
<span id="cb12-54"><a href="#cb12-54"></a>}</span>
<span id="cb12-55"><a href="#cb12-55"></a></span>
<span id="cb12-56"><a href="#cb12-56"></a><span class="dt">void</span> split(Treap * rt, <span class="dt">int</span> k, Treap * &amp; fstRt, Treap * &amp; sndRt) {</span>
<span id="cb12-57"><a href="#cb12-57"></a>    <span class="cf">if</span> (rt == <span class="kw">nullptr</span>) {</span>
<span id="cb12-58"><a href="#cb12-58"></a>        fstRt = <span class="kw">nullptr</span>; sndRt = <span class="kw">nullptr</span>;</span>
<span id="cb12-59"><a href="#cb12-59"></a>        <span class="cf">return</span>;</span>
<span id="cb12-60"><a href="#cb12-60"></a>    }</span>
<span id="cb12-61"><a href="#cb12-61"></a></span>
<span id="cb12-62"><a href="#cb12-62"></a>    rt -&gt; pushDown();</span>
<span id="cb12-63"><a href="#cb12-63"></a>    <span class="cf">if</span> (k &lt;= siz(rt -&gt; son[<span class="dv">0</span>])) {</span>
<span id="cb12-64"><a href="#cb12-64"></a>        split(rt -&gt; son[<span class="dv">0</span>], k, fstRt, rt -&gt; son[<span class="dv">0</span>]);</span>
<span id="cb12-65"><a href="#cb12-65"></a>        rt -&gt; maintain(); sndRt = rt;</span>
<span id="cb12-66"><a href="#cb12-66"></a>    } <span class="cf">else</span> {</span>
<span id="cb12-67"><a href="#cb12-67"></a>        split(rt -&gt; son[<span class="dv">1</span>], k - siz(rt -&gt; son[<span class="dv">0</span>]) - <span class="dv">1</span>, rt -&gt; son[<span class="dv">1</span>], sndRt);</span>
<span id="cb12-68"><a href="#cb12-68"></a>        rt -&gt; maintain(); fstRt = rt;</span>
<span id="cb12-69"><a href="#cb12-69"></a>    }</span>
<span id="cb12-70"><a href="#cb12-70"></a>}</span>
<span id="cb12-71"><a href="#cb12-71"></a></span>
<span id="cb12-72"><a href="#cb12-72"></a><span class="dt">int</span> getRank(Treap * rt, <span class="dt">int</span> val) {</span>
<span id="cb12-73"><a href="#cb12-73"></a>    <span class="cf">if</span> (rt == <span class="kw">nullptr</span>)</span>
<span id="cb12-74"><a href="#cb12-74"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb12-75"><a href="#cb12-75"></a>    <span class="cf">if</span> (val &lt;= rt -&gt; val)</span>
<span id="cb12-76"><a href="#cb12-76"></a>        <span class="cf">return</span> getRank(rt -&gt; son[<span class="dv">0</span>], val);</span>
<span id="cb12-77"><a href="#cb12-77"></a>    <span class="cf">return</span> getRank(rt -&gt; son[<span class="dv">1</span>], val) + siz(rt -&gt; son[<span class="dv">0</span>]) + <span class="dv">1</span>;</span>
<span id="cb12-78"><a href="#cb12-78"></a>}</span>
<span id="cb12-79"><a href="#cb12-79"></a></span>
<span id="cb12-80"><a href="#cb12-80"></a><span class="dt">void</span> insert(Treap * &amp; rt, <span class="dt">int</span> val) {</span>
<span id="cb12-81"><a href="#cb12-81"></a>    <span class="dt">int</span> k = getRank(rt, val);</span>
<span id="cb12-82"><a href="#cb12-82"></a>    Treap * fstRt = <span class="kw">nullptr</span>, * sndRt = <span class="kw">nullptr</span>;</span>
<span id="cb12-83"><a href="#cb12-83"></a>    split(rt, k, fstRt, sndRt);</span>
<span id="cb12-84"><a href="#cb12-84"></a>    rt = merge(fstRt, merge(<span class="kw">new</span> Treap(val), sndRt));</span>
<span id="cb12-85"><a href="#cb12-85"></a>}</span>
<span id="cb12-86"><a href="#cb12-86"></a></span>
<span id="cb12-87"><a href="#cb12-87"></a><span class="dt">void</span> remove(Treap * &amp; rt , <span class="dt">int</span> val) {</span>
<span id="cb12-88"><a href="#cb12-88"></a>    <span class="dt">int</span> k = getRank(rt, val) ;</span>
<span id="cb12-89"><a href="#cb12-89"></a>    Treap * fstRt = <span class="kw">nullptr</span>, * sndRt = <span class="kw">nullptr</span>, * thdRt = <span class="kw">nullptr</span>;</span>
<span id="cb12-90"><a href="#cb12-90"></a>    split(rt, k - <span class="dv">1</span>, fstRt, sndRt); </span>
<span id="cb12-91"><a href="#cb12-91"></a>    split(sndRt, <span class="dv">1</span>, sndRt, thdRt);</span>
<span id="cb12-92"><a href="#cb12-92"></a>    rt = merge(fstRt, thdRt); <span class="kw">delete</span> sndRt;</span>
<span id="cb12-93"><a href="#cb12-93"></a>}</span>
<span id="cb12-94"><a href="#cb12-94"></a></span>
<span id="cb12-95"><a href="#cb12-95"></a><span class="dt">void</span> reverse(Treap * &amp; rt, <span class="dt">int</span> qLeftPt, <span class="dt">int</span> qRightPt) {</span>
<span id="cb12-96"><a href="#cb12-96"></a>    Treap * fstRt = <span class="kw">nullptr</span>, * sndRt = <span class="kw">nullptr</span>, * thdRt = <span class="kw">nullptr</span>;</span>
<span id="cb12-97"><a href="#cb12-97"></a>    split(rt, qLeftPt - <span class="dv">1</span>, fstRt, sndRt); </span>
<span id="cb12-98"><a href="#cb12-98"></a>    split(sndRt, qRightPt - qLeftPt + <span class="dv">1</span>, sndRt, thdRt);</span>
<span id="cb12-99"><a href="#cb12-99"></a>    sndRt -&gt; lazy = <span class="kw">true</span>;</span>
<span id="cb12-100"><a href="#cb12-100"></a>    rt = merge(fstRt, merge(sndRt, thdRt));</span>
<span id="cb12-101"><a href="#cb12-101"></a>}</span>
<span id="cb12-102"><a href="#cb12-102"></a></span>
<span id="cb12-103"><a href="#cb12-103"></a><span class="dt">void</span> print(Treap * rt) {</span>
<span id="cb12-104"><a href="#cb12-104"></a>    <span class="cf">if</span> (rt == <span class="kw">nullptr</span>)</span>
<span id="cb12-105"><a href="#cb12-105"></a>        <span class="cf">return</span>;</span>
<span id="cb12-106"><a href="#cb12-106"></a>    <span class="cf">if</span> (rt -&gt; lazy)</span>
<span id="cb12-107"><a href="#cb12-107"></a>        rt -&gt; pushDown();</span>
<span id="cb12-108"><a href="#cb12-108"></a>    print(rt -&gt; son[<span class="dv">0</span>]);</span>
<span id="cb12-109"><a href="#cb12-109"></a>    cout &lt;&lt; rt -&gt; val &lt;&lt; <span class="st">&quot; &quot;</span>;</span>
<span id="cb12-110"><a href="#cb12-110"></a>    print(rt -&gt; son[<span class="dv">1</span>]);</span>
<span id="cb12-111"><a href="#cb12-111"></a>}</span>
<span id="cb12-112"><a href="#cb12-112"></a></span>
<span id="cb12-113"><a href="#cb12-113"></a><span class="dt">int</span> main() {</span>
<span id="cb12-114"><a href="#cb12-114"></a>    ios::sync_with_stdio(<span class="kw">false</span>);</span>
<span id="cb12-115"><a href="#cb12-115"></a>    cin.tie(<span class="dv">0</span>); cout.tie(<span class="dv">0</span>);</span>
<span id="cb12-116"><a href="#cb12-116"></a>    <span class="dt">int</span> len, qNum; cin &gt;&gt; len &gt;&gt; qNum;</span>
<span id="cb12-117"><a href="#cb12-117"></a>    Treap * rt = <span class="kw">nullptr</span>;</span>
<span id="cb12-118"><a href="#cb12-118"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= len; i++)</span>
<span id="cb12-119"><a href="#cb12-119"></a>        insert(rt, i);</span>
<span id="cb12-120"><a href="#cb12-120"></a>    <span class="cf">while</span> (qNum--) {</span>
<span id="cb12-121"><a href="#cb12-121"></a>        <span class="dt">int</span> qLeftPt, qRightPt; cin &gt;&gt; qLeftPt &gt;&gt; qRightPt;</span>
<span id="cb12-122"><a href="#cb12-122"></a>        reverse(rt, qLeftPt, qRightPt);</span>
<span id="cb12-123"><a href="#cb12-123"></a>    }</span>
<span id="cb12-124"><a href="#cb12-124"></a>    print(rt);</span>
<span id="cb12-125"><a href="#cb12-125"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb12-126"><a href="#cb12-126"></a>}</span></code></pre></div>
</div>
</div>
<div id="字典树" class="section level2">
<h2>字典树</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TrieNode {</span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="dt">bool</span> isWord;</span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="dt">int</span> nextArr[CHAR_SIZE];</span>
<span id="cb13-4"><a href="#cb13-4"></a>} TrieNode;</span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="dt">int</span> triePt;</span>
<span id="cb13-6"><a href="#cb13-6"></a></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="dt">int</span> newTrieNode() {</span>
<span id="cb13-8"><a href="#cb13-8"></a>    trieArr[triePt].isWord = <span class="kw">false</span>;</span>
<span id="cb13-9"><a href="#cb13-9"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; CHAR_SIZE; i++)</span>
<span id="cb13-10"><a href="#cb13-10"></a>        trieArr[triePt].nextArr[i] = -<span class="dv">1</span>;</span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="cf">return</span> triePt++;</span>
<span id="cb13-12"><a href="#cb13-12"></a>}</span>
<span id="cb13-13"><a href="#cb13-13"></a></span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="dt">void</span> insertName(string &amp; str) {</span>
<span id="cb13-15"><a href="#cb13-15"></a>    <span class="dt">int</span> cntPt = <span class="dv">0</span>, len = str.size();</span>
<span id="cb13-16"><a href="#cb13-16"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++) {</span>
<span id="cb13-17"><a href="#cb13-17"></a>        <span class="dt">int</span> cnt = str[i] - <span class="ch">&#39;a&#39;</span>;</span>
<span id="cb13-18"><a href="#cb13-18"></a>        <span class="cf">if</span> (trieArr[cntPt].nextArr[cnt] == -<span class="dv">1</span>)</span>
<span id="cb13-19"><a href="#cb13-19"></a>            trieArr[cntPt].nextArr[cnt] = newTrieNode();</span>
<span id="cb13-20"><a href="#cb13-20"></a>        cntPt = trieArr[cntPt].nextArr[cnt];</span>
<span id="cb13-21"><a href="#cb13-21"></a>    }</span>
<span id="cb13-22"><a href="#cb13-22"></a>    trieArr[cntPt].wordId = <span class="kw">true</span>;</span>
<span id="cb13-23"><a href="#cb13-23"></a>}</span>
<span id="cb13-24"><a href="#cb13-24"></a></span>
<span id="cb13-25"><a href="#cb13-25"></a>triePt = <span class="dv">0</span>;</span>
<span id="cb13-26"><a href="#cb13-26"></a>newTrieNode();</span></code></pre></div>
</div>
<div id="policy_based_data_structures" class="section level2">
<h2>policy_based_data_structures</h2>
<div id="heap" class="section level3">
<h3>Heap</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#include</span><span class="im">&lt;ext/pb_ds/priority_queue.hpp&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">using</span> <span class="kw">namespace</span> __gnu_pbds;</span>
<span id="cb14-3"><a href="#cb14-3"></a></span>
<span id="cb14-4"><a href="#cb14-4"></a>__gnu_pbds::priority_queue&lt;</span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="dt">int</span>,</span>
<span id="cb14-6"><a href="#cb14-6"></a>    less&lt;<span class="dt">int</span>&gt;,   <span class="co">// Smaller value at top, Big -&gt; Small when enumerating using iterator </span></span>
<span id="cb14-7"><a href="#cb14-7"></a>    pairing_heap_tag <span class="co">// or: binary_heap_tag, binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>&gt; pq;</span>
<span id="cb14-9"><a href="#cb14-9"></a></span>
<span id="cb14-10"><a href="#cb14-10"></a>fst.join(snd);</span></code></pre></div>
</div>
<div id="set" class="section level3">
<h3>Set</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="pp">#include </span><span class="im">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="pp">#include </span><span class="im">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co">// using namespace __gnu_pbds;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a></span>
<span id="cb15-5"><a href="#cb15-5"></a>__gnu_pbds::tree&lt;</span>
<span id="cb15-6"><a href="#cb15-6"></a>    <span class="dt">int</span>,</span>
<span id="cb15-7"><a href="#cb15-7"></a>    __gnu_pbds::<span class="dt">null_type</span>,</span>
<span id="cb15-8"><a href="#cb15-8"></a>    less&lt;<span class="dt">int</span>&gt;,  <span class="co">// less_equal&lt;int&gt;: lower_bound -&gt; upper_bound</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>    __gnu_pbds::rb_tree_tag,</span>
<span id="cb15-10"><a href="#cb15-10"></a>    __gnu_pbds::tree_order_statistics_node_update</span>
<span id="cb15-11"><a href="#cb15-11"></a>&gt; st;</span>
<span id="cb15-12"><a href="#cb15-12"></a></span>
<span id="cb15-13"><a href="#cb15-13"></a>st.order_of_key(val);</span>
<span id="cb15-14"><a href="#cb15-14"></a>st.find_by_order(val);</span>
<span id="cb15-15"><a href="#cb15-15"></a></span>
<span id="cb15-16"><a href="#cb15-16"></a>fst.join(snd); <span class="co">// Join two trees (RANGE of key value should not intersect)</span></span>
<span id="cb15-17"><a href="#cb15-17"></a>fst.split(val, snd);</span></code></pre></div>
</div>
</div>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>4146 字</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2019-11-18 09:07 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://codgician.me/zh-hans/icpc/templates/offline-algorithms/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;新</span><br><span>Offline Algorithms</span>
			</a>
			<a class="prev-post" href="https://codgician.me/zh-hans/icpc/templates/graph-theory/">
				<span class="post-nav-label">旧&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Graph Theory</span>
			</a>
		</div>
		<div id="comments" class="thin">
    <script async src="https://utteranc.es/client.js"
        repo="codgician/homepage-comments"
        issue-number="13"
        label=""
        theme="photon-dark"
        crossorigin="anonymous"
    ></script>
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 <a href="https://codgician.me/">codgician</a> &#183; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://codgician.me/zh-hans/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://codgician.me/js/main.min.35ccbf1cdceb91e4c64c06b5d009d6e2977fafe56beda7762febd4e67528d2ac.js" integrity="sha256-Ncy/HNzrkeTGTAa10AnW4pd/r+Vr7ad2L+vU5nUo0qw=" crossorigin="anonymous"></script>
	
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-97035940-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha256-F/Xda58SPdcUCr+xhSGz9MA2zQBPb0ASEYKohl8UCHc=" crossorigin="anonymous"></script>
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha256-90d2pnfw0r4K8CZAWPko4rpFXQsZvJhTBGYNkipDprI=" crossorigin="anonymous"
        onload="
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\[', right: '\\]', display: true},
                    {left: '\\(', right: '\\)', display: false}
                ]
            });
        "></script><script>
            let t = document.getElementById('TOC');
            if (t !== null) {
                t.id = 'toc';
                t.innerHTML = '<div class=\'toc-title\'>目录</div><nav id=\'TableOfContents\'>' + t.innerHTML + '</nav>';
            }
        </script>
</body>

</html>
